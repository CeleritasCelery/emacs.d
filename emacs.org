#+TITLE: Emacs Literate Configuration
#+AUTHOR: Troy Hinckley
#+PROPERTY: header-args :tangle yes


* Configuration
:PROPERTIES:
:VISIBILITY: children
:END:
** About this file
This is an Emacs literate configuration. It contains the basic structure
of a literate config along with some optimizations to ensure a fast load time.

I am using =$= as my personal namespace. I like it because it reminds
me about perl, it is really simple, and this is lisp, so I can make my
namespace whatever I want.

** Emacs Initialization
*** Personal Information
Let's set some variables with basic user information.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Troy Hinckley"
        user-mail-address "t.macman@gmail.com")
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (defvar $leader-key "SPC"
    "leader key used to quicky access commands.")

  (defvar $mm-leader-key ","
    "leader key for major mode specific commands")
#+END_SRC

don't use menu or scroll bars. We want the UI to be as clean as
possible.
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)
  (setq inhibit-startup-screen t)
  (toggle-frame-fullscreen)
  (add-hook 'focus-in-hook 'redraw-display)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode)
#+END_SRC

use =y= and =n= instead of =yes= and =no=
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** tangling
    we want to tangle on exit so that it will make startup time
    quicker.
#+BEGIN_SRC emacs-lisp
  (defun $tangle-init-file ()
    "tangle my emacs org file before closing to make startup faster."
    (require 'ob-tangle)
    (org-babel-tangle-file (expand-file-name "emacs.org" user-emacs-directory)
                           (expand-file-name "emacs.el" user-emacs-directory)))

  (add-hook 'kill-emacs-hook '$tangle-init-file)
#+END_SRC

    by setting the initial mode we won't have to load lisp at startup
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'fundamental-mode)
#+END_SRC
* Packages
:PROPERTIES:
:VISIBILITY: children
:END:
** Package Manager
We are going to use =straight.el= as package manager because it allows
us to easily maintain private repos of packages. There is bootstrap
code on the website, but I could not get it to work behind the proxy
so I cloned it myself.  I will see later if I can get the bootstrap
install code to work.

I also byte-complied the bootstrap file which shaves about 500 ms of
the startup time. This is still slower then using package.el, but I
think it is worth it.

#+BEGIN_SRC emacs-lisp
  (load (expand-file-name "straight/repos/straight.el/bootstrap" user-emacs-directory) nil 'nomessage)
#+END_SRC

** Use-package

=use-package= is a macro that allows to easily define and load other
packages.  It is the first thing we want to install. I am using my own
fork of the package that contains more sane defaults for the =:hook=
keyword (essentially it automatically adds the =-mode= suffix).

#+BEGIN_SRC emacs-lisp
  (straight-use-package
   '(use-package
      :type git :host github :repo "CeleritasCelery/use-package"
      :upstream (:host github
                       :repo "jwiegley/use-package")))
#+END_SRC

Setting =straight-use-package-by-default= to =t= we can ensure that
=use-pacakge= will use =straight.el= to install missing packages for
us. Always defer and always ensure will guarantee that all
dependencies are loaded and that packages are autoloaded unless
explicitly stated otherwise.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t
        use-package-always-defer t
        use-package-always-ensure t)
#+END_SRC

This allows us to remove mode-line lighters
#+BEGIN_SRC emacs-lisp
  (use-package delight)
#+END_SRC

The "Emacs Startup profiler". This allows us to see what parts of the
config are most heavily impacting start up time. you can't optimize
until you have good info
#+BEGIN_SRC emacs-lisp
  (use-package esup)
#+END_SRC

** bootstrap
packages that are used to setup the my emacs enviroment. They are
needed as dependaceies for other packages later on.

This package lets us use "SPC" as leader key for other keybindings. It
also provides a lot of helper functions to make binding keys easier
and smarter.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config
    (general-create-definer $leader-set-key
      :prefix $leader-key
      :states 'motion
      :keymaps 'override)
    (general-create-definer $leader-local-set-key
      :prefix $mm-leader-key
      :states 'motion))
#+END_SRC

Use tab for indentation and symbol completion
#+BEGIN_SRC emacs-lisp
  (general-define-key :states '(insert normal visual)
                      "TAB" 'indent-for-tab-command)
  (setq tab-always-indent 'complete)
#+END_SRC

make sure that third party files cannot leave conifg and save files
all over the place
#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t)
#+END_SRC

save minibuffer history between sessions.
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :straight nil
    :defer 1
    :config
    (savehist-mode))
#+END_SRC

hydra provides repeatable keybindings to quickly execute multiple
commands
#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

** UI
packages that used to improve the visuals and interface for Emacs

Setup the font that I want to use. Hasklig is a fork of /Source Code
Pro/ that contains ligatures.
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                    :family "Hasklig"
                    :height 110)
#+END_SRC

use a hydra to scale the text size
#+BEGIN_SRC emacs-lisp
  (defhydra text-scale (:hint nil)
    "
  Text Scale
    [_+_/_=_] scale up [_-_] scale down [_0_] reset font [_q_] quit
  "
    ("+" text-scale-increase)
    ("=" text-scale-increase)
    ("-" text-scale-decrease)
    ("0" (text-scale-set 0))
    ("q" nil :exit t))
  ($leader-set-key
    "z" 'text-scale/body)
#+END_SRC

change the size of the VNC to match the size of the monitor that I am
using. Since I always run my VNC fullscreen having the VNC resolution
not match the resolution of my monitor results in weird text sizes.
#+BEGIN_SRC emacs-lisp
  (defun vnc-resize (size)
    (shell-command (concat "xrandr --size " size)))

  (defhydra vnc-resize (:columns 2 :exit t)
    "VNC Resize"
    ("l" (vnc-resize "1920x1200") "single monitor (large)")
    ("m" (vnc-resize "1536x864") "mobile")
    ("w" (vnc-resize "3840x1200") "double monitor (wide)")
    ("s" (vnc-resize "1920x1080") "short"))
  ($leader-set-key
    "n"  'vnc-resize/body)
#+END_SRC

telephone line is powerline that has some nice defaults. I am still
not satisfied with my mode-line, and when I get some time I would love
to customize it to my extact taste. But in the meantime this is
working.

*** TODO [#B] create a list of customization for the modeline.
*** TODO [#C] try out the doom modeline
#+BEGIN_SRC emacs-lisp
  (use-package telephone-line
    :init
    (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
          telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
          telephone-line-primary-right-separator 'telephone-line-cubed-right
          telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right
          telephone-line-lhs '((evil   . (telephone-line-evil-tag-segment))
                               (accent . (telephone-line-vc-segment
                                          telephone-line-process-segment))
                               (nil    . (telephone-line-buffer-segment))))
    (telephone-line-mode))
#+END_SRC

Creating a collection of themes that I like. I can use
=counsel-load-themes= to switch between them. Some of these themes do
not have all faces that I would like, so When I get some time I will
modify them.

*** TODO [#C] add missing faces to themes
#+BEGIN_SRC emacs-lisp
  (use-package challenger-deep-theme)
  (use-package gruvbox-theme)
  (use-package darktooth-theme)
  (use-package spacemacs-theme)
  (use-package dracula-theme)
  (use-package moe-theme
    :init
    (add-to-list 'custom-theme-load-path
                 "~/.emacs.d/straight/build/moe-theme/"))
  (use-package doom-themes)
  (use-package solarized-theme)
  (use-package color-theme-sanityinc-tomorrow)
  (use-package noctilux-theme)
  (use-package flatland-theme)
  (use-package monokai-theme)

  (load-theme 'darktooth t)
#+END_SRC

which key is an awesome package that shows me the key I can press
after choosing a prefix key.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight
    :demand t
    :init
    (setq which-key-idle-delay 0.5
          which-key-idle-secondary-delay 0.1
          which-key-allow-evil-operators t)
    :config
    (which-key-mode))
#+END_SRC

This is a window managment package that I am testing out. it works
pretty well, but I have a couple of things I would like to change.
1. there is no good way to operate on the current window, you have to
   knows its letter first, which is not always easy. my idea is that
   the capital of action would operate on the current window. For
   example =SPC wX= would delete the current window. This would take a
   fair amount of work to change the package however. Or at least so I
   think, I have not actually looked at it yet. I want to wait for
   while to make this change so that I can get the muscle memory down
   and see if that makes this easier with this package.
2. This package will split the window but leave the cursor in the old
   window. I relalize this is just a little thing. but it is very
   unintuitive for me and I have to think about it every time.
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :init
    (setq aw-dispatch-always t
          aw-background nil
          aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    ($leader-set-key
      "w" 'ace-window)
    :config
    (add-to-list 'aw-dispatch-alist '(?w $toggle-maximize-window)))
#+END_SRC

this is a window managment package that is very minimalistic. I am
going to use it until I find a case where it won't work, then I might
try a more powerful package like popwin.
#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :demand t
    :init
    (setq shackle-rules
          '((help-mode :select t)
            ("*ielm*" :popup t)))
    :config
    (shackle-mode))
#+END_SRC

A collection of functions stolen from Spacemacs that allows me to more
easily manipulate files, buffers, and windows. I figure it is easier
to keep in a seperate file then to try and load them in my main
config. still not sure if they will stay there long term.
#+BEGIN_SRC emacs-lisp
  (use-package init-display
    :straight (init-display
               :local-repo "init-display")
    :init
    ($leader-set-key
      "TAB" '$alternate-buffer
      "fe" '$find-user-config-file
      "fc" '$copy-file
      "fy" '$show-and-copy-buffer-filename
      "fD" '$delete-file
      "fR" '$rename-file
      "b" '(:ignore t :wk "buffers")
      "bs" '$open-scratch-buffer
      "q" '(:ignore t :wk "quit")
      "qq" '$quit-emacs))
#+END_SRC

persp-mode is layout managment package that provides way more
functionality then I want. All I really are about is having named
groups of eyebrowse window configs. I could probably drop persp mode
and create a wrapper around =eyebrowse= that could group the window
configs under a name. I would use only eyebrowse, but then I would
have to try to remember what windows go to what project, and that can
get a little confusing. Also I have created some fuctions that make
shell-pop perspective local, and I really like that feature.
#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :init
    (setq persp-auto-save-opt 0)
    (defhydra persp (:exit t :pre (persp-mode))
      "Perspective"
      ("l" persp-switch "switch")
      ("n" persp-next "next" :exit nil)
      ("p" persp-prev "previous" :exit nil)
      ("r" persp-rename "rename")
      ("a" persp-add-buffer "add buffer")
      ("k" persp-remove-buffer "remove buffer")
      ("D" persp-kill "Delete perspective"))
    ($leader-set-key
      "l" 'persp/body))
#+END_SRC

minimal window managment package.
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :init
    (defhydra eyebrowse (:exit t :pre (eyebrowse-mode))
      "Window Config"
      ("e" eyebrowse-switch-to-window-config "switch")
      ("n" eyebrowse-next-window-config "next" :exit nil)
      ("p" eyebrowse-prev-window-config "previous" :exit nil)
      ("d" eyebrowse-close-window-config-prompt "close")
      ("1" eyebrowse-switch-to-window-config-1)
      ("2" eyebrowse-switch-to-window-config-2)
      ("3" eyebrowse-switch-to-window-config-3)
      ("4" eyebrowse-switch-to-window-config-4)
      ("5" eyebrowse-switch-to-window-config-5))
    ($leader-set-key
      "e" 'eyebrowse/body)
    :config
    (general-define-key
     :keymaps 'eyebrowse-mode-map
     "C-c C-w" nil))
#+END_SRC

This package is really just a lift of the layout functionality from
spacemacs. It essentially makes window configs layout local and add
some helper helm sources for perspectives.
#+BEGIN_SRC emacs-lisp
  (use-package layouts
    :straight (layouts
               :local-repo "layouts")
    :after (persp-mode eyebrowse))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :init
    ($leader-set-key
      "qr" 'restart-emacs))

#+END_SRC

#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "q" '(:ignore t :wk "quit")
    "qq" '$quit-emacs)
#+END_SRC

changing the volume on my mic triggers these bindings. So we ignore them.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "<XF86AudioLowerVolume>" 'ignore
   "<XF86AudioRaiseVolume>" 'ignore)
#+END_SRC

** Ivy

#+BEGIN_SRC emacs-lisp
  (defvar $use-ivy nil
    "use Ivy for completion")
  (defvar $use-helm t
    "use helm for completion")
#+END_SRC

I feel like ivy is simpler to setup so I am going to give it a try. I am going
to have to try to fix =counsel-ag= out of order matching if I want to live with
it though.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :straight
    (ivy
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper"))
    :delight
    :general
    (:keymaps 'ivy-minibuffer-map
              "C-j" 'ivy-next-line
              "C-k" 'ivy-previous-line
              "C-h" "DEL"
              "C-S-H" help-map
              "C-l" 'ivy-alt-done
              "<C-return>" 'ivy-immediate-done)
    :init
    (setq ivy-height 15
          ivy-use-virtual-buffers t
          ivy-extra-directories nil
          ivy-use-selectable-prompt t
          ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
    ($leader-set-key
      "bb" 'ivy-switch-buffer
      "r" 'ivy-resume)
    :config
    (ivy-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra
    :straight
    (ivy-hydra
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper"))
    :after (ivy hydra))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :straight
    (swiper
     :files ("swiper.el")
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper"))
    :init
    ($leader-set-key
      "s" '(:ignore t :wk "search")
      "ss" 'swiper))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :straight
    (counsel
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper"))
    :delight
    :init
    ($leader-set-key
      "ff" 'counsel-find-file
      "sf" 'counsel-ag
      "SPC" 'counsel-M-x)
    :config
    (counsel-mode))

  (defun $open-file-in-clipboard ()
    "open the current file in the clipboard"
    (interactive)
    (let* ((file (substitute-env-vars (string-trim (current-kill 0))))
           (default-directory (file-name-directory file)))
      (counsel-find-file (file-name-nondirectory file))))
  ($leader-set-key
    "fo" '$open-file-in-clipboard)
#+END_SRC

This package makes =ivy-switch-buffer= behave more like =helm-mini=
(i.e. displays the buffer type and full path to recentf files)
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :demand t
    :after ivy
    :config
    (setq ivy-virtual-abbreviate 'full
          ivy-rich-switch-buffer-align-virtual-buffer t)
    (ivy-set-display-transformer 'ivy-switch-buffer 'ivy-rich-switch-buffer-transformer))
#+END_SRC

smex is an enchanced version of =M-x= that will record history and is
integrated into ivy
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :init
    (setq smex-history-length 32))
#+END_SRC

** evil
evil is the Extensible VI Layer. It gives us all the power of vim
without the draw back of using vimscript for config.

Evil will be loaded by one of it's dependacey packages. We need to set
=evil-want-integration= before loading evil so that =evil-collection= can
overide the modes.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration nil
          evil-kill-on-visual-paste nil
          evil-search-module 'evil-search
          evil-magic 'very-magic ;; make evil search regex more PCRE compatible
          evil-want-C-u-scroll t
          evil-want-C-d-scroll t
          evil-want-C-w-delete t
          evil-want-C-i-jump t
          evil-want-Y-yank-to-eol t
          evil-ex-search-vim-style-regexp t)
    :config
    (general-swap-key nil 'motion "0" "^")
    (evil-mode 1)

    (general-define-key
     :states 'motion
     [remap evil-next-line] 'evil-next-visual-line
     [remap evil-previous-line] 'evil-previous-visual-line)

    (general-define-key
     :states 'operator
     [remap evil-next-line] 'evil-next-line
     [remap evil-previous-line] 'evil-previous-line)

    (defvar evil-v$-gets-eol nil)

    (evil-define-motion evil-end-of-line (count)
      "Move the cursor to the end of the current line. If COUNT is
    given, move COUNT - 1 lines downward first."
      :type inclusive
      (move-end-of-line count)
      (when evil-track-eol
        (setq temporary-goal-column most-positive-fixnum
              this-command 'next-line))
      (unless (and (evil-visual-state-p) evil-v$-gets-eol)
        (evil-adjust-cursor)
        (when (eolp)
          ;; prevent "c$" and "d$" from deleting blank lines
          (setq evil-this-type 'exclusive))))

    (evil-define-text-object evil-inner-buffer (count &optional beg end type)
      (list (point-min) (point-max)))

    (evil-define-text-object evil-pasted (count &rest args)
      (list (save-excursion (evil-goto-mark ?\[) (point))
            (save-excursion (evil-goto-mark ?\]) (point))))

    (evil-define-text-object evil-filename (count &rest args)
      (let ((bounds (bounds-of-thing-at-point 'filename)))
        (list (car bounds) (cdr bounds))))

    (general-define-key
     :keymaps 'evil-inner-text-objects-map
     "g" 'evil-inner-buffer
     "P" 'evil-pasted
     "F" 'evil-filename))
#+END_SRC

=C-i= can be used to move forward in cursor jumps, but Emacs binds it to =TAB=, so
we rebinding it to =H-i=. Though this won't work in the terminal
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'input-decode-map
   "C-i" "H-i")
  (general-define-key
   :states 'normal
   "H-i" 'evil-jump-forward)
#+END_SRC

We want to hybridize some usefull emacs commands with better evil keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states 'insert
   "C-y" 'yank)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "h" '(:ignore t :wk "help")
    "hd" '(:ignore t :wk "describe")
    "hdf" 'describe-function
    "hdv" 'describe-variable
    "hdk" 'describe-key
    "hde" 'describe-face
    "hdm" 'describe-mode
    "hs"  'profiler-start
    "hr"  'profiler-report
    "f" '(:ignore t :wk "files")
    "fa" 'save-buffer
    "bd" 'kill-buffer
    "br" 'rename-buffer)
#+END_SRC

evil unimpaired binds some usefull functions to some quick keys.
#+BEGIN_SRC emacs-lisp
  (use-package evil-unimpaired
    :straight
    (evil-unimpaired
     :type git :host github :repo "CeleritasCelery/evil-unimpaired"
     :upstream (:host github
                      :repo "zmaas/evil-unimpaired"))
    :defer 2
    :init
    (setq evil-unimpaired-leader-keys '("gk" . "gj"))
    :config
    (evil-unimpaired-mode))
#+END_SRC

we only want evil snipe for the ability to repeat =f,F,t,T=. I find
avy is better for the actual sniping
#+BEGIN_SRC emacs-lisp
  (use-package evil-snipe
    :demand t
    :after evil
    :init
    (setq evil-snipe-override-evil-repeat-keys nil)
    :config
    (evil-snipe-override-mode))
#+END_SRC

this package adds a tilde to the fringe of every line that is
empty. eventually I just want to replace this with a save buffer hook
that removes additional lines at the end of the file.
#+BEGIN_SRC emacs-lisp
  (use-package vi-tilde-fringe
    :delight
    :demand t
    :config
    (global-vi-tilde-fringe-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :delight
    :demand t
    :init
    (setq evil-escape-unordered-key-sequence t
          evil-escape-key-sequence "jk")
    :config
    (evil-escape-mode))
#+END_SRC

evil collection evilifies several major and minor modes to make them
behave better with evil.
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :demand t
    :after evil
    :config
    (defun $unmap-leader (_m keymaps)
      (when keymaps
        (general-define-key
         :states 'normal
         :keymaps keymaps
         $leader-key nil
         $mm-leader-key nil)))
    (add-hook 'evil-collection-setup-hook '$unmap-leader)
    (evil-collection-init '(calc calendar custom debug eldoc
    elisp-mode dired help info occur popup profiler wgrep wdired
    which-key)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package evil-ediff
    :commands evil-ediff-startup-hook
    :hook (ediff-startup . evil-ediff-startup-hook)
    :init
    (evil-set-initial-state 'ediff-mode 'motion)
    :config
    (evil-ediff-adjust-help))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :defer 4
    :config
    (global-evil-surround-mode)
    (general-define-key
     :states 'visual
     :keymaps 'evil-surround-mode-map
     "s" 'evil-surround-region
     "S" 'evil-substitute))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package evil-nerd-commenter
    :commands (evilnc-copy-and-comment-operator
               evilnc-comment-operator)
    :init
    ($leader-set-key
      "." '(evilnc-copy-and-comment-operator :wk "copy-and-comment")
      ";" '(evilnc-comment-operator :wk "comment")))
#+END_SRC

These packages are great at providing editor shortcuts for editing
lisp. There are several things I want to change however. 
- I hate that is overrides =v=, as I use that character all the time
  for motions. I think I am going to delegate only =C-v= and =V= to
  the lispy functions and leave the rest untouched. probably should
  use a hydra.
- I am starting to think that I would be better off just using the
  evil lisp state, and then binding some of the most convient
  functions from both to the new state. Some of the evil-cleverparens
  functions are smarter then their equvilents in lispyville.
#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :delight
    :hook emacs-lisp-mode
    :init
    (setq lispy-colon-p nil))

  (use-package lispyville
    :delight
    :hook lispy-mode
    :init
    (setq lispyville-key-theme
          '(operators
            c-w
            slurp/barf-cp
            additional
            additional-movement
            additional-insert
            additional-wrap
            mark)))
#+END_SRC

** Helm
helm is the more powerfull of the two between itself and ivy. I really
want to give Ivy a good try because it seems snappier on large files,
but there are still some issues that gives helm the advantage
- =helm-ag= supports out of order matching
- helm doesn't break when using "regex" characters in pattern
- helm is integrated with dired.
- helm supports marking files
- helm file sorting is more sane
- helm-mini has better recentf functionality
- helm supports frames, which makes swoop easier
- =counsel-fzf= is broken, but =helm-fzf= works great
- helm supports marking, which is very efficent.

my biggest beef with helm is that when using tramp it very slow. I
will have to look into seeing what can be done about that. But the
code is so intimidating. But thankfully I only use tramp about once a
week to copy some files, so it is not a big deal.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :general
    (:keymaps 'helm-map
              "C-j" 'helm-next-line
              "C-k" 'helm-previous-line
              "C-h" 'helm-next-source
              "C-S-h" 'describe-key
              "C-l" "RET"
              "C-z" 'helm-select-action
              "TAB" 'helm-execute-persistent-action)
    (:keymaps '(helm-find-files-map
                helm-read-file-map)
              "C-l" 'helm-execute-persistent-action
              "C-h" 'helm-find-files-up-one-level))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package swoop)

  (use-package helm-ag)
#+END_SRC

** editing

general editing configuration. We only want to use tabs in specific major modes
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

move me to the start of the line or start of code, based on heuristics
#+BEGIN_SRC emacs-lisp
  (use-package mwim
    :general
    (:states 'insert
             "C-e" 'mwim-end
             "C-a" 'mwim-beginning))
#+END_SRC

avy is an awesome jump to point package.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :init
    (setq avy-timeout-seconds 0.3)
    (general-define-key
     :states '(normal visual)
     ";" 'avy-goto-char-timer)
    :config
    (evil-collection-init 'avy))
#+END_SRC

provides snippets for adding complex blocks. use it with =M-/=
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish
    :defer 3
    :config
    (let ((inhibit-message t))
      (yas-global-mode)))
  (use-package yasnippet-snippets
    :diminish
    :after yasnippet)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :defer 2
    :init
    (setq projectile-enable-caching t)
    :config
    (projectile-global-mode))

  (use-package counsel-projectile
    :init
    (push '((nil . "counsel-projectile") . (nil . "proj")) which-key-replacement-alist)
    ($leader-set-key
      "p" '(:ignore t :wk "project")
      "pp" 'counsel-projectile
      "pP" 'counsel-projectile-switch-project
      "ps" 'counsel-projectile-ag
      "pf" 'counsel-projectile-find-file
      "pb" 'counsel-projectile-switch-to-buffer
      "pd" 'counsel-projectile-find-dir))
#+END_SRC

** files

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (setq recentf-max-saved-items 500))
#+END_SRC

** git

don't ask about following symlinks
#+BEGIN_SRC emacs-lisp
     (setq vc-follow-symlinks t)
#+END_SRC

magit is the best git porcelain that exists, so far as I can tell. 
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    (setq magit-git-executable
          "/usr/intel/pkgs/git/2.12.0/bin/git") ;; get around old magit git version problem
    ($leader-set-key
      "g" '(:ignore t :wk "git")
      "gs" 'magit-status)

    ($leader-local-set-key
      :keymaps 'with-editor-mode-map
      "," 'with-editor-finish
      "k" 'with-editor-cancel)
    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

I don't like to commit to my github repos using my work credentials,
but I can't use those credentials on my work repos. there I set
=useconfigonly = true= so that I have to set the credentials for every
repo. I can use these functions as short hand.
#+BEGIN_SRC emacs-lisp
  (defun $git-work-user ()
    "Set my work credentials"
    (interactive)
    (shell-command "git config --local user.name \"Hinckley, Troy J\" &&
     git config --local user.email troy.j.hinckley@intel.com"))

  (defun $git-private-user ()
    "Set my work credentials"
    (interactive)
    (shell-command "git config --local user.name CeleritasCelery &&
     git config --local user.email t.macman@gmail.com"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :demand t
    :after magit
    :config
    (general-define-key
     :keymaps 'magit-mode-map
     "SPC" nil))

  (use-package git-timemachine
    :init
    ($leader-set-key
      "gt" 'git-timemachine))
#+END_SRC

git gutter uses the the margin to display the git status. the frige
package uses the fringe instead of the margin. This means that it
won't conflict with linum-mode. However since I don't need linum mode
I can probably remove git gutter fringe all together. All the that it
would offer me is that I could display of the left side, which I may
want to do when I enable flycheck.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :defer 3
    :init
    (setq git-gutter:diff-option "-w")
    :config
    (global-git-gutter-mode))

  (use-package git-gutter-fringe
    :diminish
    :demand t
    :after git-gutter)
#+END_SRC
** shell

comint is the generic backend for REPL's and shells. We are giving it
more bash-it style behavior where I can enter some text and then use
the previous command to match against it. Also we can use ivy to
search through the command history. also whenever we try to go to the
previous command it will automatically move us the the command line.
#+BEGIN_SRC emacs-lisp
  (use-package comint
    :straight nil
    :general
    (:keymaps 'comint-mode-map
              "C-k" 'comint-previous-matching-input-from-input
              "C-j" 'comint-next-matching-input-from-input
              "C-S-k" 'comint-previous-prompt
              "C-S-j" 'comint-next-prompt
              [remap comint-dynamic-list-input-ring] 'counsel-shell-history)
    :init
    (setq comint-scroll-to-bottom-on-input t
          comint-process-echoes t
          comint-prompt-read-only t))

  (defun $goto-cmd-line (&rest _)
    (goto-char (point-max)))

  (general-advice-add '(comint-next-matching-input-from-input
                        comint-previous-matching-input-from-input) :before '$goto-cmd-line)
#+END_SRC

these are utility functions used to setting up the Emacs shell.
#+BEGIN_SRC emacs-lisp
  (use-package shell
    :straight nil
    :gfhook company-mode
    :init
    (setq shell-file-name "bash"))

  (defvar $dir-history nil
    "previous shell directories")
  (make-variable-buffer-local '$dir-history)

  (defun $select-shell-history ()
    (interactive)
    (goto-char (point-max))
    (insert (concat "cd " (string-remove-prefix (or (file-remote-p default-directory) "")
                                                (completing-read "directory:" $dir-history)))))

  (general-define-key
   :keymaps 'shell-mode-map
   "C-c C-j" '$select-shell-history)

  (defun $track-shell-directory (str)
    "use the proc filesytem to get the current directory.
  Works on remote shells as well if `shx' and `shx-cmd-set-pid' are used. The
  remote shell will need to echo it's PID in the rc file in the form of `shx'
  markup."
    (when (string-match comint-prompt-regexp str)
      (--when-let (-some->> ($get-shell-pid)
                            (format "/proc/%s/cwd")
                            (concat (file-remote-p default-directory))
                            file-symlink-p
                            cd)
        (unless (equal it (car $dir-history))
          (push it $dir-history))))
    str)

  (defun $get-shell-pid ()
    (or $shell-pid
        ;; we can only use the buffer process PID
        ;; with local shells
        (unless (file-remote-p default-directory)
          (-some->> (current-buffer)
                    get-buffer-process
                    process-id))))

  (defvar $shell-pid nil
    "Set this variable when the buffer process PID is not the shell PID.")
  (make-variable-buffer-local '$shell-pid)

  (defun shx-cmd-set-pid (pid)
    "(SAFE) sets env local shell PID.
  Add the following lines to (or equvilent) to your shell starup file

  echo \"<set-pid $$>\""
    (setq $shell-pid pid))

  (defun $supress-hostkey-warning (str)
    "EC machines issue a benign but really annoying warning that the EC people
    don't have the technical competence to fix. It has the following form:

    add_host_to_hostkeys: failed to open <missing path> - reason Permission denied "
    (if (string-match "add_host_to_hostkeys: failed to open" str) "" str))

  (defun $shell-mode-hook ()
    (shell-dirtrack-mode 0)
    (setq-local comint-prompt-regexp (rx bol "╰─→ " eos))
    (modify-syntax-entry ?= ".")
    (setq-local company-backends '(company-async-files (company-command company-env) company-fish company-capf company-dabbrev-code))
    (general-add-hook 'comint-preoutput-filter-functions
                      '($supress-hostkey-warning $track-shell-directory) nil 'local))
  (add-hook 'shell-mode-hook '$shell-mode-hook)

  (defun $tcsh-remote-shell (fn &rest args)
    (if (file-remote-p default-directory)
        (let ((shell-file-name "tcsh"))
          (apply fn args))
      (apply fn args)))

  (general-advice-add '(shell-pop shell) :around '$tcsh-remote-shell)
#+END_SRC

shx mode allows us to call emacs lisp functions from within the
builtin shell, gives us the best of both worlds.
#+BEGIN_SRC emacs-lisp
  (use-package shx
    :diminish
    :hook shell-mode)
#+END_SRC

the =EMACS_CAPTURE_ENV= is used as part of my tcshrc file to source
the proper env scripts so that all these variables are set
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :defer 6
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    (exec-path-from-shell-initialize)

    (let ((exec-path-from-shell-shell-name "tcsh")
          (exec-path-from-shell-arguments nil))
      (setenv "EMACS_CAPTURE_ENV" "1")
      (exec-path-from-shell-copy-envs '("IP_MODELS"
                                        "IP_RELEASES"
                                        "GIT_REPOS"
                                        "GLOBAL_TOOLS"
                                        "RTLMODELS"
                                        "SPF_PERL_LIB"
                                        "SPF_ROOT"))
      (setenv "EMACS_CAPTURE_ENV" nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :init
    ;; https://github.com/kyagi/shell-pop-el/issues/51
    (add-to-list 'shackle-rules `(,(rx "*shell*") :regexp t :same t))
    ($leader-set-key
      "'" 'shell-pop)
    :config
    (advice-add 'shell-pop--cd-to-cwd
                :before-until (defun $shell-in-cwd-p (cwd)
                                (file-equal-p default-directory cwd)))

    (advice-add 'shell-pop--cd-to-cwd
                :after (defun $scroll-shell-pop (_)
                         (scroll-down 1))))
#+END_SRC

I wrote this package to do async file completion. This is especially
true when using this in a shell, where you don't want to block the ui
while typing.
#+BEGIN_SRC emacs-lisp
  (use-package company-async-files
    :after company
    :straight
    (company-async-files
     :type git :host github :repo "CeleritasCelery/company-async-files")
    :init
    (add-to-list 'company-backends 'company-async-files)
    (delete 'company-files company-backends))
#+END_SRC

this is a package that I wrote to fallback on fish shell for
completion candidates. I think at some point I would like to
reimplement that argument parsing functionality in lisp and remove the
dependacey on fish.
#+BEGIN_SRC emacs-lisp
  (use-package company-fish
    :after company
    :straight
    (company-fish
     :type git :host github :repo "CeleritasCelery/company-fish")
    :init
    (add-to-list 'company-backends 'company-fish))
#+END_SRC

set of packages I wrote to add completion for enviroment variables and
commands, currently broken, I tried to remove dependencies on external
packages, but that wasn't really necessary.
#+BEGIN_SRC emacs-lisp
  (use-package local-env
    :straight
    (local-env :type git
               :host github
               :repo "CeleritasCelery/local-env-mode"
               :files ("local-env.el")))

  (use-package company-env
    :straight
    (company-env :type git
                 :host github
                 :repo "CeleritasCelery/local-env-mode"
                 :files ("company-env.el")))

  (use-package company-command
    :straight
    (company-command :type git
                     :host github
                     :repo "CeleritasCelery/local-env-mode"
                     :files ("company-command.el")))
#+END_SRC

* Languages
:PROPERTIES:
:VISIBILITY: children
:END:
** General
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

I don't want to use return for completion because that often
interferces with just regular typing. So i have gotten in the habit of
just using =C-l=
#+BEGIN_SRC emacs-lisp
  (use-package company
    :delight
    :general
    (:keymaps 'company-active-map
              "RET" nil
              [return] nil
              "C-l" 'company-complete-selection)
    :hook '(prog-mode org-mode)
    :init
    (setq company-idle-delay 0.2
          evil-collection-company-use-tng nil)
    (evil-collection-init 'company))

  (use-package company-statistics
    :demand t
    :after company
    :config
    (company-statistics-mode))

  (use-package company-shell
    :after company)
#+END_SRC
** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight nil
    :gfhook org-indent-mode $org-truncate-lines
    :init
    ($leader-local-set-key
      :keymaps 'org-mode-map
      "," 'org-edit-special
      "g" 'counsel-org-goto)
    (setq org-enforce-todo-dependencies t
          org-todo-keywords '((sequence "TODO(t)" "BLOCK(b@!)" "DOING(g)" "|" "DONE(d)")
                              (sequence "|" "CANCELED(c@)"))
          org-priority-faces '((?A . (:foreground "OrangeRed"))
                               (?B . (:foreground "yellow3"))
                               (?C . (:foreground "ForestGreen"))))
    (defun $org-truncate-lines ()
      (let ((inhibit-message t))
        (toggle-truncate-lines)))
    :config
    (add-to-list 'org-structure-template-alist
                 '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight nil
    :config
    (general-advice-add '(org-capture-place-template org-edit-src-code)
                        :around (defun $suppress-delete-other-windows (orig-fn &rest args)
                                  (cl-letf (((symbol-function 'delete-other-windows)
                                             (symbol-function 'ignore)))
                                    (apply orig-fn args))))

    (defun $org-archive-done-tasks ()
      "move tasks that are completed to the archive file."
      (interactive)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
       "/DONE" 'file)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
       "/CANCELED" 'file))
    ($leader-local-set-key
      :keymaps 'org-mode-map
      "a" '$org-archive-done-tasks)

    (defun $org-smart-return ()
      "if in a list return should add a new item. If the item is
  blank, we want to break out of the list and delete the blank
  item"
      (interactive)
      (if (org-at-item-p)
          (if (and (looking-back (rx space) (- (point) 1))
                   (memq (- (point) (org-in-item-p))
                         (number-sequence 1 3)))
              ;; If at a blank item, delete it
              (progn
                (beginning-of-line)
                (kill-line)
                (insert "\n")
                (org-return))
            ;; If at a non-blank item, insert a new item
            (org-return)
            (org-insert-item))
        ;; If not at item, normal return
        (org-return)))
    (general-define-key
     :keymaps 'org-mode-map
     "<ret>" '$org-smart-return
     "RET" '$org-smart-return)

    (defun $org-procrastinate (arg)
      "shedule the selected item for tomrrow, effectivly removing
  it from todays agenda."
      (interactive "P")
      (let ((fn (if (eq major-mode 'org-agenda-mode)
                    'org-agenda-schedule
                  'org-schedule)))
        (funcall fn arg "+1d")))
    ($leader-local-set-key
      :keymaps '(org-mode-map org-agenda-mode-map)
      "s" '$org-procrastinate))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :straight nil
    :init
    (setq org-agenda-todo-ignore-scheduled 'future
          org-agenda-dim-blocked-tasks 'invisible
          org-agenda-files "~/org/.agenda-files")
    ($leader-set-key
      "a" 'org-agenda))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ox
    :straight nil
    :init
    (setq org-export-with-section-numbers nil
          org-export-with-toc nil
          org-export-with-sub-superscripts '{}
          org-export-with-priority t
          org-export-preserve-breaks t
          org-html-postamble nil)
    (defun $org-create-css-html-email-head ()
      "Create the header with CSS for use with email"
      (interactive)
      (setq org-html-head
            (concat
             "<style type=\"text/css\">\n"
             "<!--/*--><![CDATA[/*><!--*/\n"
             (with-temp-buffer
               (insert-file-contents
                "~/org/org-html-themes/styles/email/css/email.css")
               (buffer-string))
             "/*]]>*/-->\n"
             "</style>\n"))
      t)
    ($org-create-css-html-email-head))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :straight nil
    :init
    ($leader-set-key
      "c" 'org-capture)
    ($leader-local-set-key
      :definer 'minor-mode
      :keymaps 'org-capture-mode
      "e" '$export-org-email
      "," 'org-capture-finalize
      "k" 'org-capture-kill)
    :config
    (setq org-default-notes-file (expand-file-name "notes.org" org-directory)
          org-default-email-file (expand-file-name "email.org" org-directory)
          org-default-journal-file (expand-file-name "journal.org" org-directory)
          org-capture-templates
          '(("t" "Todo" entry (file+headline org-default-notes-file "Tasks")
             "* TODO [#B] %?\n %t\n" :empty-lines 1)
            ("l" "Todo Link" entry (file+headline org-default-notes-file "Tasks")
             "* TODO [#B] %?\n %i\n %a" :empty-lines 1)
            ("s" "Scheduled TODO" entry (file+headline org-default-notes-file "Tasks")
             "* TODO [#B] %?\n  SCHEDULED: %^T\n" :empty-lines 1)
            ("T" "Todo from Clipboard" entry (file+headline org-default-notes-file "Tasks")
             "* TODO [#B] %?\n  %c" :empty-lines 1)
            ("n" "Note" entry (file+headline org-default-notes-file "Notes")
             "* %?" :empty-lines 1)
            ("N" "Note with Clipboard" entry (file+headline org-default-notes-file "Notes")
             "* %?\n   %c" :empty-lines 1)
            ("e" "Email" entry (file org-default-email-file)
             "* %?" :empty-lines 1)
            ("j" "Journal" entry (file org-default-journal-file)
             "* %<%a %b %e, %l:%M> -  %?" :empty-lines 1))))

     (defun $export-org-email ()
       "Export the current org email and copy it to the clipboard"
       (interactive)
       (let ((org-export-show-temporary-export-buffer nil))
         (org-html-export-as-html)
         (with-current-buffer "*Org HTML Export*"
           (kill-new (buffer-string)))
         (message "HTML copied to clipboard")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org-src
    :straight nil
    :init
    (setq org-src-fontify-natively t
          org-src-tab-acts-natively t)
    :config
    ($leader-local-set-key
      :definer 'minor-mode
      :keymaps 'org-src-mode
      "," 'org-edit-src-exit))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :delight
    :hook org-mode
    :init (add-hook 'org-insert-heading-hook 'evil-insert-state))
  ;; (evil-define-key 'normal evil-org-mode-map
  ;;   "H" 'org-shiftleft
  ;;   "J" 'org-shiftdown
  ;;   "K" 'org-shiftup
  ;;   "L" 'org-shiftright)
  (use-package evil-org-agenda
    :straight nil
    :commands evil-org-agenda-set-keys
    :hook (org-agenda-mode . evil-org-agenda-set-keys))
#+END_SRC

These packages are used to make org mode look better and take
advantage of unicode
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook org-mode)

  (use-package org-fancy-priorities
    :diminish
    :hook org-mode
    :init
    (setq org-fancy-priorities-list '("⬆" "⬅" "⬇" "☕")))
#+END_SRC

This package is builtin to Emacs, but the builtin version is too low
to export fontified org src code blocks
# #+BEGIN_SRC emacs-lisp
#   (use-package htmlize)
# #+END_SRC

https://gist.github.com/dfeich/1df4e174d45f05fb5798ca514d28c68a
provide a hydra dispatcher based on context
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight nil
    :init
    ($leader-local-set-key
      :keymaps 'org-mode-map
      "d" '$context-hydra-launcher)
    :config
    (defun $context-hydra-launcher ()
      "A launcher for hydras based on the current context."
      (interactive)
      (let* ((elem (org-element-context))
             (etype (car elem))
             (type (org-element-property :type elem)))
        (cl-case etype
          (src-block (hydra-babel-helper/body))
          (link (hydra-org-link-helper/body))
          ((table-row table-cell) (hydra-org-table-helper/body) )
          (t (message "No specific hydra for %s/%s" etype type)
             (hydra-org-default/body)))))

  ;;; *** org mode hydras
    (defhydra hydra-org-default (:color pink :hint nil)
      "
  Org default hydra
  _s_ insert src block ref with helm
  _q_ quit
  "
      ("s" helm-lib-babel-insert :color blue)
      ("q" nil :color blue))


    (defhydra hydra-org-link-helper (:color pink :hint nil)
      "
  org link helper
  _i_ backward slurp     _o_ forward slurp    _n_ next link
  _j_ backward barf      _k_ forward barf     _p_ previous link
  _q_ quit
  "
      ("i" org-link-edit-backward-slurp)
      ("o" org-link-edit-forward-slurp)
      ("j" org-link-edit-backward-barf)
      ("k" org-link-edit-forward-barf)
      ("n" org-next-link)
      ("p" org-previous-link)
      ("q" nil :color blue))

    (defhydra hydra-org-table-helper (:color pink :hint nil)
      "
  org table helper
  _r_ recalculate     _w_ wrap region      _c_ toggle coordinates
  _i_ iterate table   _t_ transpose        _D_ toggle debugger
  _B_ iterate buffer  _E_ export table     _d_ edit field
  _e_ eval formula    _s_ sort lines
  _q_ quit
  "
      ("E" org-table-export :color blue)
      ("s" org-table-sort-lines)
      ("d" org-table-edit-field)
      ("e" org-table-eval-formula)
      ("r" org-table-recalculate)
      ("i" org-table-iterate)
      ("B" org-table-iterate-buffer-tables)
      ("w" org-table-wrap-region)
      ("D" org-table-toggle-formula-debugger)
      ("t" org-table-transpose-table-at-point)
      ("c" org-table-toggle-coordinate-overlays :color blue)
      ("q" nil :color blue))

    (defhydra hydra-babel-helper (:color pink :hint nil)
      "
  org babel src block helper functions
  _n_ next       _i_ info           _I_ insert header
  _p_ prev       _c_ check
  _h_ goto head  _E_ expand
  ^ ^            _s_ split
  _q_ quit       _r_ remove result  _e_ examplify region
  "
      ("i" org-babel-view-src-block-info)
      ("I" org-babel-insert-header-arg)
      ("c" org-babel-check-src-block :color blue)
      ("s" org-babel-demarcate-block :color blue)
      ("n" org-babel-next-src-block)
      ("p" org-babel-previous-src-block)
      ("E" org-babel-expand-src-block :color blue)
      ("e" org-babel-examplify-region :color blue)
      ("r" org-babel-remove-result :color blue)
      ("h" org-babel-goto-src-block-head)
      ("q" nil :color blue))

    )
#+END_SRC

** elisp

#+BEGIN_SRC emacs-lisp
  (use-package emacs-lisp
    :straight nil
    :init
    ($leader-local-set-key
      :keymaps 'emacs-lisp-mode-map
      "'" 'ielm
      "eb" 'eval-buffer
      "er" 'eval-region
      "ef" 'eval-defun))
#+END_SRC

never have to worry about tab indenting again.
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :hook emacs-lisp-mode)
#+END_SRC

set TRAMP verbosity to warnings and errors only. default is level 3
which sends a message every time we connect to a remote host
https://emacs.stackexchange.com/questions/29286/tramp-unable-to-open-some-files
#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :straight nil
    :init
    (setq tramp-default-method "ssh"
          tramp-default-user "tjhinckl"
          tramp-verbose 4
          helm-tramp-connection-min-time-diff 1
          tramp-inline-compress-start-size 1000000
          tramp-copy-size-limit 1000000)
    :config
    (tramp-set-completion-function "ssh" '((tramp-parse-hosts "~/.ssh2/ssh2_config"))))
#+END_SRC

packages to help manage parens
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook prog-mode)

  (use-package paren
    :straight nil
    :demand t
    :after prog-mode
    :init
    (setq evil-show-paren-range 3)
    (evil-collection-init 'paren)
    :config
    (show-paren-mode))
#+END_SRC

** perl
all the enviroment variables are set so as to make it easier for
flycheck to get a clean compile.
#+BEGIN_SRC emacs-lisp
  (use-package cperl
    :straight nil
    :init
    (setq flycheck-perl-executable "/usr/intel/pkgs/perl/5.14.1/bin/perl"
          flycheck-perl-perlcritic-executable "/usr/intel/pkgs/perl/5.14.1-threads/bin/perlcritic"
          flycheck-perl-include-path '("/p/hdk/cad/spf/latest/lib/perl5" ;; SPF library
                                       "../lib/perl5" ;; DTEG ultiscan
                                       "../../lib/perl5" ;; DTEG STF
                                       "..")) ;; library files need to see the library ¯\_(ツ)_/¯
    (setenv "VALID_ROOT" "/p/hdk/rtl/valid/shdk74")
    (setenv "VTLIB" "/p/hdk/rtl/valid/shdk74/lib")
    (setenv "SPF_PERL_LIB" "/p/hdk/cad/spf/latest/lib/perl5")
    (setenv "GLOBAL_TOOLS" "/nfs/site/proj/dpg/tools")
    (setenv "XWEAVE_REPO_ROOT" "/p/hdk/rtl/ip_releases/shdk74/xweave/v17ww43a")
    (setenv "IDS_HOME" "/p/hdk/rtl/cad/x86-64_linux26/dteg/ideas_shell/0.15.1")

    ;; ISC required variables
    (setenv "RTL_CAD_ROOT" "/p/hdk/rtl/cad/x86-64_linux26")
    (setenv "RTL_PROJ_CFG" "/p/hdk/rtl/proj_tools/proj_cfg")
    (setenv "CFG_PROJECT" "shdk74")
    (setenv "RTL_PROJ_BIN" "/p/hdk/rtl/proj_tools/proj_binx/shdk74/latest")
    (setenv "RTL_PROJ_TOOLS" "/p/hdk/rtl/proj_tools"))
#+END_SRC
** other
collection of major modes that I use for different file types.
#+BEGIN_SRC emacs-lisp
  (use-package major-modes
    :straight (major-modes
               :local-repo "major-modes")
    :init
    ($leader-local-set-key
      :keymaps 'spfspec-mode-map
      "g" 'spfspec-goto-definition))
#+END_SRC
