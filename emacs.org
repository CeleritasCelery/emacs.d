#+TITLE: Emacs Literate Configuration
#+AUTHOR: Troy Hinckley
#+PROPERTY: header-args :tangle yes


* Configuration
:PROPERTIES:
:VISIBILITY: children
:END:
** Design Choices
I have some basic design principles that I am trying to keep
consistent through all of my config.

*** namespace
I am using =$= as my personal namespace. I like it because it reminds
me of perl, it is really simple, and this is elisp, so I can make my
namespace whatever I want.

*** lambdas
the easiest way add a simple wrapper function to a hook or advice is
to use lambdas. However that has the problem of making them very hard
to inspect and remove. It is better to use named functions. However it
can be confusing if a function is only used as a named lambda or if it
is being used elsewhere. Therefore I will put named functions (using
=defun=) inside of =add-hook= or =advice-add=. This allows me to
clearly associate the function with the purpose but also avoids the
confusion surrounding anonymous functions.

*** overrides
Never override a function when an advice will do. when I actually do
need to override a function, I will try to use the package =el-patch=
to make it maintainable.

** Emacs Initialization

*** lexical bindings

make this file lexically bound
#+BEGIN_SRC emacs-lisp
  ;;; init.el --- personal emacs config file -*- lexical-binding: t -*-
#+END_SRC

*** Personal Information
Let's set some variables with basic user information.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Troy Hinckley"
        user-mail-address "t.macman@gmail.com")
#+END_SRC

*** customization

stolen from https://github.com/abo-abo/oremacs/blob/github/init.el
and modified to be more flexible
#+BEGIN_SRC emacs-lisp
  (defmacro csetq (&rest pairs)
    "For each SYMBOL VALUE pair, calls either `custom-set' or `set-default'."
    (let (forms)
      (while pairs
        (let ((variable (pop pairs))
              (value (pop pairs)))
          (push `(funcall (or (get ',variable 'custom-set) 'set-default)
                          ',variable ,value)
                forms)))
      `(progn ,@(nreverse forms))))
#+END_SRC

a simple function to convert from a cons cell to list for use with
apply.
#+BEGIN_SRC emacs-lisp
  (defsubst $flatten-cons (cons)
    (list (car cons) (cdr cons)))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (defvar $leader-key "SPC"
    "leader key used to quicky access commands.")

  (defvar $mm-leader-key ","
    "leader key for major mode specific commands")
#+END_SRC

don't use menu or scroll bars. We want the UI to be as clean as
possible.
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)
  (setq inhibit-startup-screen t)
  (toggle-frame-fullscreen)
  (add-hook 'focus-in-hook 'redraw-display)
#+END_SRC

don't load x-resources. Everything we need for our config should be in here
#+BEGIN_SRC emacs-lisp
  (setq inhibit-x-resources t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode)
#+END_SRC

use =y= and =n= instead of =yes= and =no=
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

move the custom file to its own loaction so it does not clutter us.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load-file custom-file)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (csetq load-prefer-newer t)
#+END_SRC

*** tangling
we want to tangle on exit so that it will make startup time quicker.
#+BEGIN_SRC emacs-lisp
  (defun $tangle-init-file ()
    "tangle my emacs org file before closing to make startup faster."
    (interactive)
    (let ((src (expand-file-name "emacs.org" user-emacs-directory))
          (target (expand-file-name "emacs.el" user-emacs-directory)))
      (when (file-newer-than-file-p src target)
        (require 'ob-tangle)
        (org-babel-tangle-file src target))))

  (add-hook 'kill-emacs-hook '$tangle-init-file)
#+END_SRC

by setting the initial mode we won't have to load lisp at startup
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'fundamental-mode)
#+END_SRC

*** git version

fix the path to use a new version of git
#+BEGIN_SRC emacs-lisp
  (setq exec-path (delete "/p/hdk/rtl/proj_tools/proj_binx/shdk74/latest" exec-path))
#+END_SRC

** Package Manager
We are going to use =straight.el= as package manager because it allows
us to easily maintain private repos of packages. This is still slower
then using package.el, but I think it is worth it. below is the
bootstrap code to download the package manager and run it.

#+BEGIN_SRC emacs-lisp
  (setq straight-check-for-modifications '(check-on-save find-when-checking))
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

** use package

=use-package= is a macro that allows to easily define and load other
packages.  It is the first thing we want to install. I am using my own
fork of the package that contains more sane defaults for the =:hook=
keyword (essentially it automatically adds the =-mode= suffix).

*** use-package
#+BEGIN_SRC emacs-lisp
  (straight-use-package
   '(use-package
      :type git :host github :repo "CeleritasCelery/use-package"
      :upstream (:host github
                       :repo "jwiegley/use-package")))
#+END_SRC

Setting =straight-use-package-by-default= to =t= we can ensure that
=use-pacakge= will use =straight.el= to install missing packages for
us. Always defer will guarantee that all packages are autoloaded
unless explicitly stated otherwise.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t
        use-package-always-defer t)
#+END_SRC

** emacs startup profiler
The "Emacs Startup profiler". This allows us to see what parts of the
config are most heavily impacting start up time. you can't optimize
until you have good info
#+BEGIN_SRC emacs-lisp
  (use-package esup)
#+END_SRC

* Packages
:PROPERTIES:
:VISIBILITY: children
:END:
** setup
packages that are used to setup my emacs enviroment. They are
needed as dependaceies for other packages later on.

*** general package
This package lets us use "SPC" as leader key for other keybindings. It
also provides a lot of helper functions to make binding keys easier
and smarter.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config

    (general-create-definer $leader-set-key
      :prefix $leader-key
      :states 'motion
      :keymaps 'override)

    (general-create-definer $leader-local-set-key
      :prefix $mm-leader-key
      :states 'motion)

    (defun general-leader-define-key (_state keymap key def _orig-def _kargs)
      "define a new key based on leader"
      (if (eq keymap 'global)
          (eval `($leader-set-key ,key ',def))
        (eval `($leader-local-set-key :keymaps ',keymap ,key ',def)))))
#+END_SRC

Use tab for indentation and symbol completion
#+BEGIN_SRC emacs-lisp
  (general-define-key :states '(insert normal visual)
                      "TAB" 'indent-for-tab-command)
  (setq tab-always-indent 'complete)
#+END_SRC

*** no littering
make sure that third party files cannot leave conifg and save files
all over the place
#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t)
#+END_SRC

*** save hist
save minibuffer history between sessions.
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :straight nil
    :defer 1
    :config
    (savehist-mode))
#+END_SRC

*** hyrda
hydra provides repeatable keybindings to quickly execute multiple
commands
#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

*** el-patch
#+BEGIN_SRC emacs-lisp
  (use-package el-patch)
#+END_SRC

** UI
packages that are used to improve the visuals and interface for Emacs

*** highlight line

highlight the current line with a background face
#+BEGIN_SRC emacs-lisp
  (use-package hl-line
    :demand t
    :config
    (global-hl-line-mode))

  (general-add-hook '(evil-visual-state-entry-hook evil-insert-state-entry-hook)
                    (defun $disable-hl-line ()
                      (global-hl-line-mode -1)))

  (general-add-hook '(evil-visual-state-exit-hook evil-insert-state-exit-hook)
                    (defun $enable-hl-line ()
                      (global-hl-line-mode)))
#+END_SRC

*** font
Setup the font that I want to use. Hasklig is a fork of /Source Code
Pro/ that contains ligatures.
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                    :family "Hasklig"
                    :height 120)
#+END_SRC

use a hydra to scale the text size
#+BEGIN_SRC emacs-lisp
  (defhydra text-scale (:hint nil)
    "
  Text Scale
    _i_n _o_ut _r_eset _q_uit
  "
    ("i" text-scale-increase)
    ("o" text-scale-decrease)
    ("r" (text-scale-set 0) :exit t)
    ("q" nil :exit t))
  ($leader-set-key
    "z" '(:ignore t :wk "util")
    "zs" 'text-scale/body)
#+END_SRC

*** ligatures
liguatures use a custom symbol to represent two or more
characters. The haskling font is required to make these work. Another
option would be FiraCode, but I am pretty happy with Hasklig for now.
#+BEGIN_SRC emacs-lisp
  (defvar $prog-prettify-symbols-alist
    `(("&&"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE100)))
      ("||"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE104)))
      ("::"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE106)))
      ("=="  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE107)))
      ("=>"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE10A)))
      (">>"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE10D)))
      ("->"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE112)))
      ("<<"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE11C)))
      (".."  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE11F)))
      ("++"  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE121)))
      ("!="  . (?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE123)))
      ("..." . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE120)))
      ("->>" . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Br) ,(decode-char 'ucs #XE126)))
      (".="  . (?· (Br . Bl) ?=))
      ("<="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?< (Bc . Bc) ?_))
      (">="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?> (Bc . Bc) ?_))))

  (defun $prettify-base-symbols ()
    "enable hasklig ligatures"
    (interactive)
    (dolist (symbol $prog-prettify-symbols-alist)
      (add-to-list 'prettify-symbols-alist symbol))
    (prettify-symbols-mode))

  (add-hook 'prog-mode-hook '$prettify-base-symbols)
#+END_SRC

compose symbols (ligatures) no matter where they are. also unformat at
point so we can easily see the representation
#+BEGIN_SRC emacs-lisp
  (csetq prettify-symbols-unprettify-at-point t
         prettify-symbols-compose-predicate (defun $prettify-symbols-all-p (_1 _2 _3) t))
#+END_SRC

*** vnc size
change the size of the VNC to match the size of the monitor that I am
using. Since I always run my VNC fullscreen having the VNC resolution
not match the resolution of my monitor results in weird text sizes.
#+BEGIN_SRC emacs-lisp
  (defun vnc-resize (size)
    (shell-command (concat "xrandr --size " size)))

  (defhydra vnc-resize (:columns 2 :exit t)
    "VNC Resize"
    ("l" (vnc-resize "1920x1200") "single monitor (large)")
    ("m" (vnc-resize "1536x864") "mobile")
    ("w" (vnc-resize "3840x1200") "double monitor (wide)")
    ("s" (vnc-resize "1920x1080") "short")
    ("h" (vnc-resize "2400x1350") "huge")
    ("r" (vnc-resize "1600x1200") "square"))
  ($leader-set-key
    "zn"  'vnc-resize/body)
#+END_SRC

*** themes
Creating a collection of themes that I like. I can use
=helm-themes= to switch between them. Some of these themes do
not have all faces that I would like, so When I get some time I will
modify them.
#+BEGIN_SRC emacs-lisp
  (use-package challenger-deep-theme)
  (use-package gruvbox-theme)
  (use-package darktooth-theme
    :straight
    (darktooth-theme
     :type git  :host github :repo "CeleritasCelery/emacs-theme-darktooth"
     :upstream (:host github :repo "emacsfodder/emacs-theme-darktooth")))
  (use-package spacemacs-theme)
  (use-package dracula-theme)
  (use-package moe-theme
    :init
    (add-to-list 'custom-theme-load-path
                 "~/.emacs.d/straight/build/moe-theme/"))
  (use-package doom-themes)
  (use-package solarized-theme)
  (use-package color-theme-sanityinc-tomorrow)
  (use-package noctilux-theme)
  (use-package flatland-theme)
  (use-package monokai-theme)

  (load-theme 'darktooth t)
#+END_SRC

**** colors
These two packages provide some great tools for editing and analying
themes visually.

With rainbow mode, colors are highlighted with their actual color. We
don't want to highlight color "names" in elisp though.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :init
    (setq rainbow-x-colors nil))
#+END_SRC

fontify face will colorize faces with their face. we combine this with
rainbow mode to make a minor mode that is perfect for editing themes.
#+BEGIN_SRC emacs-lisp
  (use-package fontify-face)

  (define-minor-mode $color-mode
    "turn on rainbow and fontify-face modes"
    :group '$color-mode
    (if $color-mode
        (progn (rainbow-mode)
               (fontify-face-mode))
      (rainbow-mode -1)
      (fontify-face-mode -1)))

  ($leader-set-key
    "zc" '(:ignore t :wk "color")
    "zcc" '$color-mode)
#+END_SRC

use helm to look at all availible colors
#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "zcs" 'helm-colors)
#+END_SRC

*** modeline
I am still struggling to find a modeline I really like. I have settled
on doom for now, but there are some segments that I would like to add
such as compilation exit status. My biggest beef with doom-modeline is
it does not play nice non-doom themes. I think powerlines are cool
looking, but I am honestly becomeling less of a fan of them. I may
just end up making my own modeline from scratch.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/ignore.el
  (use-package smart-mode-line
    :demand t
    :config
    (sml/setup))
#+END_SRC

Doom modeline works great, but a couple of small tweaks. First we
don't need the evil-state in the modeline, it is obvious enough.
Second we want to make sure that all "buffer info" flags can be
displayed at the same time.
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :straight
    (doom-modeline :type git :host github :repo "seagle0128/doom-modeline")
    :hook (after-init . doom-modeline-init)
    :config
    (csetq eldoc-eval-preferred-function 'eval-expression)
    (column-number-mode)
    (doom-modeline-def-segment evil-state
      "Disabled for now"
      "")
    (doom-modeline-def-segment buffer-info
      "Combined information about the current buffer, including the current working
  directory, the file name, and its state (modified, read-only or non-existent)."
      (concat (cond (buffer-read-only
                     (concat (doom-modeline-maybe-icon-octicon
                              "lock"
                              :face 'doom-modeline-warning
                              :v-adjust -0.05)
                             " "))
                    ((buffer-modified-p)
                     (concat (doom-modeline-maybe-icon-faicon
                              "floppy-o"
                              :face 'doom-modeline-buffer-modified
                              :v-adjust -0.0575)
                             " ")))
              (when (and buffer-file-name
                         (not (file-remote-p buffer-file-name))
                         (not (file-exists-p buffer-file-name)))
                (concat (doom-modeline-maybe-icon-octicon
                         "circle-slash"
                         :face 'doom-modeline-urgent
                         :v-adjust -0.05)
                        " "))
              (when (buffer-narrowed-p)
                (concat (doom-modeline-maybe-icon-octicon
                         "fold"
                         :face 'doom-modeline-warning
                         :v-adjust -0.05)
                        " "))
              (if buffer-file-name
                  (doom-modeline-buffer-file-name)
                "%b")))
    (defun doom-modeline-project-root ()
      "Get the path to the root of your project.
  If non-remote return root otherwise `default-directory'."
      (if (file-remote-p default-directory)
          default-directory
        (let (projectile-require-project-root)
          (projectile-project-root)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/ignore.el
  (use-package telephone-line
    :init
    (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
          telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
          telephone-line-primary-right-separator 'telephone-line-cubed-right
          telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right
          telephone-line-lhs '((evil   . (telephone-line-evil-tag-segment))
                               (accent . (telephone-line-vc-segment
                                          telephone-line-process-segment))
                               (nil    . (telephone-line-buffer-segment))))
    (telephone-line-mode))
#+END_SRC

*** which key
which key is an awesome package that shows me the key I can press
after choosing a prefix key.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :demand t
    :init
    (setq which-key-idle-delay 0.5
          which-key-idle-secondary-delay 0.1
          which-key-allow-evil-operators t)
    :config
    (which-key-mode)
    (push '((nil . "\\$") . (nil . "")) which-key-replacement-alist))
#+END_SRC

*** ace window
This is a window managment package that I am testing out. it works
pretty well, but I have a couple of things I would like to change.
1. there is no good way to operate on the current window, you have to
   knows its letter first, which is not always easy. my idea is that
   the capital of action would operate on the current window. For
   example =SPC wX= would delete the current window. This would take a
   fair amount of work to change the package however. Or at least so I
   think, I have not actually looked at it yet. I want to wait for
   while to make this change so that I can get the muscle memory down
   and see if that makes this easier with this package.
2. This package will split the window but leave the cursor in the old
   window. I relalize this is just a little thing. but it is very
   unintuitive for me and I have to think about it every time.
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :general
    (:definer 'leader
              "w" 'ace-window)
    :init
    (setq aw-dispatch-always t
          aw-background nil)
    :config
    (add-to-list 'aw-dispatch-alist '(?w $toggle-maximize-window))
    (add-to-list 'aw-dispatch-alist '(?d aw-delete-window "delete window"))
    (add-to-list 'aw-dispatch-alist '(?s aw-split-window-horz "Split Horz window")))

  ;; from https://gist.github.com/3402786
  (defun $toggle-maximize-window ()
    "Maximize buffer"
    (interactive)
    (if (and (= 1 (length (window-list)))
             (assoc ?_ register-alist))
        (jump-to-register ?_)
      (progn
        (window-configuration-to-register ?_)
        (delete-other-windows))))
#+END_SRC

*** shackle
this is a window managment package that is very minimalistic. I am
going to use it until I find a case where it won't work, then I might
try a more powerful package like popwin.
#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :demand t
    :config
    (add-to-list 'shackle-rules '("*Help*" :select t :align below))
    (shackle-mode))

  (defmacro $shacklize (fn)
    "change the function signature of display-buffer functions to
  account for shackle calling convetion"
    `(lambda (buf alist _plist) (,fn buf alist)))
#+END_SRC

*** buffers
A collection of functions stolen from Spacemacs that allows me to more
easily manipulate files, buffers, and windows.

#+BEGIN_SRC emacs-lisp
  (defun $alternate-buffer (&optional window)
    "Switch back and forth between current and last buffer in the
  current window."
    (interactive)
    (let ((current-buffer (window-buffer window))
          (buffer-predicate
           (frame-parameter (window-frame window) 'buffer-predicate)))
      ;; switch to first buffer previously shown in this window that matches
      ;; frame-parameter `buffer-predicate'
      (switch-to-buffer
       (or (cl-find-if (lambda (buffer)
                         (and (not (eq buffer current-buffer))
                              (or (null buffer-predicate)
                                  (funcall buffer-predicate buffer))))
                       (mapcar #'car (window-prev-buffers window)))
           ;; `other-buffer' honors `buffer-predicate' so no need to filter
           (other-buffer current-buffer t)))))

  (defun $quit-emacs ()
    "save buffers and quit"
    (interactive)
    (save-some-buffers)
    (kill-emacs))

  (defun $open-scratch-buffer ()
    "open the scratch buffer"
    (interactive)
    (set-window-buffer (selected-window)
                       (get-buffer-create "*scratch*")))

  (defun $show-and-copy-buffer-filename (arg)
    "Show and copy the full path to the current file in the minibuffer."
    (interactive "P")
    ;; list-buffers-directory is the variable set in dired buffers
    (let ((file-name (or (buffer-file-name)
                         list-buffers-directory
                         default-directory)))
      (if file-name
          (message (kill-new (if (null arg)
                                 (file-truename file-name)
                               file-name)))
        (error "Buffer not visiting a file"))))

  ($leader-set-key
    "TAB" '$alternate-buffer
    "fy" '$show-and-copy-buffer-filename
    "b" '(:ignore t :wk "buffers")
    "bs" '$open-scratch-buffer
    "q" '(:ignore t :wk "quit")
    "qq" '$quit-emacs)
#+END_SRC

quick movement hydra.

#+BEGIN_SRC emacs-lisp
  (defhydra buffer-nav (:exit nil)
    "move quickly through recent buffers"
    ("p" previous-buffer "prev")
    ("N" previous-buffer "prev")
    ("n" next-buffer "next"))

  ($leader-set-key
    "bp" 'buffer-nav/previous-buffer
    "bn" 'buffer-nav/next-buffer)
#+END_SRC

*** window
switch back to minibuffer when it is active.

#+BEGIN_SRC emacs-lisp
  (defun $switch-to-minibuffer-window ()
    "switch to minibuffer window (if active)"
    (interactive)
    (when (active-minibuffer-window)
      (select-frame-set-input-focus (window-frame (active-minibuffer-window)))
      (select-window (active-minibuffer-window))))

  ($leader-set-key
    "bm" '$switch-to-minibuffer-window)
#+END_SRC

*** winum
winum adds the window number to the mode-line and gives us easy
bindings to jump between windows. We need to update
=winum-assign-functions= so that we are using the same ordering as
ace-window.
#+BEGIN_SRC emacs-lisp
  (use-package winum
    :defer 1
    :init
    (dolist (num (number-sequence 0 9))
      (let ((str (number-to-string num)))
        (eval `($leader-set-key
                 ,str (intern (concat "winum-select-window-" ,str))))))
    :config
    (add-to-list 'winum-assign-functions
                 (defun $winum-use-ace-window-numbering ()
                   (require 'ace-window)
                   (when-let ((windows (cl-sort (winum--window-list) 'aw-window<))
                              (pos (cl-position (selected-window) windows)))
                     (1+ pos))))
    (winum-mode))
#+END_SRC

*** helpful
helpful provides better information about variables and
functions. only tweak we need to make is let the window close with q
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :init
    ($leader-set-key
      "h" '(:ignore t :wk "help")
      "hd" '(:ignore t :wk "describe")
      "hdf" 'helpful-callable
      "hdv" 'helpful-variable
      "hdk" 'helpful-key)
    (general-define-key
     :keymaps 'helpful-mode-map
     :states 'normal
     "q" 'quit-window))
#+END_SRC

we are going to add helpful to the completing read handler for
helm. This will let us preview the variable with TAB.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'helm-mode
    (require 'map)
    (dolist (help-fn '(helpful-variable
                       helpful-function
                       helpful-macro
                       helpful-key
                       helpful-callable))
      (map-put helm-completing-read-handlers-alist help-fn 'helm-completing-read-symbols)))
#+END_SRC

*** persp-mode
persp-mode is layout managment package that provides way more
functionality then I want. All I really are about is having named
groups of eyebrowse window configs. I could probably drop persp mode
and create a wrapper around =eyebrowse= that could group the window
configs under a name. I would use only eyebrowse, but then I would
have to try to remember what windows go to what project, and that can
get a little confusing. Also I have created some fuctions that make
shell-pop perspective local, and I really like that feature.
#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :init
    (setq persp-auto-save-opt 0)
    (defhydra persp (:exit t :pre (persp-mode))
      "Perspective"
      ("l" persp-switch "switch")
      ("n" persp-next "next" :exit nil)
      ("p" persp-prev "previous" :exit nil)
      ("r" persp-rename "rename")
      ("a" persp-add-buffer "add buffer")
      ("k" persp-remove-buffer "remove buffer")
      ("D" persp-kill "Delete perspective"))
    ($leader-set-key
      "l" 'persp/body))
#+END_SRC

*** eyebrowse
minimal window managment package.
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :init
    (defhydra eyebrowse (:exit t :pre (eyebrowse-mode))
      "Window Config"
      ("e" eyebrowse-switch-to-window-config "switch")
      ("n" eyebrowse-next-window-config "next" :exit nil)
      ("p" eyebrowse-prev-window-config "previous" :exit nil)
      ("d" eyebrowse-close-window-config-prompt "close")
      ("1" eyebrowse-switch-to-window-config-1)
      ("2" eyebrowse-switch-to-window-config-2)
      ("3" eyebrowse-switch-to-window-config-3)
      ("4" eyebrowse-switch-to-window-config-4)
      ("5" eyebrowse-switch-to-window-config-5))
    ($leader-set-key
      "e" 'eyebrowse/body)
    :config
    (general-define-key
     :keymaps 'eyebrowse-mode-map
     "C-c C-w" nil))
#+END_SRC

*** toggles
minor modes that I commonly toggle on and off
#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "t" '(:ignore t :wk "toggle")
    "tn" 'display-line-numbers-mode
    "tl" 'toggle-truncate-lines
    "te" 'toggle-debug-on-error
    "tq" 'toggle-debug-on-quit
    "tg" 'git-gutter-mode)
#+END_SRC

*** restart
#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :init
    ($leader-set-key
      "qr" 'restart-emacs))
#+END_SRC

changing the volume on my mic triggers these bindings. So we ignore them.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "<XF86AudioLowerVolume>" 'ignore
   "<XF86AudioRaiseVolume>" 'ignore)
#+END_SRC

** Ivy

*** ivy
I feel like ivy is simpler to setup so I am going to give it a try. I am going
to have to try to fix =counsel-ag= out of order matching if I want to live with
it though.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :straight
    (ivy
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper"))
    :general
    (:keymaps 'ivy-minibuffer-map
              "C-j" 'ivy-next-line
              "C-k" 'ivy-previous-line
              "C-h" "DEL"
              "C-S-H" help-map
              "C-l" 'ivy-alt-done
              "<C-return>" 'ivy-immediate-done)
    :init
    (setq ivy-height 15
          ivy-use-virtual-buffers t
          ivy-extra-directories nil
          ivy-use-selectable-prompt t
          ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
    ($leader-set-key
      "bg" 'ivy-switch-buffer)
    :config
    (defun ivy-yank-action (x)
      (kill-new x))
    (ivy-set-actions
     t
     '(("y" ivy-yank-action "yank")))
    (ivy-set-actions 'counsel-find-file nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra
    :straight
    (ivy-hydra
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper"))
    :after (ivy hydra))
#+END_SRC

*** swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :straight
    (swiper
     :files ("swiper.el")
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper"))
    :init
    ($leader-set-key
      "os" 'swiper))
#+END_SRC

*** counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :straight
    (counsel
     :type git :host github :repo "CeleritasCelery/swiper"
     :upstream (:host github
                      :repo "abo-abo/swiper")))
#+END_SRC

*** rich foratting
This package makes =ivy-switch-buffer= behave more like =helm-mini=
(i.e. displays the buffer type and full path to recentf files). This
is just too slow to use right now though.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/ignore.el
  (use-package ivy-rich
    :demand t
    :after ivy
    :config
    (setq ivy-virtual-abbreviate 'full
          ivy-rich-switch-buffer-align-virtual-buffer t)
    (ivy-set-display-transformer 'ivy-switch-buffer 'ivy-rich-switch-buffer-transformer))
#+END_SRC

*** smex
smex is an enchanced version of =M-x= that will record history and is
integrated into ivy
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :init
    (setq smex-history-length 32))
#+END_SRC

*** prescient
keeps track of statistics for usage and presents most familiar
candiates first. Currently does not support regex, which makes it much
less useful
#+BEGIN_SRC emacs-lisp
  (use-package ivy-prescient
    :after ivy
    :config
    (ivy-prescient-mode)
    (prescient-persist-mode))
#+END_SRC

** evil
evil is the Extensible VI Layer. It gives us all the power of vim
without the draw back of using vimscript for config.

*** general

because we are using evil collection, we need to disable evil's
builtin integration *before* evil is loaded.
#+BEGIN_SRC emacs-lisp
  (setq evil-want-integration nil)
#+END_SRC

we want to overide most control keybindings to make them behave like
Vim instead of like Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :init
    (csetq evil-jumps-cross-buffers nil
           evil-want-C-w-delete t
           evil-want-C-i-jump t
           evil-want-Y-yank-to-eol t)
    :config
    (general-swap-key nil 'motion "0" "^")
    (evil-mode 1))
#+END_SRC

I want to preserve the functionality of =C=u=, but still want to use
standard keys to scroll. =C-f= and =C-b= are used for scrolling in
vim/less, but they scroll a whole page, which is too much. So we
rebind these to the normal scroll function.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal visual)
   "C-f" 'evil-scroll-down
   "C-b" 'evil-scroll-up)
#+END_SRC

Using =*= and =#=, search foward for symbols, not words
#+BEGIN_SRC emacs-lisp
  (csetq evil-symbol-word-search t)
#+END_SRC

we want to use visual lines, but then the line operators don't work
(i.e. =dj= will not operate on literal lines). So we do some simple
remapping instead of setting =evil-respect-visual-line-mode=.
[[https://github.com/emacs-evil/evil/issues/188][emacs-evil/evil#188]]
#+BEGIN_SRC emacs-lisp
  (general-define-key
       :states 'motion
       [remap evil-next-line] 'evil-next-visual-line
       [remap evil-previous-line] 'evil-previous-visual-line)

  (general-define-key
       :states 'operator
       [remap evil-next-line] 'evil-next-line
       [remap evil-previous-line] 'evil-previous-line)
#+END_SRC

add a little hack to prevent =v$= from grabbing the newline. This is a
much better default, but the evil people don't like it and won't add
an option to support it. Nice thing about Emacs though, is we can do
it anyway.  [[https://github.com/emacs-evil/evil/issues/897][emacs-evil/evil#897]]
#+BEGIN_SRC emacs-lisp
  (defvar evil-v$-gets-eol nil)

  (evil-define-motion evil-end-of-line (count)
    "Move the cursor to the end of the current line. If COUNT is
      given, move COUNT - 1 lines downward first."
    :type inclusive
    (move-end-of-line count)
    (when evil-track-eol
      (setq temporary-goal-column most-positive-fixnum
            this-command 'next-line))
    (unless (and (evil-visual-state-p) evil-v$-gets-eol)
      (evil-adjust-cursor)
      (when (eolp)
        ;; prevent "c$" and "d$" from deleting blank lines
        (setq evil-this-type 'exclusive))))
#+END_SRC

prevent "vimmers" from quiting my Emacs. Old habbits die hard.
#+BEGIN_SRC emacs-lisp
  (evil-ex-define-cmd "q" nil)
  (evil-ex-define-cmd "wq" nil)
#+END_SRC

*** magic searching
by default =evil-ex= uses the emacs regex engine which has some very
weird syntax and annoying escaping. instead we want to use evil's
=very-magic= mode which provdies something much more PCRE
compatible. however we can't just set this directly because
=evil-multiedit= relies on =evil-ex= to be "non-magic". Therefore we
just create user callable wrapper around evil-ex functions. Magic mode
only works if the search module is =evil-search=.
#+BEGIN_SRC emacs-lisp
  (setq evil-search-module 'evil-search
        evil-ex-search-vim-style-regexp t)

  (defmacro $make-magic (cmd)
    `(defun ,(intern (concat "$magic-" (symbol-name cmd))) ()
       (interactive)
       (let ((evil-magic 'very-magic))
         (call-interactively (quote ,cmd)))))

  (general-define-key
   :states '(motion normal visual)
   ":" ($make-magic evil-ex)
   "/" ($make-magic evil-ex-search-forward)
   "?" ($make-magic evil-ex-search-backward)
   "n" ($make-magic evil-ex-search-next)
   "N" ($make-magic evil-ex-search-previous))
#+END_SRC

substitute globally by default
#+BEGIN_SRC emacs-lisp
  (csetq evil-ex-substitute-global t)
#+END_SRC

*** text objects
**** custom
create text objects for the buffer, pasted region, and filename
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'evil
    (evil-define-text-object evil-inner-buffer (count &optional _beg _end _type)
      (list (point-min) (point-max)))

    (evil-define-text-object evil-pasted (count &rest _args)
      (list (save-excursion (evil-goto-mark ?\[) (point))
            (save-excursion (evil-goto-mark ?\]) (1+ (point)))))

    (evil-define-text-object evil-filename (count &rest _args)
      (let ((bounds (bounds-of-thing-at-point 'filename)))
        (list (car bounds) (cdr bounds))))

    (general-define-key
     :keymaps 'evil-inner-text-objects-map
     "g" 'evil-inner-buffer
     "P" 'evil-pasted
     "F" 'evil-filename))
#+END_SRC

**** indentation
The =evil-indent-plus= pakcage provides =i=, =I=, and =J= text objects
the select based on indentation.
#+BEGIN_SRC emacs-lisp
  (use-package evil-indent-plus
    :demand t
    :config
    (evil-indent-plus-default-bindings))
#+END_SRC

**** syntax
a text object that highlights everything with the same font lock
#+BEGIN_SRC emacs-lisp
  (use-package evil-textobj-syntax
    :straight
    (evil-textobj-syntax
     :type git :host github :repo "laishulu/evil-textobj-syntax")
    :general
    (:keymaps 'evil-inner-text-objects-map
              "h" 'evil-i-syntax)
    (:keymaps 'evil-outer-text-objects-map
              "h" 'evil-a-syntax))
#+END_SRC

*** keybindings
=C-i= can be used to move forward in cursor jumps, but Emacs binds it to =TAB=, so
we rebinding it to =H-i=. Though this won't work in the terminal
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'input-decode-map
   "C-i" "H-i")
  (general-define-key
   :states 'normal
   "H-i" 'evil-jump-forward)
#+END_SRC

We want to hybridize some usefull emacs commands with better evil keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states 'insert
   "C-y" 'yank)
#+END_SRC

general leader key bindings
#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "hde" 'describe-face
    "hdm" 'describe-mode
    "hdc" 'describe-char
    "hs"  'profiler-start
    "hS"  'profiler-stop
    "hr"  'profiler-report
    "hR"  'profiler-reset
    "d" 'save-buffer
    "br" 'rename-buffer
    "bR" 'revert-buffer
    "s" '(:ignore t :wk "search")
    "sc" 'evil-ex-nohighlight
    "u" 'universal-argument)
#+END_SRC

*** undo-tree
#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "U" 'undo-tree-visualize)
  (general-define-key
   :states '(normal visual)
   "u" 'undo-tree-undo
   "C-r" 'undo-tree-redo)
#+END_SRC

*** unimpaired
evil unimpaired binds some usefull functions to some quick keys.
#+BEGIN_SRC emacs-lisp
  (use-package evil-unimpaired
    :defer 2
    :straight
    (evil-unimpaired
     :type git :host github :repo "zmaas/evil-unimpaired")
    :init
    (setq evil-unimpaired-leader-keys '("gk" . "gj"))
    :config
    (evil-unimpaired-mode))
#+END_SRC

*** anzu
provides total number of searches in the modeline
#+BEGIN_SRC emacs-lisp
  (use-package evil-anzu
    :demand t
    :straight
    (evil-anzu
     :type git :host github :repo "CeleritasCelery/emacs-evil-anzu"
     :upstream (:host github
                      :repo "syohex/emacs-evil-anzu"))
    :init
    (csetq anzu-cons-mode-line-p nil))
#+END_SRC

*** snipe
we only want evil snipe for the ability to repeat =f,F,t,T=. I find
avy is better for the actual sniping
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package evil-snipe
    :demand t
    :init
    (setq evil-snipe-override-evil-repeat-keys nil)
    :config
    (evil-snipe-override-mode)
  (add-to-list 'evil-snipe-disabled-modes 'undo-tree-visualizer-mode))
#+END_SRC

*** escape

use a quick key combo to enter normal state. We don't want to escape
magit because I do that by accident all the time.
#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :demand t
    :init
    (setq evil-escape-unordered-key-sequence t
          evil-escape-key-sequence "jk")
    :config
    (evil-escape-mode)
    (advice-add 'evil-escape--is-magit-buffer :override (defun $dont-escape-magit () nil)))
#+END_SRC

*** collection
evil collection evilifies several major and minor modes to make them
behave better with evil.
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :demand t
    :config
    (add-hook 'evil-collection-setup-hook
              (defun $unmap-leader (_mode keymaps)
                (when (and keymaps
                           (not (memq 'ediff-mode-map keymaps)))
                  (general-define-key
                   :states 'normal
                   :keymaps keymaps
                   $leader-key nil
                   $mm-leader-key nil))))
    (evil-collection-init '(calc calendar custom debug doc-view
                                 eldoc elisp-mode dired help info
                                 integration occur popup profiler
                                 wgrep wdired which-key)))
#+END_SRC

*** surround
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :defer 4
    :config
    (global-evil-surround-mode)
    (general-define-key
     :states 'visual
     :keymaps 'evil-surround-mode-map
     "s" 'evil-surround-region
     "S" 'evil-substitute))
#+END_SRC

*** commenting
#+BEGIN_SRC emacs-lisp
  (use-package evil-nerd-commenter
    :commands (evilnc-copy-and-comment-operator
               evilnc-comment-operator)
    :init
    ($leader-set-key
      "k" '(evilnc-comment-operator :wk "comment")
      "K" '(evilnc-copy-and-comment-operator :wk "copy-and-comment")))
#+END_SRC

*** exchange
swap two regions with evil exchange
#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
    :general
    (:states
     '(visual normal)
     "gx" 'evil-exchange
     "gX" 'evil-exchange-cancel))
#+END_SRC

*** lispy
I tried lispy for a long time, and tried hard to like it. But
eventually I had to admit that it is clahses with the design patterns
of modal editing. Even using lispville (Lispy + evil) can't save it.
However I will keep using lispyville. Not because of its lispy
integration but because it reimplements evil-cleverparens in a nice
package.
#+BEGIN_SRC emacs-lisp
  (use-package lispyville
    :hook emacs-lisp-mode
    :init
    (setq lispyville-key-theme
          '(operators
            c-w
            prettify
            text-objects
            additional-movement
            slurp/barf-cp
            wrap
            additional
            additional-insert
            additional-wrap))
    (defhydra lispyville-mark (:pre
                               (require 'lispyville)
                               :exit nil)
      ("v" lispyville-wrap-lispy-mark-symbol-visual "symbol")
      ("V" lispyville-wrap-lispy-mark-visual "sexp"))
    ($leader-set-key
      "v" 'lispyville-mark/lispyville-wrap-lispy-mark-visual)
    :config
    (lispyville-wrap-command lispy-mark-symbol visual)
    (lispyville-wrap-command lispy-mark visual))
#+END_SRC

*** parens

=evil-cleverparens= requires paredit, unfortunately the default
paredit recipe does not work for me and I need to update it.
Thankfully, straight.el makes that super easy!
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :straight
    (paredit
     :files ("paredit.el")
     :type git
     :repo "http://mumble.net/~campbell/git/paredit.git"))
#+END_SRC

even cleverparens is a smartparens based paren editor. Lispyville
reimplements all of this functionality, but evil-cleverparens
implements it better. Some examples:

- when entering insert state cleverparens will automatically add a
  space. Lispville can't because it has to leave you in "special"
- when wrapping a form, lispy will try and wrap the quote (='foo ->
  ('foo)=) which is almost never what I want. Smartparens will leave
  the whole sexp wrapped (='foo -> '(foo)=)

However for the most part, I can just use lispyville with lispy
disabled. And a lot of cleverparens functionality requires
=evil-cleverparens= or =smartparens= to be enabled, which I would
prefer not to do.
#+BEGIN_SRC emacs-lisp
  (use-package evil-cleverparens
    :commands (evil-cp-insert
               evil-cp-append)
    :general
    (:states
     'normal
     "i" 'evil-cp-insert
     "a" 'evil-cp-append))
#+END_SRC

For a long time I used =evil-lisp-state= and loved it. However I
realized that it was overkill for what I wanted, and it relied
exclusivly on smartparens. So instead I created my own hydra that
takes the best functions from lispy, evil-cleverparens, and
smartparens and puts them into one dispatcher.
#+BEGIN_SRC emacs-lisp
  (defhydra lisp-quick (:pre (progn (require 'evil-cleverparens)))
    "quick commands evil-lisp-state"
    ("I" evil-cp-insert-at-beginning-of-form "insert list")
    ("A" evil-cp-insert-at-end-of-form "append list")
    ("O" lispyville-open-above-list "open above")
    ("o" lispyville-open-below-list "open below")
    ("J" lispy-join "join" :exit nil)
    ("r" sp-raise-sexp "raise" :exit nil)
    ("R" lispyville-raise-list "raise list" :exit nil)
    ("w" (sp-wrap-with-pair "(") "wrap" :exit nil))

  ($leader-set-key
    "m" 'lisp-quick/body)
#+END_SRC

** Helm
helm is the more powerfull of the two between itself and ivy. I really
want to give Ivy a good try because it seems snappier on large files,
but there are still some issues that gives helm the advantage
- =helm-ag= supports out of order matching
- helm doesn't break when using "regex" characters in pattern
- helm is integrated with dired
- helm file sorting is more sane
- helm-mini has better recentf functionality
- helm supports windows, which makes swoop easier
- =counsel-fzf= is broken, but =helm-fzf= works great
- helm supports marking, which is very efficent.

*** general

we want to make the helm keybindings more evil friendly. also change
the display function to be more consistent.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :general
    (:keymaps 'minibuffer-local-map
              "C-c C-l" 'helm-minibuffer-history)
    (:keymaps 'helm-map
              "C-j" 'helm-next-line
              "C-k" 'helm-previous-line
              "C-h" 'helm-next-source
              "C-S-h" 'helm-help
              "C-c C-h" 'describe-key
              "C-l" "RET"
              "C-z" 'helm-select-action
              "TAB" 'helm-execute-persistent-action)
    (:keymaps '(helm-find-files-map
                helm-read-file-map)
              "C-l" 'helm-execute-persistent-action
              "C-h" 'helm-find-files-up-one-level)
    ("M-x" 'helm-M-x
     "M-y" 'helm-show-kill-ring
     "C-x C-x" 'helm-all-mark-rings
     "C-c C-f" 'helm-find-files)
    (:definer 'leader
              "ff" 'helm-find-files
              "fr" 'helm-recentf
              "r"  'helm-resume
              "bh" 'helm-buffers-list
              "bb" 'helm-mini)
    :init
    ($leader-set-key "SPC" 'helm-M-x)
    (csetq
     helm-split-window-inside-p t
     helm-always-two-windows t
     helm-buffer-max-length 60
     helm-ff-candidate-number-limit 1000
     helm-display-function '$display-helm-window
     helm-buffer-skip-remote-checking t
     helm-echo-input-in-header-line t
     helm-ff-delete-files-function 'helm-delete-marked-files-async
     helm-find-files-ignore-thing-at-point t)

    (evil-collection-init 'helm)

    (defun $display-helm-window (buffer &optional _resume)
      (let ((display-buffer-alist
             '(("*.*Helm.*Help.**")
               ("*.*helm.**"
                (display-buffer-in-side-window)
                (inhibit-same-window . t)
                (side . bottom)
                (window-width . 0.6)
                (window-height . 0.3)))))
        (helm-default-display-buffer buffer)))
    :config
    (helm-mode)
    (dired-async-mode))
#+END_SRC

*** sorting
I am using helm-adaptive, but it only seems to work for helm-bookmark,
and some grep functions. I want to create an adaptive sort of the
describe functions and one for helm find files. Also we want to
prevent the buffer list from being resorted
#+BEGIN_SRC emacs-lisp
  (csetq helm-adaptive-history-length 100)
  (with-eval-after-load 'helm
    (helm-adaptive-mode)
    (advice-add 'helm-buffers-sort-transformer :around
                (defun $helm-buffers-sort-transformer@donot-sort (_1 candidates _3)
                  candidates))

    (defun $helm-sort-symbol-at-point (candidates _source)
      "move symbol at point to the start of list"
      (if-let ((adaptivep helm-adaptive-mode)
               (symbol (with-helm-current-buffer
                         (thing-at-point 'symbol t)))
               (valid (member symbol candidates)))
          (cons symbol (remove symbol candidates))
        candidates))
    (byte-compile #'$helm-sort-symbol-at-point)

    (defun helm-completing-read-symbols
        (prompt _collection test _require-match init
                hist default _inherit-input-method name buffer)
      "Specialized function for fast symbols completion in `helm-mode'."
      (require 'helm-elisp)
      (or
       (helm
        :sources (helm-build-in-buffer-source name
                   :init (lambda ()
                           (helm-apropos-init (lambda (x)
                                                (and (funcall test x)
                                                     (not (keywordp x))))
                                              (or (car-safe default) default)))
                   :filtered-candidate-transformer '(helm-apropos-default-sort-fn
                                                     helm-adaptive-sort
                                                     $helm-sort-symbol-at-point)
                   :help-message #'helm-comp-read-help-message
                   :fuzzy-match helm-mode-fuzzy-match
                   :persistent-action
                   (lambda (candidate)
                     (helm-lisp-completion-persistent-action
                      candidate name))
                   :persistent-help (helm-lisp-completion-persistent-help)
                   :candidate-number-limit 200)
        :prompt prompt
        :buffer buffer
        :input init
        :history hist
        :resume 'noresume
        :default (or default ""))
       (helm-mode--keyboard-quit)))
    (byte-compile #'helm-completing-read-symbols))

  (with-eval-after-load 'helm-files

    (defun $helm-sort-hardlink (candidates _source)
      "move to the hardlink to the top of the list when adaptive sorting"
      (if-let ((adaptivep helm-adaptive-mode)
               (hardlink (--first (string-suffix-p "/." (if (consp it) (cdr it) ""))
                                  candidates)))
          (cons hardlink (remove hardlink candidates))
        candidates))
    (byte-compile #'$helm-sort-hardlink)

    (setq helm-source-find-files (helm-make-source
                                     "Find Files" 'helm-source-ffiles))
    (cl-callf append (alist-get 'filtered-candidate-transformer helm-source-find-files)
      '(helm-adaptive-sort $helm-sort-hardlink))

    (advice-add 'helm-execute-persistent-action :before
                (defun $helm-adaptive-files-add (&rest _)
                  (when (and helm-adaptive-mode
                             (equal "*helm find files*" helm-buffer))
                    (let (helm-adaptive-done)
                      (helm-adaptive-store-selection))))))
#+END_SRC

*** bookmarks
don't set the org source as the first one in the book marks. Ideally
since I am using helm-adaptive-mode the most commonly used bookmarks
will be first.
#+BEGIN_SRC emacs-lisp
  (use-package helm-bookmark
    :straight nil
    :init
    ($leader-set-key
      "fb" 'helm-filtered-bookmarks)
    :config
    (require 'dash)
    (setq helm-bookmark-default-filtered-sources
	  (-insert-at 2 (car helm-bookmark-default-filtered-sources)
		      (cdr helm-bookmark-default-filtered-sources))))

#+END_SRC

*** evil
some hacks to make helm more evil compatible See
[[https://github.com/syl20bnr/spacemacs/issues/3700][syl20bnr/spacemacs#3700]]
#+BEGIN_SRC emacs-lisp
  (defun $helm-unprevent-minibuffer-escape ()
    (when helm-prevent-escaping-from-minibuffer
      (general-define-key :states 'motion
                          [down-mouse-1] 'evil-mouse-drag-region)
      (general-define-key :states 'normal
                          [mouse-2] 'mouse-yank-primary)))

  (defun $helm-prevent-minibuffer-escape ()
    (when helm-prevent-escaping-from-minibuffer
      (general-define-key :states 'motion
                          [down-mouse-1] nil)
      (general-define-key :states 'normal
                          [mouse-2] nil)))

  (defun $helm-hide-cursor-in-buffer ()
    (with-helm-buffer
      (setq cursor-in-non-selected-windows nil)))

  (general-add-hook 'helm-after-initialize-hook
                    '($helm-prevent-minibuffer-escape
                      $helm-hide-cursor-in-buffer))
  (add-hook 'helm-cleanup-hook #'$helm-unprevent-minibuffer-escape)
#+END_SRC

*** files
set of function to make helm find files more usable.
- remove the parent hardlink from the list (we can always go up a
  directory).
- make sure current directory is not selected by default. rarely am I
  going to just select the current directory. This is especially
  useful when I want to quickly navigate through multiple directories
  with only one entry. I can just use tab over and over again instead
  of having to type.

#+BEGIN_SRC emacs-lisp
  (defun $helm-skip-dots ()
    (let ((cands (helm-marked-candidates))
          (sel   (helm-get-selection)))
      (if (and sel
               (not (cdr cands))
               (file-directory-p sel)
               (string= "." (helm-basename sel)))
          (helm-next-line))))

  (advice-add 'helm-ff-setup-update-hook :after
              (defun $helm-add-skip-dot ()
                (add-hook 'helm-after-update-hook '$helm-skip-dots)))

  (advice-add 'helm-find-files-cleanup :after
              (defun $helm-remove-skip-dot ()
                (remove-hook 'helm-after-update-hook '$helm-skip-dots)))

  (advice-add 'helm-ff-filter-candidate-one-by-one
              :before-while (defun $helm-ff-not-parent-hardlink-p (file)
                              (not (string-suffix-p ".." file))))
#+END_SRC

ignore lockfiles and backups when looking through the filesystem
#+BEGIN_SRC emacs-lisp
  (csetq helm-boring-file-regexp-list
         (list "~" "#" (rx ".#" (1+ nonl))))
  (csetq helm-ff-skip-boring-files t)
#+END_SRC

open file in clipboard. Usually something I copied from an
email. automatically add the tramp header if from a different site
#+BEGIN_SRC emacs-lisp
  (defun $open-file-in-clipboard ()
    (interactive)
    (let* ((file (string-trim (current-kill 0)))
           (current-site (getenv "EC_SITE"))
           (target-site (if (string-match (rx bos "/nfs/" (group (1+ (not (any "/"))))) file)
                            (match-string 1 file)
                          current-site))
           (tramp (if (or (equal target-site "site")
                          (equal current-site target-site))
                      ""
                    (concat "/ssh:"
                            (if (equal target-site "sc")
                                "zone"
                              target-site)
                            ":" ))))
      (require 'helm-files)
      (helm-find-files-1 (concat tramp file) (file-name-base file))))
  ($leader-set-key
    "fo" '$open-file-in-clipboard)
#+END_SRC

a better fild-file-at-point function that allows full directory
naviagation
#+BEGIN_SRC emacs-lisp
  (defun $find-file-at-point ()
    "A better replacement for `find-file-at-point' that gives me
  the full power of helm"
    (interactive)
    (let ((file ($get-path-at-point)))
      (when-let ((root (and (string-match-p (rx "$" (opt "{") "MODEL_ROOT" ) file)
                            (vc-git-root default-directory))))
        (--> root
             (file-truename it)
             (string-remove-suffix "/" it)
             (string-remove-prefix (or (file-remote-p it) "") it)
             (setenv "MODEL_ROOT" it)))
      (require 'helm-files)
      (helm-find-files-1 (concat (or (file-remote-p default-directory) "")
                                 file)
                         (file-name-base file))))

  (general-define-key
   :states '(normal visual motion)
   :keymaps 'global
   "gf" '$find-file-at-point)
#+END_SRC

start a find file session from project root
#+BEGIN_SRC emacs-lisp
  (defun $find-file-project-root ()
    "start a helm find files session from project root"
    (interactive)
    (require 'helm-files)
    (if-let ((root (vc-git-root default-directory)))
        (helm-find-files-1 root)
      (user-error "no root found for current file")))

  ($leader-set-key
    "fp" '$find-file-project-root)
#+END_SRC

get helm history when writing a file
[[https://github.com/emacs-helm/helm/issues/2088#issuecomment-421999031][emacs-helm/helm#2088]]
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'helm-mode
    (add-to-list 'helm-completing-read-handlers-alist '(write-file . helm-read-file-name-handler-1)))
#+END_SRC

*** dispatcher
these are functions that I often want to run, but normally have to
exit helm to call their keybindings. So we create wrapper thats lets
us call them from helm.
#+BEGIN_SRC emacs-lisp
  (defun $helm-ag-from-session ()
    "Launch `helm-ag' from within a helm session"
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       'helm-do-ag
       helm-ff-default-directory
       (let ((cand (helm-marked-candidates)))
         ;; if we have not marked anything we want to search the current directory
         (unless (equal (list (helm-get-selection))
                        cand)
           cand)))))

  (defun $magit-from-helm-session ()
    "run magit from a helm session"
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       '$magit-status-in-dir
       helm-ff-default-directory)))

  (defun $meld-from-helm-session ()
    "run meld from a helm session"
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       (lambda (paths)
         (async-start-process "Helm Meld" "meld" nil
                              (nth 0 paths)
                              (nth 1 paths)))
       (helm-marked-candidates))))

  (defun $helm-ff-switch-to-shell ()
    "Run switch to shell action from `helm-source-find-files'."
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       '$shell-pop
       helm-current-prefix-arg
       helm-current-buffer
       helm-ff-default-directory)))

  (defun $helm-copy-to-kill-ring ()
    "Copy selection or marked candidates to the kill ring.
  Note that the real values of candidates are copied and not the
  display values.
  If a file name, copy the full path unless C-u prefix is given."
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       (lambda (cands)
         (with-helm-current-buffer
           (kill-new (mapconcat
                      (lambda (c)
                        (format "%s" (if (and (null helm-current-prefix-arg)
                                              (stringp c)
                                              (file-exists-p c))
                                         (file-truename c)
                                       c)))
                      cands "\n"))))
       (helm-marked-candidates))))
#+END_SRC

more convient keybindings for dispatcher functions as well as some
helm builtins
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'helm
    (general-define-key
     :keymaps 'helm-map
     "C-c y" '$helm-copy-to-kill-ring)
    (general-define-key
     :keymaps '(helm-find-files-map helm-read-file-map helm-generic-files-map)
     "C-r"   'helm-find-files-history
     "C-c b" 'helm-find-files-toggle-to-bookmark
     "C-c c" 'helm-ff-run-copy-file
     "C-c '" '$helm-ff-switch-to-shell
     "C-c s" '$helm-ag-from-session
     "C-c C-s" '$helm-ag-from-session
     "C-c m" '$meld-from-helm-session
     "C-c g" '$magit-from-helm-session
     "C-c C-g" '$magit-from-helm-session)
#+END_SRC

*** swoop
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :init
    (setq helm-swoop-split-with-multiple-windows t
          helm-swoop-speed-or-color t
          helm-swoop-candidate-number-limit 1000)
    (general-define-key
     "C-s" '$helm-swoop)
    :config
    (add-hook 'after-revert-hook 'helm-swoop--clear-cache)
    (general-define-key
     :keymaps 'helm-swoop-edit-map
     "C-c C-c" 'helm-swoop--edit-complete
     "C-c C-k" 'helm-swoop--edit-cancel))

  (defun $helm-swoop (arg)
    (interactive "P")
    (require 'helm-swoop)
    (let* ((prefix (equal arg '(4)))
           (helm-swoop-pre-input-function
            (if prefix
                (lambda ()
                  (if (region-active-p)
                      (buffer-substring (region-beginning)
                                        (region-end))
                    (or (thing-at-point 'symbol t) "")))
              (lambda () ""))))
      (helm-swoop :$multiline (unless prefix arg))))
#+END_SRC

*** ag
use the ag utility to search through files. The pcre package provides
us with PCRE compatible functions. PCRE is more intuitive then emacs
regex
#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :init
    (csetq helm-ag-base-command "/p/hdk/rtl/proj_dbin/shdk74/ag --nocolor --nogroup --search-zip")
    ($leader-set-key
      "sf" 'helm-do-ag
      "sF" '$helm-do-ag-region-or-symbol)
    (general-define-key
     "C-c s" '$helm-do-ag-current-dir
     "C-c C-s" '$helm-do-ag-current-dir))

  (defun $helm-do-ag-current-dir (arg)
    "search in the current directory with Ag"
    (interactive "P")
    (funcall (if arg '$helm-do-ag-region-or-symbol 'helm-do-ag) default-directory))

  (defun $helm-do-ag-region-or-symbol (&optional dir)
    "Search with `ag' with a default input."
    (interactive)
    (require 'helm-ag)
    (cl-letf* (((symbol-value 'helm-ag-insert-at-point) 'symbol)
               ;; make thing-at-point choosing the active region first
               ((symbol-function 'this-fn) (symbol-function 'thing-at-point))
               ((symbol-function 'thing-at-point)
                (lambda (thing)
                  (let ((res (if (region-active-p)
                                 (buffer-substring-no-properties
                                  (region-beginning) (region-end))
                               (this-fn thing))))
                    (when res (rxt-quote-pcre res))))))
      (helm-do-ag dir)))
#+END_SRC

*** projectile
this still needs to be setup, as I am currently using counsel
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :commands (helm-projectile-find-file
               helm-projectile-switch-project
               helm-projectile-switch-to-buffer
               helm-projectile-find-dir)
    :init
    (push '((nil . "helm-projectile") . (nil . "proj")) which-key-replacement-alist)
    (csetq projectile-use-git-grep t)
    ($leader-set-key
      "p" '(:ignore t :wk "project")
      "pp" 'helm-projectile-switch-project
      "pP" 'helm-projectile
      "ps" 'helm-projectile-ag
      "pf" 'helm-projectile-find-file
      "pb" 'helm-projectile-switch-to-buffer
      "pd" 'helm-projectile-find-dir)
    :config
    (defun $helm-projectile-pop-to-shell (dir)
      "open shell in project root"
      (interactive)
      ($shell-pop helm-current-prefix-arg (dired-noselect dir) dir))
    (defun $helm-projectile-find-file (dir)
      "run `helm-find-files' in root"
      (interactive)
      (let ((helm-ff-transformer-show-only-basename t))
        (helm-find-files-1 dir "target")))
    (helm-projectile-define-key helm-projectile-projects-map
      (kbd "C-c f") '$helm-projectile-find-file
      (kbd "C-c C-f") '$helm-projectile-find-file
      (kbd "C-c g") 'helm-projectile-vc
      (kbd "C-c C-g") 'helm-projectile-vc
      (kbd "C-c s") 'helm-projectile-grep
      (kbd "C-c C-s") 'helm-projectile-grep
      (kbd "C-c '") '$helm-projectile-pop-to-shell)

    (cl-callf append (alist-get 'filtered-candidate-transformer helm-source-projectile-files-list)
      '(helm-adaptive-sort))
    (setf (alist-get 'filtered-candidate-transformer helm-source-projectile-projects)
          '(helm-fuzzy-matching-default-sort-fn helm-fuzzy-highlight-matches helm-adaptive-sort))
    (setf (alist-get 'filtered-candidate-transformer helm-source-projectile-dired-files-list)
          '(helm-fuzzy-highlight-matches helm-adaptive-sort))
    (setf (alist-get 'filtered-candidate-transformer helm-source-projectile-directories-list)
          '(helm-fuzzy-matching-default-sort-fn helm-fuzzy-highlight-matches helm-adaptive-sort)))



#+END_SRC

*** org
use helm to quickly navigate org headings
#+BEGIN_SRC emacs-lisp
  ($leader-local-set-key
    :keymaps 'org-mode-map
    "j" 'helm-org-in-buffer-headings)

  (csetq helm-org-format-outline-path t)
#+END_SRC

*** themes
switch themes using helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-themes
    :general
    (:definer 'leader
              "T" 'helm-themes))
#+END_SRC

*** ediff
running ediff from helm is very convient. But the problem is that is
not reproducible. You have to reselect the files everytime, which is
time consuming. So we create a function to save the last ediff.
#+BEGIN_SRC emacs-lisp
  (defvar $ediff-targets nil
    "The last two files that were diffed")
  (defun $save-ediff-targets (&rest args)
    "Save the last two ediffed files"
    (setq $ediff-targets (car args)))
  (advice-add 'ediff-files-internal :filter-args #'$save-ediff-targets)

  (defun $run-last-ediff ()
    "Run ediff with the last used files"
    (interactive)
    (apply 'ediff-files-internal $ediff-targets))
  ($leader-set-key "fd" '$run-last-ediff)
#+END_SRC

** editing
*** general
make interprogram paste work correctly. don't update the primary when
in evil
#+BEGIN_SRC emacs-lisp
  (setq interprogram-paste-function 'x-cut-buffer-or-selection-value
        evil-kill-on-visual-paste nil)
  (fset 'evil-visual-update-x-selection 'ignore)
#+END_SRC

general editing configuration. We only want to use tabs in specific
major modes
#+BEGIN_SRC emacs-lisp
  (csetq indent-tabs-mode nil)
#+END_SRC

my filesystem generates regular backups, so having Emacs create
backups is redundant.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

some log files are *really* large, so don't warn about opening files
less the 500 MB
#+BEGIN_SRC emacs-lisp
  (csetq large-file-warning-threshold 500000000)
#+END_SRC

Only communists end sentences with two spaces.
#+BEGIN_SRC emacs-lisp
  (csetq sentence-end-double-space nil)
#+END_SRC

*** whitespace

use ws-butler to only fix trailing whitespace on lines that I
touch. That way it won't unnecessarily effect git diffs, but still
keeps me from being sloppy.
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :hook (org-mode prog-mode)
    :config
    (setq ws-butler-convert-leading-tabs-or-spaces t))
#+END_SRC

*always* add a final newline. some really stupid languages (looking at
you tcsh) require a final newline or the last line of a script never
gets executed.
#+BEGIN_SRC emacs-lisp
  (csetq require-final-newline t)
#+END_SRC

don't show me long lines in whitespace mode
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'whitespace
    (delq 'lines whitespace-style))
#+END_SRC

whitespace managment keybindings
#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "tw" 'whitespace-mode
    "xd" 'delete-trailing-whitespace)
#+END_SRC

show empty lines at the end of files
#+BEGIN_SRC emacs-lisp
  (setq-default indicate-empty-lines t)
#+END_SRC

*** normalization
Outlook is stupid and tries to replace the normal accent characters
with nonascii versions. This can cause problems when copying from the
an email or word doc. The function below will replace the formating
with their ascii equiviments.
#+BEGIN_SRC emacs-lisp
  (defun $normalize-text (beg end)
    "normalize characters used in Microsoft formatting"
    (let* ((orig-text (buffer-substring beg end))
           (normalized-text
            (thread-last orig-text
              (replace-regexp-in-string "–" "--")
              (replace-regexp-in-string (rx (char "‘’")) "'")
              (replace-regexp-in-string (rx (char "“”")) "\""))))
      (unless (equal orig-text normalized-text)
        (save-excursion
          (goto-char beg)
          (delete-region beg end)
          (insert normalized-text)))))

  (defun $normalize-region (beg end)
    "normalzie the last paste, or if region is selected, normalize
  that region."
    (interactive "r")
    (if (region-active-p)
        (progn ($normalize-text beg end)
               (deactivate-mark))
      (apply #'$normalize-text (cl-sort (list (point) (mark t)) '<))))

  ($leader-set-key
    "xn" '$normalize-region)
#+END_SRC
*** keybindings
#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "xa" 'align
    "xr" 'align-regexp
    "xt" 'untabify
    "zq" 'quick-calc)
#+END_SRC

*** narrowing
#+BEGIN_SRC emacs-lisp
  ($leader-set-key
    "n" '(:ignore t :wk "narrow")
    "nw" 'widen
    "nr" 'narrow-to-region
    "nf" 'narrow-to-defun)
#+END_SRC

*** move where I mean
move me to the start of the line or start of code, based on heuristics
#+BEGIN_SRC emacs-lisp
  (use-package mwim
    :general
    (:states 'insert
             "C-e" 'mwim-end
             "C-a" 'mwim-beginning))
#+END_SRC

*** dumb jump
dumb jump uses regexp search to try and find the definition of a symbol
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :general
    (:definer
     'leader
     "J" 'dumb-jump-go))
#+END_SRC

*** avy
avy is an awesome jump to point package.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :init
    (setq avy-timeout-seconds 0.3)
    :general (:states 'motion
                      ";" 'avy-goto-char-timer)
    :config
    (evil-collection-init 'avy))
#+END_SRC

*** easy motion
a evil motion package. by default the =F,f,T,t= bindings have buffer
scope, but that makes it too complex, so we will limit that to current
line only
#+BEGIN_SRC emacs-lisp
  (use-package evil-easymotion
    :general
    (:states '(normal visual)
             "f" 'evilem-motion-find-char
             "F" 'evilem-motion-find-char-backward
             "t" 'evilem-motion-find-char-to
             "T" 'evilem-motion-find-char-to-backward)
    :init
    ($leader-set-key
      "j" '(:keymap evilem-map :package evil-easymotion)))
#+END_SRC

*** yasnippet
provides snippets for adding complex blocks. use it with =M-/=
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish
    :defer 3
    :config
    (let ((inhibit-message t))
      (yas-global-mode)))
  (use-package yasnippet-snippets
    :diminish
    :after yasnippet)
#+END_SRC

*** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :defer 3
    :init
    (setq projectile-enable-caching t)
    :config
    (projectile-mode))
#+END_SRC

**** performance
finding the root of the project can sometimes be costly. Since I am
always using git I can just locate the vc-git-root function and ignore
remote files.
#+BEGIN_SRC emacs-lisp
  (defun $git-root-unless-remote (dir)
    (unless (file-remote-p dir)
      (require 'vc-git)
      (vc-git-root dir)))

  (csetq projectile-project-root-files-functions '($git-root-unless-remote))
#+END_SRC

the most expensive part of loading a file with projectile is
reserializing the cache. So we remove that step and make sure that
everything is updated before we quit.
#+BEGIN_SRC emacs-lisp
  (advice-add 'projectile-cache-current-file :around
              (defun $no-cache-write (fn)
                (cl-letf* (((symbol-function 'projectile-serialize-cache)
                            (lambda () nil)))
                  (funcall fn))))

  (add-hook 'kill-emacs-hook 'projectile-serialize-cache)
#+END_SRC

*** multiedit
mutliedit is a hybrid of evil-iedit-state and evil-mc.

#+BEGIN_SRC emacs-lisp
  (use-package evil-multiedit
    :init
    (csetq evil-multiedit-use-symbols t)
    ($leader-set-key
      "se" 'evil-multiedit-match-all)
    :general
    (:states 'visual
             "M-d" 'evil-multiedit-match-and-next
             "M-D" 'evil-multiedit-match-and-prev
             "C-M-D" 'evil-multiedit-restore
             "R" 'evil-multiedit-match-all)
    (:states 'normal
             "M-d" 'evil-multiedit-match-symbol-and-next
             "M-D" 'evil-multiedit-match-symbol-and-prev
             "R" 'evil-multiedit-match-all)
    (:states 'insert
             "M-d" 'evil-multiedit-toggle-marker-here)
    (:keymaps 'evil-multiedit-state-map
              "RET" 'evil-multiedit-toggle-or-restrict-region)
    (:keymaps '(evil-multiedit-state-map
                evil-multiedit-insert-state-map)
              "C-n" 'evil-multiedit-next
              "C-p" 'evil-multiedit-prev))
#+END_SRC

*** hex decimal conversion

#+BEGIN_SRC emacs-lisp
  (defun $radix-name (radix)
    (or (nth radix '("NA" "Unary" "Binary"
                     "Ternary" "Quaternary" "Quinary"
                     "Senary" "Heptary" "Octal"
                     "Nonary" "Decimal" "Undecimal"
                     "Duodecimal" "Tridecimal" "Tetradecimal"
                     "Pentadecimal" "Hexadecimal"))
        (format "(base %d)" radix)))

  (defun $convert-radix-internal (str old-radix new-radix)
    "internal function to convert between two radices"
    (require 'calc-ext) ;; big numbers
    (require 'calc)
    (message "%s %s = %s %s"
             ($radix-name old-radix)
             str
             ($radix-name new-radix)
             (let ((calc-number-radix new-radix))
               (kill-new (downcase (math-format-radix (string-to-number str old-radix)))))))

  (defun $convert-hex-binary ()
    "Converts hex to binary or vice versa and copies the results to the kill ring"
    (interactive)
    (let* ((str (apply 'buffer-substring-no-properties
                       (--map (save-excursion
                                (funcall it "[:xdigit:]#'hx")
                                (point))
                              '(skip-chars-backward skip-chars-forward))))
           (radix (--if-let (car (s-match (rx bos (or (and (0+ (any digit)) "'" (any "hb"))
                                                      (and (any "0#") (any "bx"))))
                                          str))
                      (progn (setq str (s-chop-prefix it str))
                             (if (s-contains? "b" it) 'bin 'hex))
                    'bin)))
      (apply '$convert-radix-internal str (if (eq radix 'bin) '(2 16) '(16 2)))))

  (defun $convert-radix (r1 r2)
    "Convert one radix to another and copy the result to the kill ring"
    (interactive "ncurrent radix: \nndesired radix: ")
    (let* ((valid-chars (if (<= r1 10)
                            (format "0-%d" (- r1 1))
                          (let ((max-char (cond
                                           ((eql r1 11) "a")
                                           ((eql r1 12) "b")
                                           ((eql r1 13) "c")
                                           ((eql r1 14) "d")
                                           ((eql r1 15) "e")
                                           ((eql r1 16) "f"))))
                            (format "0-9a-%sA-%s" max-char (upcase max-char)))))
           (str (apply 'buffer-substring-no-properties
                       (--map (save-excursion
                                (funcall it valid-chars)
                                (point))
                              '(skip-chars-backward skip-chars-forward)))))
      ($convert-radix-internal str r1 r2)))

  ($leader-set-key
    "xc" '$convert-radix
    "xh" '$convert-hex-binary)

#+END_SRC

*** regex

ample regexps lets us define =rx= short hand that we can use to make
writing regexp clearer.
#+BEGIN_SRC emacs-lisp
  (defvar $rx-defaults
    '((spc (any " \t"))
      (spc+ (1+ spc))
      (spc* (0+ spc))
      (-> (1+ any))
      (^ bol)
      (file (1+ (any alnum "-_/.")))
      (symbol (1+ (any alnum "_")))
      (nums (1+ num))
      (fp (1+ (any num "."))))
    "modified rx forms that are really usefull")

  (use-package ample-regexps
    :commands $rx
    :config
    (define-arx $rx $rx-defaults))
#+END_SRC

pcre2el lets us convert between Emacs regexp and PCRE. very
usefull for debugging.
#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :commands reb-change-syntax)
#+END_SRC

*** tramp
set TRAMP verbosity to warnings and errors only. default is level 3
which sends a message every time we connect to a remote host
#+BEGIN_SRC emacs-lisp
  (csetq tramp-default-method "ssh")

  (with-eval-after-load 'tramp
    (add-to-list 'tramp-remote-path "/usr/intel/bin"))
#+END_SRC

by default tramp tries to parse =/etc/ssh2/hostkeys= for the hostkey
names but this file does not exist. This leads to an error everytime
we try to get the hostkey names. I tried just defining the completion
functions after tramp was loaded, something is still setting it back
to the defaults. So I created a function to be called as part of helm
that will set the completion functions right before tramp tries to use
them. I would love to remove this advice and only set it once.
#+BEGIN_SRC emacs-lisp
  (advice-add 'helm-ff--tramp-hostnames :before
              (defun $helm-set-tramp-host-names ()
                (unless  (equal '("ssh" (tramp-parse-hosts "~/.ssh2/ssh2_config"))
                                (assoc "ssh" tramp-completion-function-alist))
                  (tramp-set-completion-function "ssh" '((tramp-parse-hosts "~/.ssh2/ssh2_config")))
                  (tramp-set-completion-function "scp" '((tramp-parse-hosts "~/.ssh2/ssh2_config"))))))
#+END_SRC

** files
*** functions
collection of functions stolen from spacemacs
#+BEGIN_SRC emacs-lisp
  (defun $copy-file ()
    (interactive)
    (let* ((destination (read-file-name "Write File: "))
           (dir (file-name-directory destination)))
      (unless (file-exists-p dir)
        (make-directory dir 'parents))
      (write-file destination 'confirm)))

  (defun $delete-file ()
    (interactive)
    (delete-file (buffer-file-name)))

  (defun $rename-file ()
    (interactive)
    (let* ((destination (read-file-name "Rename File: "))
           (dir (file-name-directory destination)))
      (unless (file-exists-p dir)
        (make-directory dir 'parents))
      (rename-file (buffer-file-name) destination)))

  (defun $find-user-config-file ()
    "Edit the org file we use for config, in the current window."
    (interactive)
    (find-file-existing (expand-file-name "emacs.org" user-emacs-directory)))

  (defun $kill-this-buffer ()
    "kill this buffer"
    (interactive)
    (kill-buffer (current-buffer)))

  (defun $async-delete-file (file)
    "delete a file or directory by moving it to a tmp location and
  then removing in the background"
    (interactive "D")
    (if (not (file-exists-p file))
        (message (format "file %s does not exist" file))
      (message (format "deleting %s asynchronously" file))
      (async-start
       (lambda ()
         (let ((tmp-file (make-temp-name (concat file ".del."))))
           (rename-file file tmp-file)
           (if (file-directory-p tmp-file)
               (delete-directory tmp-file 'recursive)
             (delete-file tmp-file))))
       (lambda (_result)
         (message (format "file %s deleted successfully" file))))))

  ($leader-set-key
    "f" '(:ignore t :wk "files")
    "fe" '$find-user-config-file
    "fc" '$copy-file
    "bd" '$kill-this-buffer
    "fD" '$delete-file
    "fR" '$rename-file)
#+END_SRC

*** find similar file
search up the directory stack looking for files that only differ from
the current file by one directory. This is useful for mulitply
instantiated files that use the same path with a different parent. For example

foo/bar/baz.txt
foo/bat/baz.txt
foo/ban/baz.txt

would all be considered similar files.
#+BEGIN_SRC emacs-lisp
  (defun $switch-to-similar-file ()
    "find a file of the same name with only one directory different"
    (interactive)
    (require 'f)
    (if-let ((file (buffer-file-name))
             (parts (f-split file))
             (other-files ($find-similar-file (butlast parts 2) (car (last parts 2)) (last parts)))
             (common-parent (f-common-parent other-files))
             (unique-file (completing-read "select other file: " (f-uniquify other-files))))
        (find-file (f-join common-parent unique-file))
      (cond ((buffer-file-name) (user-error "No similar file found"))
            (t (user-error "buffer not visitng a file")))))


  (defun $find-similar-file (head dir tail)
    "search up the directory path for paths that very by only one
  directory pointing to the same file name"
    ;; anything above 5 depth is not worth searching becase we are out
    ;; of the disk
    (when (>= (length head) 5)
      (let* ((parent (apply 'f-join head))
             (child (apply 'f-join tail))
             (dirs (delete (f-join parent dir) (f-directories parent)))
             (valid-paths (-filter 'file-exists-p
                                   (--map (f-join it child) dirs))))
        (or valid-paths
            ($find-similar-file (butlast head) (car (last head)) (cons dir tail))))))

  ($leader-set-key
    "fs" '$switch-to-similar-file)
#+END_SRC

*** dired
we don't need so many dired confirmation prompts
#+BEGIN_SRC emacs-lisp
  (setq dired-no-confirm t)
#+END_SRC

*** recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (setq recentf-max-saved-items 500
          recentf-auto-cleanup "11:00pm"))
#+END_SRC

*** ediff
I like to keep everything in one frame. I am not a mutli-window
heathen from 2003
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (evil-collection-init 'ediff)
#+END_SRC

** git

don't ask about following symlinks
#+BEGIN_SRC emacs-lisp
  (csetq vc-follow-symlinks t)
#+END_SRC

only look for git registered files
#+BEGIN_SRC emacs-lisp
  (csetq vc-handled-backends '(Git))
#+END_SRC

*** vc-git
Emacs built in version control
#+BEGIN_SRC emacs-lisp
  (autoload (function vc-git-root) "vc-git")
#+END_SRC

*** magit
magit is the best git porcelain that exists, so far as I can tell. we
need to set the git version to a newer version because the default at
intel is not support. Also the Trash at intel is only 100M so trashing
files can quickly fill up my home disk.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    (csetq magit-git-executable "/usr/intel/pkgs/git/2.12.0/bin/git"
           magit-delete-by-moving-to-trash nil
           magit-remote-add-set-remote.pushDefault 'ask)
    ($leader-set-key
      "g" '(:ignore t :wk "git")
      "gs" 'magit-status
      "gb" 'magit-blame
      "gf" 'magit-file-popup)
    :config
    (general-define-key
     :keymaps 'magit-diff-mode-map
     "SPC" nil))
#+END_SRC

expanding the diffs can often take too long
#+BEGIN_SRC emacs-lisp
  (csetq magit-diff-expansion-threshold 20)
#+END_SRC

start the commit message editor in insert state
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'with-editor
    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

I don't like to commit to my github repos using my work credentials,
but I can't use my private credentials on my work repos. therefore I
set ~useconfigonly = true~ so that I have to set the credentials for
every repo. I can use these functions as short hand.
#+BEGIN_SRC emacs-lisp
  (defun $git-work-user ()
    "Set my work credentials"
    (interactive)
    (shell-command "git config --local user.name \"Hinckley, Troy J\" &&
     git config --local user.email troy.j.hinckley@intel.com"))

  (defun $git-private-user ()
    "Set my work credentials"
    (interactive)
    (shell-command "git config --local user.name CeleritasCelery &&
     git config --local user.email t.macman@gmail.com"))

  ($leader-set-key
    "gu" '(:ignore t :wk "user")
    "guw" '$git-work-user
    "gup" '$git-private-user)
#+END_SRC

calling =magit-status= on a whole IP can be very time
consumuing. Often I am just trying to look at a single directory, and
this gives me the power to do that.

#+BEGIN_SRC emacs-lisp
  (defun $magit-status-in-dir (dir)
    "limit magit status to directory"
    (interactive "D")
    (require 'magit)
    (let* ((root (vc-git-root dir))
           (dir (list (file-relative-name dir root)))
           (magit-status-mode-hook (cons (lambda () (setq-local magit-diff-section-file-args dir))
                                         magit-status-mode-hook)))
      (magit-status-internal root)))

  (defun $magit-status-current-dir ()
    "run magit in current dir"
    (interactive)
    ($magit-status-in-dir default-directory))

  (defun $magit-clear-diff-args-if-not-dir-local ()
    (unless (assq 'magit-diff-section-file-args dir-local-variables-alist)
      (setq-local magit-diff-section-file-args nil)))

  (advice-add 'magit-status :around
              (defun $magit-remove-diff-args (fn &rest args)
                (let ((magit-status-mode-hook (cons '$magit-clear-diff-args-if-not-dir-local
                                                    magit-status-mode-hook)))
                  (apply fn args))))

  ($leader-set-key
    "gd" '$magit-status-current-dir
    "gs" 'magit-status)
  (general-define-key
   "C-c g" '$magit-status-current-dir)
#+END_SRC

*** evil
#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :demand t
    :after magit
    :config
    (general-define-key
     :keymaps 'magit-mode-map
     "SPC" nil))

  (use-package git-timemachine
    :init
    (evil-collection-init 'git-timemachine)
    ($leader-set-key
      "gt" 'git-timemachine))
#+END_SRC

*** git gutter
git gutter uses the the margin to display the git status. the frige
package uses the fringe instead of the margin. This means that it
won't conflict with linum-mode. However since I don't need linum mode
I can probably remove git gutter fringe all together. All the that it
would offer me is that I could display of the left side, which I may
want to do when I enable flycheck.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :defer 3
    :init
    (setq git-gutter:diff-option "-w")
    (defhydra $git-hunk (:exit nil)
      ("n" git-gutter:next-hunk "next")
      ("p" git-gutter:previous-hunk "prev")
      ("r" git-gutter:revert-hunk "revert")
      ("h" $git-gutter-show-hunk "show hunk" :exit t)
      ("s" git-gutter:stage-hunk "stage")
      ("v" git-gutter:mark-hunk "mark" :exit t))
    ($leader-set-key
      "gg" '$git-hunk/body)
    :config
    (global-git-gutter-mode))

  (use-package git-gutter-fringe
    :diminish
    :demand t
    :after git-gutter)
#+END_SRC

these changes the behavior of the git gutter popup so that I can quit
with =q= and the window is selected.
#+BEGIN_SRC emacs-lisp
  (advice-add 'git-gutter:update-popuped-buffer :after
              (defun $git-gutter-window-quit (&rest _)
                (when-let ((buffer (get-buffer git-gutter:popup-buffer)))
                  (with-current-buffer buffer
                    (general-define-key
                     :keymaps 'local
                     :states 'normal
                     "q" 'quit-window)))))

  (defun $git-gutter-show-hunk ()
    (interactive)
    (git-gutter:popup-hunk)
    (pop-to-buffer git-gutter:popup-buffer))
#+END_SRC

** shell
*** comint
comint is the generic backend for REPL's and shells. We are giving it
more bash-it style behavior where I can enter some text and then use
the previous command to match against it. Also we can use ivy to
search through the command history. also whenever we try to go to the
previous command it will automatically move us the the command line.
#+BEGIN_SRC emacs-lisp
  (use-package comint
    :straight nil
    :general
    (:keymaps 'comint-mode-map
              "C-k" 'comint-previous-matching-input-from-input
              "C-j" 'comint-next-matching-input-from-input
              "C-S-k" 'comint-previous-prompt
              "C-S-j" 'comint-next-prompt
              [remap comint-dynamic-list-input-ring] 'helm-comint-input-ring)
    :init
    (setq comint-scroll-to-bottom-on-input t
          comint-process-echoes t
          comint-prompt-read-only t))

  (defun $goto-cmd-line (&rest _)
    (goto-char (point-max)))

  (general-advice-add '(comint-next-matching-input-from-input
                        comint-previous-matching-input-from-input) :before '$goto-cmd-line)
#+END_SRC

*** shell
these are utility functions used to setting up the Emacs shell.
#+BEGIN_SRC emacs-lisp
  (use-package shell
    :straight nil
    :gfhook company-mode)

  (defvar $dir-history nil
    "previous shell directories")
  (make-variable-buffer-local '$dir-history)

  (defun $select-shell-history ()
    (interactive)
    (goto-char (point-max))
    (insert (concat "cd " (string-remove-prefix (or (file-remote-p default-directory) "")
                                                (completing-read "directory:" $dir-history)))))

  (general-define-key
   :keymaps 'shell-mode-map
   "C-c C-j" '$select-shell-history)

  (defun $track-shell-directory (str)
    "use the proc filesytem to get the current directory.
    Works on remote shells as well if `shx' and `shx-cmd-set-pid' are used. The
    remote shell will need to echo it's PID in the rc file in the form of `shx'
    markup."
    (when (string-match comint-prompt-regexp str)
      (when-let ((remote  (or (file-remote-p default-directory) ""))
                 (dir (-some->> (local-env-get-shell-pid)
                             (format "/proc/%s/cwd")
                             (concat remote)
                             file-symlink-p)))
        (cd (concat remote dir))
        (unless (equal dir (car $dir-history))
          (push dir $dir-history))))
    str)

  (defun $supress-hostkey-warning (str)
    "EC machines issue a benign but really annoying warning that the EC people
      don't have the technical competence to fix. It has the following form:

      add_host_to_hostkeys: failed to open <missing path> - reason Permission denied "
    (if (string-match "add_host_to_hostkeys: failed to open" str) "" str))

  (with-eval-after-load 'shell
    (modify-syntax-entry ?= "." shell-mode-syntax-table)
    (modify-syntax-entry ?> "." shell-mode-syntax-table)
    (modify-syntax-entry ?> "." shell-mode-syntax-table))

  (defun $shell-mode-hook ()
    (shell-dirtrack-mode 0)
    (setq-local comint-prompt-regexp (rx bol "╰─→ " eos))
    (setq-local evil-search-wrap nil)
    (local-env-mode)
    (setq-local company-backends '(company-async-files
                                   (company-command company-env)
                                   (company-capf company-dabbrev-code)))
    (general-add-hook 'comint-preoutput-filter-functions
                      '($supress-hostkey-warning $track-shell-directory) nil 'local))
  (add-hook 'shell-mode-hook '$shell-mode-hook)
#+END_SRC

generic wrapper function that can be called from other code. currently
used in helm
#+BEGIN_SRC emacs-lisp
  (defun $shell-pop (arg buffer dir)
    "shell-pop to current buffers directory or dir"
    (if (and (boundp 'shell-pop-last-shell-buffer-name)
             (equal (buffer-name buffer)
                    shell-pop-last-shell-buffer-name))
        (shell-pop--cd-to-cwd dir)
      (let ((default-directory dir))
        (shell-pop arg))))
#+END_SRC

I want =C-d= to scroll, not delete a character
#+BEGIN_SRC emacs-lisp
  (when evil-want-C-d-scroll
    (general-define-key
     :keymaps 'comint-mode-map
     "C-d" nil))
#+END_SRC

*** shx
shx mode allows us to call emacs lisp functions from within the
builtin shell, gives us the best of both worlds.
#+BEGIN_SRC emacs-lisp
  (use-package shx
    :diminish
    :hook shell-mode
    :general
    (:keymaps 'shx-mode-map
              "C-<return>" '$shx-send-input-or-copy-path))

  (defun $get-path-at-point ()
    (or (when (and (memq major-mode '(cperl-mode perl-mode))
                   (require 'ffap-perl-module nil 'noerror))
          (ffap-perl-module-file-at-point))
        (thread-last
            (apply 'buffer-substring-no-properties
                   (--map (save-excursion
                            (funcall it "-{}[:alnum:]$/._~\"")
                            (point))
                          '(skip-chars-backward skip-chars-forward)))
          (replace-regexp-in-string (rx (1+ (any space "\""))) "")
          (replace-regexp-in-string (rx (1+ "/")) "/")
          (replace-regexp-in-string "$ENV" "$"))))

  (defun $shx-send-input-or-copy-path ()
    "send command or copy path at point"
    (interactive)
    (if (shx-point-on-input-p)
        (shx-send-input)
      (let ((path ($get-path-at-point)))
        (goto-char (point-max))
        (insert path))))
#+END_SRC

*** exec path from shell
the =EMACS_CAPTURE_ENV= is used as part of my tcshrc file to source
the proper env scripts so that all these variables are set
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package exec-path-from-shell
    :defer 6
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    (exec-path-from-shell-initialize)

    (let ((exec-path-from-shell-shell-name "tcsh")
          (exec-path-from-shell-arguments nil))
      (setenv "EMACS_CAPTURE_ENV" "1")
      (exec-path-from-shell-copy-envs '("IP_MODELS"
                                        "IP_RELEASES"
                                        "GIT_REPOS"
                                        "RTLMODELS"
                                        "RTL_PROJ_TOOLS"
                                        "RTL_PROJ_CFG"
                                        "RTL_PROJ_BIN"
                                        "RTL_CAD_ROOT"
                                        "GLOBAL_TOOLS"
                                        "CFG_PROJECT"
                                        "VALID_ROOT"
                                        "VTLIB"))
      (setenv "EMACS_CAPTURE_ENV" nil)))
#+END_SRC

*** shell pop
pop up the shell in my current directory
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :init
    ($leader-set-key
      "'" 'shell-pop
      "\"" '$shell-pop-root)
    (general-define-key
     :keymaps '(global org-mode-map)
     "C-c '" 'shell-pop
     "C-c \"" '$shell-pop-root))

  (defun $shell-pop-root (arg)
    "open a shell in the project root"
    (interactive "P")
    (let ((default-directory (vc-git-root default-directory)))
      (shell-pop arg)))
#+END_SRC

only send a cd command if we are not already in that directory
#+BEGIN_SRC emacs-lisp
  (advice-add 'shell-pop--cd-to-cwd
              :before-until
              (defun $shell-in-cwd-p (cwd)
                (file-equal-p default-directory cwd)))
#+END_SRC

my current bash prompt is 2 lines, so we always scroll one line down
so that I can see the whole thing. probably need to make this code
smarter
#+BEGIN_SRC emacs-lisp
  (advice-add 'shell-pop--cd-to-cwd
              :after
              (defun $scroll-shell-pop (_)
                (scroll-down 1)))
#+END_SRC

fix [[https://github.com/kyagi/shell-pop-el/issues/51][kyagi/shell-pop-el#51]]
#+BEGIN_SRC emacs-lisp
  (add-to-list 'shackle-rules `(,(rx "*shell*") :regexp t :same t))
#+END_SRC

*** async file completion
I wrote this package to do async file completion. This is especially
true when using this in a shell, where you don't want to block the ui
while typing.
#+BEGIN_SRC emacs-lisp
  (use-package company-async-files
    :after company
    :straight
    (company-async-files
     :type git :host github :repo "CeleritasCelery/company-async-files")
    :init
    (add-to-list 'company-backends 'company-async-files)
    (setq company-backends (delete 'company-files company-backends)))
#+END_SRC

*** argument completion
provide auto completion for the command line arguments of the command
at point.
#+BEGIN_SRC emacs-lisp
  (use-package company-arguments
    :after company
    :straight
    (company-arguments
     :type git :host github :repo "CeleritasCelery/company-arguments")
    :init
    (add-to-list 'company-backends 'company-arguments))
#+END_SRC

*** local env
These packages will be loaded by shell-mode. They let me share the
environment of my local process with the buffer. very useful.
#+BEGIN_SRC emacs-lisp
  (use-package local-env
    :straight
    (local-env :type git
               :host github
               :repo "CeleritasCelery/local-env-mode"
               :files ("local-env.el"))
    :init
    (setq local-env-capture-variables '("MODEL_ROOT"
                                        "STF_SPFSPEC"
                                        "TAP_SPFSPEC"
                                        "TAP2STF_MAP_FILE"
                                        "XWEAVE"
                                        "XWEAVE_REPO_ROOT"
                                        "SPF_ROOT"
                                        "SPF_PERL_LIB"
                                        "LD_LIBRARY_PATH"
                                        "DFT_REPO_ROOT"))
    ($leader-local-set-key
      :keymaps 'shell-mode-map
      "e" 'local-env-capture))

  (use-package company-env
    :straight
    (company-env :type git
                 :host github
                 :repo "CeleritasCelery/local-env-mode"
                 :files ("company-env.el")))

  (use-package company-command
    :straight
    (company-command :type git
                     :host github
                     :repo "CeleritasCelery/local-env-mode"
                     :files ("company-command.el")))
#+END_SRC

** compilation
packages that assist in compiling and building code

*** compile
#+BEGIN_SRC emacs-lisp
  (use-package compile
    :straight nil
    :init
    (add-to-list 'shackle-rules '(compilation-mode :select t))
    (add-to-list 'shackle-rules '(comint-mode :select t))
    ($leader-set-key
      "o" '(:ignore t :wk "compile")
      "oc" '$compile)
    :config
    (evil-collection-init 'compile)
    (general-define-key
     :keymaps 'compilation-mode-map
     "SPC" nil))

  (defun $compile ()
    "compile with hdk enviroment sourced"
    (let* ((root (vc-git-root default-directory))
           (model-root (or (file-truename root) "no-model"))
           (compilation-environment (list (concat "MODEL_ROOT=" model-root)))
           (compilation-buffer-name-function
            (lambda (_mode)
              (format "*%s compile*"
                      (f-filename model-root)))))
      (compile (concat "source /p/hdk/rtl/hdk.rc -cfg shdk74 && " (read-string "Compile Command: " nil compile-history)))))
#+END_SRC


compilation mode will throw these warnings when clearing large buffers
so we supress them
#+BEGIN_SRC emacs-lisp
  (setq warning-suppress-types '(undo discard-info))
#+END_SRC

*** keybindings
compillation can either be run in =compilation-mode= or in
=comint-mode= with =compilation-shell-minor-mode= enabled. The later
is needed when we want to interact with the running process. This has
a few issues that we are going to resolve now:

1. There is a weird issue where the recompile buffer is not the same
   as the original buffer. Therefore we force the buffer name to remain the same by overriding the =compilation-arguments=.

2. It is really convient to dismiss the compilation window with =q= so
   we are going to bind that. regular compilation-mode supports this
   binding by default.

3. We want to start in normal state, so we easily dismiss the
   window with =q= right when it first pops up if we want.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :definer 'minor-mode
   :states 'normal
   :keymaps 'compilation-shell-minor-mode
   "q" 'quit-window
   "gr" 'recompile
   "gf" '$find-file-at-point
   "C-j" 'compilation-next-error
   "C-k" 'compilation-previous-error)
  (general-define-key
   :states 'normal
   :keymaps 'compilation-minor-mode-map
   "C-j" 'compilation-next-error
   "C-k" 'compilation-previous-error)
  (general-define-key
   :states 'normal
   :keymaps 'compilation-mode-map
   "gf" '$find-file-at-point)

  (advice-add 'recompile :before (defun $set-recompile-buffer-name (_)
                                   (setf (nth 2 compilation-arguments) (lambda (_) (buffer-name)))))

  (add-hook 'compilation-shell-minor-mode-hook 'evil-normal-state)
#+END_SRC

*** ansi-color
Emacs can interpret ansi escape codes as font lock

#+BEGIN_SRC emacs-lisp
  (defun $apply-ansi-color-on-buffer ()
    "apply ANSI color codes in this buffer"
    (interactive)
    (ansi-color-apply-on-region (point-min) (point-max)))
#+END_SRC

*** errors
Define some custom rx forms that are common to all error messages
#+BEGIN_SRC emacs-lisp
  (define-arx err-rx
    (append $rx-defaults
            '((fill (1+ (not (any space))))
              (filename (group-n 1 file))
              (line (group-n 2 nums))
              (col (group-n 3 nums))
              (info (opt "-I-:")))))
#+END_SRC

we need to define what errors look like in compilation and log
files. compilation mode has some defaults but they are not really
applicable to us. Also the built-in verilog mode tries to add all of
its error regexp's to the alist everytime it is loaded. This results
in a lot of extra processing that we don't want. Therefore we remove
that hook and set the alist back to our canonical version.
#+BEGIN_SRC emacs-lisp
  (defvar $compilation-error-regexp-alist nil
    "The canonical error regexp alist")

  (setq compilation-error-regexp-alist
        (setq $compilation-error-regexp-alist
              `((,(err-rx ^ "-I-:Error-" ->
                          "\n-I-:" filename ", " line)
                 1 2)
                (,(err-rx ^ "-E-:SGDFT" -> "FAILED"
                          "\n-I-:  Error" ->
                          "\n-I-:  Use" ->
                          "\n-I-:Report: " filename)
                 1)
                (,(err-rx ^ spc+ "simregress invocation failed on " ->
                          "\n" spc+ "Refer to " -> ": " filename)
                 1)
                (,(err-rx ^ "Error-[" (group-n 3 ->) "]" ->
                          "\n" filename ", " line)
                 1 2 nil nil nil (3 font-lock-warning-face))
                (,(err-rx ^ "-E-:FAILED: emubuild" -> "REASON : failed LOG :  "
                          filename)
                 1)
                (,(err-rx ^ "  Log: " filename)
                 1)
                (,(err-rx ^ "UPFSEM_4" spc+ (1+ word) spc+
                          filename spc+ line)
                 1 2)
                (,(err-rx ^ "Errormessage   : Failed to open input file ["
                          filename "]")
                 1)
                (,(err-rx ^ info "  Error occurred at File: " filename " Line: " line)
                 1 2)
                (,(err-rx ^ "-I-:-E-:" symbol ": invalid HSD waiver: " -> " file '" filename "'")
                 1)
                (,(err-rx ^ line ": " (or "OVM_ERROR" "OVM_FATAL") " ")
                 (0 "acerun.log.gz") 2)
                (,(err-rx ^ (or "OVM_ERROR" "OVM_FATAL") " " filename ":" line " @ ")
                 1 2)
                (,(err-rx ^ "-I-:ERROR: " symbol " has " nums " upf error" (opt "s")
                          "\n-I-:Check: " filename)
                 1)
                (,(err-rx ^ "-I-:Detailed violation log for sgdft_drc for " symbol ": " filename)
                 1)
                (,(err-rx ^ "-E-:Error in stage bman.mdf_10nm.vclp." symbol ":"
                          "\n-I-:***** Cat'ing logs *****"
                          "\n-I-:Executing: cat " filename)
                 1)
                (,(err-rx ^ "-I-:" (opt "DIE signal:") " ERROR " nums ": Couldn't find directory '" filename "'")
                 1)
                (,(err-rx ^ "-F-:Failing test in " filename)
                 1)
                (,(err-rx ^ "-I-:FAILED: Exit status of pid " nums " was '" nums "', user expected '0'; LOG " filename)
                 1)
                ;; this used to be in ipgen, may need to be in both
                (,(err-rx ^ "Information: script '" filename
                          "'\n" spc+ "stopped at line " line ->)
                 1 2)
                (,(err-rx ^ "Could not open file No such file or directory at " filename " line " line)
                 1 2)
                (,(err-rx ^ "-F-: [CRT-023] Error in conncection file adhoc connection file " filename
                          "\nError at line# " line)
                 1 2)
                (,(err-rx ^ "ERROR: couldn't parse " filename ":")
                 1)
                (,(err-rx ^ "FATAL                (F) Exception caught: " (1+ nonl) " at " filename " line " line)
                 1 2)
                (,(err-rx ^ "//  Error: File: " filename ", Line: " line ": " (1+ nonl))
                 1 2)
                (,(err-rx ^ filename ":" line ": [Error]" (1+ nonl))
                 1 2))))


  (with-eval-after-load 'verilog-mode
    (remove-hook 'compilation-mode-hook 'verilog-error-regexp-add-emacs)
    (setq compilation-error-regexp-alist $compilation-error-regexp-alist))
#+END_SRC

**** font lock fix
There is any issue where an error message spans multiple lines, the
font lock engine will sometimes stop parsing in the middle of it and
therefore it will never get highlighted. We fix this by creating our
own =font-lock-extend-region= function that makes sure we do not stop
on error messages.
#+BEGIN_SRC emacs-lisp
  (defun $font-lock-extend-region-error-message ()
    (defvar font-lock-end)
    (save-excursion
      (goto-char font-lock-end)
      (beginning-of-line)
      (when (looking-at-p (rx (opt "-I-:")
                              (or "Error: "
                                  " Error"
                                  "Error-"
                                  "Errormessage"
                                  "-E-:"
                                  "-F-:")))
        (forward-line 2)
        (setq font-lock-end (point)))))
  (byte-compile '$font-lock-extend-region-error-message)

  (general-add-hook '(compilation-mode-hook
                      compilation-minor-mode-hook
                      compilation-shell-minor-mode-hook)
                    (defun $set-font-lock-error-function ()
                      (add-hook 'font-lock-extend-region-functions
                                '$font-lock-extend-region-error-message
                                'append
                                'local)))
#+END_SRC

*** functions
functions that are used for compilation of ipgen and bman or turnin.

**** ipgen

all the errors I have encountered in IPGen
#+BEGIN_SRC emacs-lisp
  (defvar ipgen-error-regexp-alist
    `((,(err-rx ^ "gmake: *** [" (group-n 1 (>= 10 any)) "] Error " num)
       1)
      (,(err-rx ^ info "Error: " (group-n 3 ->)
                "\n" info "-" (or "E" "F") "-: [CRT-" nums "] Error in "
                -> " file " filename spc*
                "\n" info " Error at line# " line ->)
       1 2 nil nil nil (3 compilation-info-face))
      (,(err-rx ^ "-I-:Error-[MPD] Module previously declared"
                "\n-I-:  The module was previously declared at: "
                "\n-I-:  \"" (group fill) "/" fill (or ".vs" ".sv") "\",")
       (1 "%s/dft_ipgen.hdl"))
      (,(err-rx ^ "-E- Unable to parse JSON file " filename ":"
                -> "line " line
                " offset " col)
       1 2 3)
      (,(err-rx ^ "-F-: [CRT-023] Error in conncection file adhoc connection file " filename
                "\nError at line# " line)
       1 2))
    "errors seen while running ipgen")
#+END_SRC

ipgen will some times pull up a coreassembler prompt when it fails.
this can lead to a test being suck for a long time without alerting
the user. So we check for the CoreAssembler prompt and alert the user
if that is the case. We also add the buffer to a list of stalled runs
so that status is acurate when we list all compilations.
#+BEGIN_SRC emacs-lisp
  (defvar $compilation-stalled-buffers nil
    "buffers that have a stalled compilation")

  (defun $alert-core-assembler-stall ()
    (defvar compilation-filter-start)
    (when (looking-back (rx bol "CoreAssembler> ") (line-beginning-position))
      (add-to-list '$compilation-stalled-buffers (current-buffer))
      (alert "Core Assembler stall"
             :severity 'moderate)))
  (byte-compile '$alert-core-assembler-stall)

  (defun $compilation-apply-ansi-color ()
    (defvar compilation-filter-start)
    (ansi-color-apply-on-region compilation-filter-start (point)))
  (byte-compile #'$compilation-apply-ansi-color)

  (add-hook 'compilation-finish-functions
            (defun $compilation-remove-stalled-buffer (buffer _exit)
              (setq $compilation-stalled-buffers (delete buffer $compilation-stalled-buffers))))

  (with-eval-after-load 'compile
    (add-to-list 'shackle-rules '(ipgen-mode :select t))
    (define-compilation-mode ipgen-mode "ipgen"
      "compilation mode for running IPGen tool"
      (general-add-hook 'compilation-filter-hook '($alert-core-assembler-stall $compilation-apply-ansi-color) nil 'local)))
#+END_SRC

we use helm as the dispatcher for ipgen because it allows to operate
on multiple candidates at once. This lets us run for all models or
only the models we choose.
#+BEGIN_SRC emacs-lisp
  (defun $run-ipgen-internal (dir &optional no-clean)
    (let* ((default-directory dir)
           (model-root (vc-git-root dir))
           (compilation-environment (list (concat "MODEL_ROOT=" model-root)
                                          "PATH=/usr/intel/bin:/usr/bin:/usr/sbin:/bin"
                                          "TAP_MARSHAL"
                                          "TAP2STF_MAP_FILE"
                                          "XWEAVE"
                                          "XWEAVE_REPO_ROOT"
                                          "TAP_SPFSPEC"
                                          "STF_SPFSPEC"
                                          "STF_MARSHAL"))
           (compilation-buffer-name-function
            (defun $ipgen-buffer-name-fn (mode)
              (format "*%s %s %s*"
                      (f-filename model-root)
                      (downcase mode)
                      (f-filename dir)))))
      ($compilation-start (concat "source setup && env && "
                                  (unless no-clean "$DFT_REPO_ROOT/DFTNetworkGen/run_dft_ipgen clean && ")
                                  "$DFT_REPO_ROOT/DFTNetworkGen/run_dft_ipgen")
                          'ipgen-mode)))

  (defun $helm-get-ipgen-data ()
    (let* ((model-root (vc-git-root default-directory))
           (ipgen (f-join model-root "tools/ipgen/"))
           (duts (f--directories ipgen (let ((setup (f-join it "setup")))
                                         (and (file-exists-p setup)
                                              (not (file-symlink-p setup)))))))
      (--map (cons (f-filename it) it) duts)))

  (defun $helm-ipgen-action (_)
    (--each (helm-marked-candidates) ($run-ipgen-internal it helm-current-prefix-arg)))

  (defun $run-ipgen ()
    "run dft ipgen in the current model"
    (interactive)
    (helm
     :buffer "*Run IPGen*"
     :sources (helm-build-sync-source
                  "select ipgen models: "
                :fuzzy-match t
                :candidates ($helm-get-ipgen-data)
                :action '(("run ipgen (C-u to run without clean)" . $helm-ipgen-action)))))

  ($leader-set-key
    "oi" '$run-ipgen)
#+END_SRC

**** bman
run the bman command based on a dispatcher. At some point I would like
to make this dynamic so that it could detect all stages and detect
what models can be run. For now I have a "generic" stage that lets me
run any command
#+BEGIN_SRC emacs-lisp
  (defhydra bman-cmd (:exit t :columns 2)
    "run a bman command"
    ("a" ($run-bman "" t) "all")
    ("A" ($run-bman "+s sgcdc" t) "extra")
    ("l" ($run-bman "-s all +s lintra") "lintra")
    ("v" ($run-bman "-s all +s vcs") "vcs")
    ("e" ($run-bman "-s all +s espfmodel") "espf")
    ("c" ($run-bman "-s all +s collage") "collage")
    ("s" ($run-bman "-s all +s sgdft") "SG DFT")
    ("d" ($run-bman "-s all +s sgcdc") "SG CDC")
    ("r" ($run-bman "-s emu -s sgdft -s sglp -s sglp_legacy -s lintra_ol -s FLG -s hip_listgen -s lintra" t) "RTL only")
    ("g" ($run-bman (read-string "run bman as: ")) "generic"))
#+END_SRC

there are very few errors that show up in bman, but we need a special
handler function to find the right log as the full path is not
availible
#+BEGIN_SRC emacs-lisp
  (defun $find-generic-bman-log ()
    (car (file-expand-wildcards (format "target/log/*.%s.log"
                                        (match-string-no-properties 1)))))

  (defvar bman-error-regexp-alist
    `((,(err-rx ^ "-" (or "E" "I") "-:" (opt spc) "FAILED:" -> (or ";" ":") " LOG " (opt ": ") filename)
       1)
      (,(err-rx ^ "-E-:FAILED" spc+ fp spc+ fp "  " filename)
       $find-generic-bman-log)
      (,(err-rx ^ "-I-:DIE signal: " (1+ nonl) " (in " filename ")")
       1)
      (,(err-rx ^ "-I-:DIE signal: \n-I-:" (1+ nonl) " at " filename)))
    "Regex for errors encountered in bman runs")
#+END_SRC

use these function to get the cluster and therefore the model needed. At
some point I would like to make this automatic by inspection.
#+BEGIN_SRC emacs-lisp
  (defvar $model-cluster-alist '(("mdf" . "mdf_10nm")
                                 ("mem" "mem" "mcddr")))

  (defun $get-cluster ()
    (string-trim-right (shell-command-to-string "git config intel.cluster")))

  (defun $get-model-arguments ()
    "get the command line arguments for the model portion of this build"
    (let ((model (alist-get ($get-cluster) $model-cluster-alist nil nil 'equal)))
      (if (listp model)
          (format " -dut %s -mc %s " (first model) (second model))
        (format " -dut %s " model))))
#+END_SRC

define a custom compliation mode that is run based on the hydra above
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'compile
    (add-to-list 'shackle-rules '(bman-mode :select t))
    (define-compilation-mode bman-mode "bman"
      "compilation mode for bman runs"))

  (defun $run-bman (filter &optional clean)
    "run dft ipgen in the current model"
    (let* ((model-root (file-truename (vc-git-root default-directory)))
           (compilation-environment (list (concat "MODEL_ROOT=" model-root)))
           (default-directory model-root)
           (compilation-buffer-name-function
            (lambda (_mode)
              (format "*%s bman*"
                      (f-filename model-root)))))
      (when (or current-prefix-arg clean)
        ($async-delete-file "target"))
      ($compilation-start (concat "source /p/hdk/rtl/hdk.rc -cfg shdk74 && bman" ($get-model-arguments) filter)
                          'bman-mode)))

  ($leader-set-key
    "ob" 'bman-cmd/body)
#+END_SRC

**** turnin
run a turnin command
#+BEGIN_SRC emacs-lisp
  (defun $find-latest-gk-log ()
    "this will stop working in the year 3000. Built-in
  obsolescence"
    (first (sort (file-expand-wildcards "GATEKEEPER/turnin.2*.log") 'string>)))

  (defvar turnin-error-regexp-alist
    `((,(err-rx ^ "  Turnin privileges denied on the following files:\n" spc+ filename)
       1)
      (,(err-rx ^ "%E-pre_turnin_script: Command Failed (Exit = " nums "):")
       $find-latest-gk-log)
      (,(err-rx ^ "%E-toolconfig_qc.pl:    ERROR:" (1+ nonl) " at " filename " line " line)
       1))
    "Regex for errors encountered during turnin")
#+END_SRC

a custom compilation command for running a turnin
#+BEGIN_SRC emacs-lisp
  (define-compilation-mode turnin-mode "turnin"
    "compilation mode for turnins")

  (defun $run-turnin ()
    "run a turnin command"
    (interactive)
    (let* ((model-root (file-truename (vc-git-root default-directory)))
           (compilation-environment (list (concat "MODEL_ROOT=" model-root)))
           (mock (y-or-n-p "Run as Mock? "))
           (clone (when mock (y-or-n-p "Clone ToT? ")))
           (eco (when (and (not mock)
                           (y-or-n-p "bug fix? "))
                  (read-string "Bug or ECO number(s): ")))
           (comment (unless mock
                      (read-string "turnin comment: ")))
           (compilation-buffer-name-function
            (lambda (major-mode)
              (format "*%s %s%s*"
                      (f-filename model-root)
                      (if mock "mock " "")
                      (downcase major-mode)))))
      ($compilation-start (concat "source /p/hdk/rtl/hdk.rc -cfg shdk74 && turnin -c "
                                  ($get-cluster)
                                  " -s srvr10nm"
                                  (when mock " -mock")
                                  (when (and mock (not clone)) " -no_clone")
                                  (when eco (concat " -bugecos '" eco "'"))
                                  (when comment (concat " -comments \"" comment "\"")))
                          'turnin-mode)))

  ($leader-set-key
    "o" '(:ignore t :wk "compile")
    "ot" '$run-turnin)
#+END_SRC
*** utility

**** enviroment
we are doing two things here to make compliation more convient

1. we want to compile with tcsh because that is the standard login shell
for EC machines and some of the compilation setup scripts require it,
we could make it work with bash, but this is easier.

2. by setting the compliation root, we can ensure that we are only
prompted to save buffers that actaully exist in the project instead of
it trying prompt us to save all buffers.
#+BEGIN_SRC emacs-lisp
  (defun $compile-with-tcsh (fn &rest args)
    "use tcsh (standard intel shell) for compilation"
    (let ((shell-file-name "tcsh"))
      (apply fn args)))

  (defvar $current-compilation-dir nil
    "root of current compliation")

  (defun $set-compilation-dir (&rest _)
    "set the root of the current compilation"
    (setq $current-compilation-dir default-directory))

  (setq compilation-save-buffers-predicate
        (lambda ()
          (when-let ((root (vc-git-root (buffer-file-name)))
                     (comp-root (vc-git-root $current-compilation-dir)))
            (and (not (string-match-p (rx ".log" eos) (buffer-file-name)))
                 (f-same? comp-root root)))))

  (with-eval-after-load 'compile
    (advice-add 'compilation-start :around #'$compile-with-tcsh)
    (advice-add 'compilation-start :before #'$set-compilation-dir))
#+END_SRC

**** timestamps
it is often useful to know how long a command runs, but compilation
mode only gives us the end time normally. These functions will print
the timestamp in the compilation buffer.
#+BEGIN_SRC emacs-lisp
  (defvar $compilation-start-time nil)
  (make-variable-buffer-local '$compilation-start-time)

  (with-eval-after-load 'compile
    (advice-add 'compilation-start :after
                (defun $compilation-set-start-time (&rest _)
                  (with-current-buffer compilation-last-buffer
                    (setq-local $compilation-start-time (current-time))))))

  (add-hook 'compilation-finish-functions
            (defun $compilation-print-run-time (buffer _msg)
              (with-current-buffer buffer
                (save-excursion
                  (goto-char (point-max))
                  (insert (format " --- Total run time: %s ---\n"
                                  ($time-difference-to-string
                                   (current-time) $compilation-start-time)))))))

  (cl-defun $time-difference-to-string (time1 time2)
    "take the difference between two time stamps and print it"
    (let* ((names '("day" "hour" "minute" "second"))
           (decode (reverse (-take 4 (decode-time (time-subtract time1 time2) "UTC0"))))
           ;; units is the alist of (value . name) pairs. e.g. (1 . day) (4 . hour) etc.
           ;; since days starts at 1 (instead of 0) we subtract 1 from the first element
           (units (-zip-pair (cons (1- (car decode)) (cdr decode))
                             names)))
      (while units
        ;; When we find the first non-zero unit we print it as well as
        ;; the following unit.
        (when-let ((formatted ($format-time-unit (pop units))))
          (cl-return-from $time-difference-to-string
            (s-join ", " (remove nil (list formatted ($format-time-unit (pop units))))))))))

  (defun $format-time-unit (unit)
    "return formatted time string if unit is not 0"
    (when (and unit
               (> (car unit) 0))
      (let ((value (car unit))
            (name (cdr unit)))
        (format "%d %s%s" value name (if (>= value 1) "s" "")))))
#+END_SRC

**** chaining
A series of functions for chaining together compliation that are going
to require previous steps. It checks to see if the new compilation is
using the same root as a current complilation. If that is the case it,
it blocks until the current one is done.

#+BEGIN_SRC emacs-lisp
  (defun $command-requires-blocking (mode)
    "return non-nil if compilations are being run using the current
  root"
    (cl-some (lambda (proc)
               (let ((buffer (process-buffer proc)))
                 (and (process-live-p proc)
                      (not (eq mode (with-current-buffer buffer major-mode)))
                      ($same-root default-directory buffer))))
             compilation-in-progress))

  (defun $same-root (buffer1 buffer2)
    (apply 'file-equal-p
           (--map (vc-git-root (if (bufferp it)
                                   (with-current-buffer it default-directory)
                                 it))
                  (list buffer1 buffer2))))

  (defvar $compilation-command-queue nil
    "compilation commands that are queued to be run once their
    dependaceies have finished")

  (defvar $compilation-dynamic-closures '(compilation-buffer-name-function
                                          compilation-environment
                                          default-directory))

  (defun $compilation-start (command mode &rest args)
    "start compilation if there are not other compliations running
    in the same root. If there are, defer till those compilations
    complete successfully"
    (if ($command-requires-blocking mode)
        (add-to-list '$compilation-command-queue
                     (list (mapcar (lambda (var)
                                     (list var `',(symbol-value var)))
                                   $compilation-dynamic-closures)
                           command mode args))
      (apply 'compilation-start command mode args)))

  ;; I need to make this smarter so that is will only launch when the
  ;; command it was waiting on has completed successfully
  (add-hook 'compilation-finish-functions
            (defun $compilation-pop-command-queue (buffer exit-string)
              (setq $compilation-command-queue
                    (cl-loop for (closure command mode args) in $compilation-command-queue
                             unless (eval `(let ,closure
                                             (if (and (string-prefix-p "exited abnormally" exit-string)
                                                      ($same-root default-directory buffer))
                                                 ;; if we return t, we will
                                                 ;; not collect this command,
                                                 ;; essenstially removing for
                                                 ;; the queue
                                                 t
                                               (unless ($command-requires-blocking mode)
                                                 (apply 'compilation-start command mode args))))
                                          (cadr #'(lambda)))
                             collect (list closure command mode args)))))
#+END_SRC

*** status
set of functions to show the status of all compilations, whether
finished or running, and easily jump to the associated buffer.
#+BEGIN_SRC emacs-lisp
  (defvar $compilation-finished-buffers nil
    "buffers that have finished compilation")

  (add-hook 'compilation-finish-functions
            (defun $compilation-add-buffer (buffer msg)
              (push (cons buffer (replace-regexp-in-string "\n" "" msg))
                    $compilation-finished-buffers)))

  (defun $compilation-buffers-candidates ()
    (setq $compilation-finished-buffers (seq-uniq $compilation-finished-buffers (lambda (x y) (eq (car x) (car y)))))
    ;; remove dead processes and buffers. If I kill buffers with helm
    ;; but they were still running then they will never get updated. So
    ;; we check for that at the start of every status.
    (setq compilation-in-progress (cl-remove-if-not (lambda (proc)
                                                      (let ((buf (process-buffer proc)))
                                                        (and (buffer-live-p buf)
                                                             (process-live-p proc))))
                                                    compilation-in-progress))
    (let* ((finished-buffers (cl-remove-if (-lambda ((buffer))
                                             (or (not (buffer-live-p buffer))
                                                 (memq (get-buffer-process buffer) compilation-in-progress)))
                                           $compilation-finished-buffers))
           (stalled-procs (cl-remove-if-not (lambda (proc)
                                              (memq (process-buffer proc) $compilation-stalled-buffers))
                                            compilation-in-progress))
           (running-procs (cl-remove-if (lambda (proc)
                                          (memq (process-buffer proc) $compilation-stalled-buffers))
                                        compilation-in-progress))
           (waiting-buffers (mapcar  (lambda (command)
                                       (get-buffer-create (let ((env (car command))
                                                                (mode (string-remove-suffix "-mode" (symbol-name (caddr command)))))
                                                            (eval `(let ,env
                                                                     (if compilation-buffer-name-function
                                                                         (funcall compilation-buffer-name-function ,mode)
                                                                       "*generic compilation placeholder*"))))))
                                     $compilation-command-queue))
           (formatted-stalled-buffers (--map (let ((buffer (process-buffer it)))
                                               (cons (format "%-50s%s"
                                                             buffer
                                                             (propertize "stalled" 'face 'compilation-warning))
                                                     buffer))
                                             stalled-procs))
           (formatted-running-buffers (--map (let ((buffer (process-buffer it)))
                                               (cons (format "%-50s%s"
                                                             buffer
                                                             (propertize "running" 'face 'compilation-line-number))
                                                     buffer))
                                             running-procs))
           (formatted-finished-buffers (mapcar (-lambda ((buffer . msg))
                                                 (cons (format "%-50s%s"
                                                               buffer
                                                               (propertize msg
                                                                           'face
                                                                           (if (string-prefix-p "exited abnormally" msg)
                                                                               'compilation-error
                                                                             'compilation-info)))
                                                       buffer))
                                               finished-buffers))
           (formatted-waiting-buffers (mapcar (lambda (buffer)
                                                (cons (format "%-50s%s"
                                                              buffer
                                                              (propertize "waiting" 'face 'term-color-cyan))
                                                      buffer))
                                              waiting-buffers))
           )
      (append formatted-stalled-buffers formatted-finished-buffers formatted-running-buffers formatted-waiting-buffers)))


  (defun $compilation-jump-to-buffer ()
    "select from active and finished compilation buffers"
    (interactive)
    (helm
     :buffer "*Helm compilation buffers*"
     :prompt "jump to compilation buffer: "
     :sources (helm-build-sync-source
                  "compilation buffers"
                :candidates ($compilation-buffers-candidates)
                :action helm-type-buffer-actions)))

  ($leader-set-key
    "oj" '$compilation-jump-to-buffer)
#+END_SRC

*** alert
the alert package lets us creat notification for any event we want. In
this case we are intersted in knowing when a compliation finishes or
stalls.
#+BEGIN_SRC emacs-lisp
  (use-package alert
    :init
    (setq alert-default-style 'fringe))

  (add-hook 'compilation-filter-hook
            (defun $complilation-detect-core-assembler-stall ()
              "termiate compilation when core assembler stalls"
              (when (looking-back (rx bol "CoreAssembler> ") (line-beginning-position))
                (alert "Core Assembler stall"
                       :severity 'moderate))))

  (byte-compile #'$complilation-detect-core-assembler-stall)

  (add-hook 'compilation-finish-functions
            (defun $notify-compile-done (_buffer exit-string)
              "notfiy the user that compliation is finished"
              (alert "compliation finished"
                     :severity (if (string-prefix-p "exited abnormally" exit-string)
                                   'high
                                 'normal))))

  (defun $clear-alert ()
    "clear persistent alert"
    (interactive)
    (alert ""))

  ($leader-set-key
    "oa" '$clear-alert)
#+END_SRC

*** readability
some basic font lock to make compilation and log buffers easier to
read. We want to see labels and delimiters very quick so we can tell
what part of a buffer we are in
#+BEGIN_SRC emacs-lisp

  (define-arx log-rx
    (append $rx-defaults
            '((I (: bol (opt "-I-")))
              (I: (: bol (opt "-I-:"))))))

  (defvar $compilation-font-lock-keywords
    `((,(log-rx I: spc* (group (in "#*") (in " \t#*=") ->) eol)
       1 'compilation-line-number)
      (,(log-rx I: spc* (group (repeat 4 "=") ->) eol)
       1 'compilation-line-number)
      (,(log-rx I spc* (group (repeat 3 "-") ->) eol)
       1 'compilation-line-number)
      (,(log-rx I (opt ":")  (group (not (in "-")) (1+ (in alnum " \t_-"))) ": ")
       1 'font-lock-function-name-face)
      (,(log-rx bol (group "-I-"))
       1 'compilation-info prepend)
      (,(log-rx I: (group (or "-I-" "Note-" "NOTE" "OVM_INFO")))
       1 'compilation-info prepend)
      (,(log-rx I: (group (or "-E-" "-F-" "Error-" "Fatal-" "OVM_ERROR" "ERROR" "FATAL" "OVM_FATAL")))
       1 'compilation-error prepend)
      (,(log-rx I: (group (or "-W-" "Warning-" "WARNING" "OVM_WARNING")))
       1 'compilation-warning prepend)))

  (with-eval-after-load 'compile
    (font-lock-add-keywords 'compilation-mode $compilation-font-lock-keywords))
  (with-eval-after-load 'log-mode
    (font-lock-add-keywords 'log-mode $compilation-font-lock-keywords))
#+END_SRC

* Org
** todos and general
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight nil
    :gfhook org-indent-mode $org-truncate-lines
    :init
    ($leader-local-set-key
      :keymaps 'org-mode-map
      "," 'org-edit-special
      "g" '$org-navigate/body)
    ($leader-set-key
      "ol" 'org-store-link)
    (setq org-lowest-priority ?D
          org-enforce-todo-dependencies t
          org-todo-keywords '((sequence "TODO(t)" "BLOCK(b@!)" "DOING(g)" "|" "DONE(d)")
                              (sequence "|" "CANCELED(c@)"))
          org-priority-faces '((?A . (:foreground "OrangeRed"))
                               (?B . (:foreground "yellow3"))
                               (?C . (:foreground "ForestGreen"))))
    (defun $org-truncate-lines ()
      (let ((inhibit-message t))
        (toggle-truncate-lines)))
    :config

    (general-advice-add '(org-insert-subheading org-insert-todo-subheading)
                        :before
                        (defun $org-insert-subheading (ARG)
                          (let ((undo-inhibit-record-point t))
                            (end-of-line))))
    (general-define-key
     :keymaps 'org-mode-map
     "C-c C-<return>" 'org-insert-subheading
     "C-c C-SPC" 'org-insert-todo-subheading)
    (add-to-list 'org-structure-template-alist
                 '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "")))
#+END_SRC

*** inherit priority
inherit the priority of the parent heading
#+BEGIN_SRC emacs-lisp
  (defun $org-insert-header-priority (_arg &optional force)
    (when (org-at-heading-p)
      (let ((parent-priority (save-excursion (if force
                                                 (org-up-heading-safe)
                                               (org-backward-heading-same-level 1))
                                             (org-show-priority))))
        (cl-loop do (org-priority (if (string< (org-show-priority) parent-priority) 'up 'down))
                 until (equal parent-priority (org-show-priority))))))

  (advice-add 'org-insert-todo-heading :after '$org-insert-header-priority)
#+END_SRC

** navigation
#+BEGIN_SRC emacs-lisp
  (defhydra $org-navigate ()
    "navigate through org headers"
    ("J" org-next-visible-heading "next heading")
    ("K" org-previous-visible-heading "prev heading")
    ("j" org-forward-element "foward")
    ("k" org-backward-element "back")
    ("h" org-up-element "up")
    ("l" org-down-element "down")
    ("q" nil)
    ("<tab>" org-cycle "cycle"))

  (defun $org-smart-forward-element ()
    "if heading is not folded go down into it first."
    (interactive)
    (let ((element (org-element-at-point)))
      (if (and (org-at-heading-or-item-p)
               (not (org-invisible-p (line-end-position)))
               (org-element-property :contents-begin element)
               (memq (org-element-type element)
                     (append '(plain-list table) org-element-greater-elements)))
          (org-down-element)
        (org-forward-element))))

  (general-define-key
   :keymaps 'org-mode-map
   "C-j" '$org-smart-forward-element
   "C-k" 'org-backward-element
   "C-l" 'org-down-element)
#+END_SRC

** functions
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight nil
    :config
    (defun $org-show-current-heading-tidily ()
      "Show next entry, keeping other entries closed."
      (interactive)
      (if (save-excursion (end-of-line) (outline-invisible-p))
          (progn (org-show-entry) (outline-show-children))
        (outline-back-to-heading)
        (unless (and (bolp) (org-at-heading-p))
          (org-up-heading-safe)
          (outline-hide-subtree)
          (error "Boundary reached"))
        (org-overview)
        (org-reveal t)
        (org-show-entry)
        (outline-show-children)))
    (advice-add 'counsel-org-goto :after '$org-show-current-heading-tidily)

    (defun $org-archive-done-tasks ()
      "move tasks that are completed to the archive file."
      (interactive)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
       "/DONE" 'file)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
       "/CANCELED" 'file))

    ($leader-local-set-key
      :keymaps 'org-mode-map
      "a" '$org-archive-done-tasks
      "h" '$org-show-current-heading-tidily)

    (defun $org-smart-return ()
      "if in a list return should add a new item. If the item is
  blank, we want to break out of the list and delete the blank
  item"
      (interactive)
      (if (org-at-item-p)
          (if (and (looking-back (rx space) (- (point) 1))
                   (memq (- (point) (org-in-item-p))
                         (number-sequence 1 3)))
              ;; If at a blank item, delete it
              (progn
                (beginning-of-line)
                (kill-line)
                (insert "\n")
                (org-return))
            ;; If at a non-blank item, insert a new item
            (org-return)
            (org-insert-item))
        ;; If not at item, normal return
        (org-return)))
    (general-define-key
     :keymaps 'org-mode-map
     "<ret>" '$org-smart-return
     "RET" '$org-smart-return)

    (defun $org-procrastinate (arg)
      "shedule the selected item for tomrrow, effectivly removing
  it from todays agenda."
      (interactive "P")
      (let ((fn (if (eq major-mode 'org-agenda-mode)
                    'org-agenda-schedule
                  'org-schedule)))
        (defvar org-state)
        (let ((org-state "DONE"))
          (require 'org-clock)
          (org-clock-out-if-current))
        (funcall fn arg "+1d")))
    ($leader-local-set-key
      :keymaps '(org-mode-map org-agenda-mode-map)
      "s" '$org-procrastinate))
#+END_SRC

** agenda
#+BEGIN_SRC emacs-lisp
  (csetq org-agenda-todo-ignore-scheduled 'future
         org-agenda-tags-todo-honor-ignore-options t
         org-agenda-dim-blocked-tasks 'invisible
         org-agenda-files "~/org/.agenda-files"
         org-agenda-custom-commands '(("f" "full" tags-todo "mdf-pvim|snr|gen|mem")
                                      ("d" "development" tags-todo "dev")
                                      ("p" "pvim" tags-todo "pvim+now|next|past")
                                      ("m" "mdf" tags-todo "mdf")
                                      ("u" "turnin" tags-todo "turnin")))
  ($leader-set-key
    "a" 'org-agenda)
#+END_SRC

** refile
this allows me to quickly move headers around files based on these
refile targets. we enable caching because we do not expect these files
to change outside of Emacs.
#+BEGIN_SRC emacs-lisp
  (csetq org-refile-use-cache t
         org-refile-targets '((nil :maxlevel . 2)
                              ("~/org/integration.org" :maxlevel . 2)
                              ("~/org/validation.org" :maxlevel . 2)
                              ("~/org/projects/mdf.org" :maxlevel . 2)
                              ("~/org/projects/mdf_pvim.org" :maxlevel . 3)
                              ("~/org/projects/snr/snr_scan.org" :maxlevel . 2)
                              ("~/org/meeting-notes/mdf_meet.org" :maxlevel . 2)
                              ("~/org/meeting-notes/integ_meet.org" :maxlevel . 2)
                              ("~/org/dev/development.org" :maxlevel . 1)))
#+END_SRC

since I am using helm, it makes the most sense to show the whole
outline path instead of trying to refile in steps.
#+BEGIN_SRC emacs-lisp
  (csetq org-refile-use-outline-path 'file
         org-outline-path-complete-in-steps nil)
#+END_SRC

** clock
#+BEGIN_SRC emacs-lisp
  (use-package org-clock
    :straight nil
    :init
    ($leader-set-key
      "og" 'org-clock-goto
      "oo" 'org-clock-out)
    ($leader-local-set-key
      :keymaps 'org-mode-map
      "i" 'org-clock-in
      "o" 'org-clock-out)
    ($leader-local-set-key
      :keymaps 'org-agenda-mode-map
      "i" 'org-agenda-clock-in
      "o" 'org-agenda-clock-out))
#+END_SRC

** export
org has the awesome functionality to export org markup to HTML. My
most common use case is to write an email in an org capture buffer and
then export that to HTML and insert it into outlook. Therefore we are
going to set our defaults based on that use case. For other exports we
are going to have to override these variables explicitly

don't add section numbers
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-section-numbers nil)
#+END_SRC

don't add a table of contents
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-toc nil)
#+END_SRC

only make something a subscript if we had braces around
it. i.e. make 5_{4} a subscript but not 5_4. Otherwise we end up
with subscripts anytime we don't markup a variable name.
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-sub-superscripts '{})
#+END_SRC

include a priority element when exporting todos
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-priority t)
#+END_SRC

preserve line breaks when exporting. This makes the exported format
closer to my markup, which keeps unwated suprises
#+BEGIN_SRC emacs-lisp
  (setq org-export-preserve-breaks t)
#+END_SRC

don't use the default preamble. We are creating our own css preamble
and we don't want the default one interfering
#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

I program on a dark background because I am not heathen. But this
means that when we use the default inline CSS for syntax highlighting
we get really hard to read colors on a white background like email. So
instead org will just define css elements for the different syntax
elements and our =email.css= can define the colors for those. that way
we always have good colors for reading on white background regardless
of our theme.
#+BEGIN_SRC emacs-lisp
  (setq org-html-htmlize-output-type 'css)
#+END_SRC

create a custom HTML preamble that includes our default CSS to make
things more clean and modern. load it after the export libraries are
loaded so it does not effect startup time.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'ox-html
    (setq org-html-head
          (concat
           "<style type=\"text/css\">\n"
           "<!--/*--><![CDATA[/*><!--*/\n"
           (with-temp-buffer
             (insert-file-contents
              "~/org/org-html-themes/styles/email/css/email.css")
             (buffer-string))
           "/*]]>*/-->\n"
           "</style>\n")))
#+END_SRC

A simple function to export the current buffer as HTML and put it in
the clipboard
#+BEGIN_SRC emacs-lisp
  (defun $org-export-buffer ()
    "Export the current org email and copy it to the clipboard"
    (interactive)
    (defvar org-export-show-temporary-export-buffer)
    (let (org-export-show-temporary-export-buffer)
      (org-html-export-as-html)
      (with-current-buffer "*Org HTML Export*"
        (kill-new (buffer-string)))
      (message "HTML copied to clipboard")))

  (defun $export-code-region (beg end)
    "Export the current region as formatted HTML"
    (interactive "r")
    (let ((region (buffer-substring-no-properties beg end))
          (mode (string-remove-suffix "-mode" (symbol-name major-mode))))
      (with-temp-buffer
        (insert "#+BEGIN_SRC " mode "\n")
        (insert region "\n")
        (insert "#+END_SRC\n")
        ($org-export-buffer))))

  ($leader-set-key
    "xe" '$export-code-region)
#+END_SRC

The built-in version of =htmlize= does not support exporting code
blocks
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

** capture
#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :straight nil
    :init
    ($leader-set-key
      "c" 'org-capture)
    ($leader-local-set-key
      :definer 'minor-mode
      :keymaps 'org-capture-mode
      "e" '$org-export-buffer)
    :config
    (setq org-default-notes-file (expand-file-name "notes.org" org-directory)
          org-default-todo-file (expand-file-name "todo.org" org-directory)
          org-default-email-file (expand-file-name "email.org" org-directory)
          org-default-journal-file (expand-file-name "journal.org" org-directory)
          org-capture-templates
          '(("t" "Todo" entry (file org-default-todo-file)
             "* TODO [#C] %?\n %t\n" :empty-lines 1)
            ("l" "Todo Link" entry (file org-default-todo-file)
             "* TODO [#C] %?\n %i\n %a" :empty-lines 1)
            ("s" "Scheduled TODO" entry (file org-default-todo-file)
             "* TODO [#C] %?\n  SCHEDULED: %^T\n" :empty-lines 1)
            ("T" "Todo from Clipboard" entry (file org-default-todo-file)
             "* TODO [#C] %?\n  %c" :empty-lines 1)
            ("n" "Note" entry (file org-default-notes-file)
             "* %?" :empty-lines 1)
            ("N" "Note with Clipboard" entry (file org-default-notes-file)
             "* %?\n   %c" :empty-lines 1)
            ("e" "Email" entry (file org-default-email-file)
             "* %?" :empty-lines 1)
            ("j" "Journal" entry (file org-default-journal-file)
             "* %<%a %b %e, %l:%M> -  %?" :empty-lines 1))))
#+END_SRC

** tags
#+BEGIN_SRC emacs-lisp
  (csetq org-tags-column 0)

  (csetq org-tag-alist
         '(("mdf"  . ?m)
           ("mem"  . ?e)
           ("snr"  . ?s)
           ("dev"  . ?d)
           ("int"  . ?i)
           ("val"  . ?v)
           ("gen"  . ?g)
           ("hsd"  . ?h)
           ("info" . ?f)
           ("hai"  . ?a)
           ("turnin" . ?t)))
#+END_SRC

** links
there is no good function to copy a link in org mode, so we override
the default open link behavior
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-open-at-point-functions
            (defun $org-copy-url ()
              "in my current setup, the builtin browswer does not
  work, so I copy links and paste them into chrome."
              (let ((context (org-element-context)))
                (when (member (org-element-property :type context)
                              '("http" "https"))
                  (message "copied org link: %s"
                           (kill-new (org-element-property :raw-link context)))))))
#+END_SRC

** src blocks
#+BEGIN_SRC emacs-lisp
  (use-package org-src
    :straight nil
    :gfhook #'$org-src-lexical-bindings
    :general
    (:keymaps 'org-src-mode-map
              "C-c C-c" 'org-edit-src-exit)
    :init
    (csetq org-src-fontify-natively t
           org-src-window-setup 'current-window
           org-src-tab-acts-natively t)
    (defun $org-src-lexical-bindings ()
      (setq-local lexical-binding t)))
#+END_SRC

=C-c C-C= is more useful to edit src code blocks then to eval them
#+BEGIN_SRC emacs-lisp
  (defun $org-ctrl-c-ctrl-c (&optional arg)
    (interactive "P")
    (if (eq 'src-block (org-element-type (org-element-at-point)))
        (org-edit-src-code)
      (org-ctrl-c-ctrl-c arg)))

  (general-define-key
   :keymaps 'org-mode-map
   "C-c C-c" '$org-ctrl-c-ctrl-c)
#+END_SRC

** evil
#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :hook org-mode
    :init (add-hook 'org-insert-heading-hook 'evil-insert-state))

  (use-package evil-org-agenda
    :straight nil
    :commands evil-org-agenda-set-keys
    :hook (org-agenda-mode . evil-org-agenda-set-keys))

  (defun $org-todo-or-evil-t ()
    "change the org todo state or evil's till operator"
    (interactive)
    (if (org-at-heading-p)
        (org-todo)
      (evilem-motion-find-char-to)))

  (general-define-key
   :keymaps 'org-mode-map
   :states 'normal
   "t" '$org-todo-or-evil-t)
#+END_SRC

** visuals
These packages are used to make org mode look better and take
advantage of unicode
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook org-mode)

  (use-package org-fancy-priorities
    :diminish
    :hook org-mode
    :init
    (setq org-fancy-priorities-list '("⬆" "⬅" "⬇" "☕")))
#+END_SRC

* Languages
:PROPERTIES:
:VISIBILITY: children
:END:
** General

make scripts executable on save
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :init
    ($leader-set-key
      "tf" 'flycheck-mode))
#+END_SRC

*** company
I don't want to use return for completion because that often
interferces with just regular typing. So i have gotten in the habit of
just using =C-l=
#+BEGIN_SRC emacs-lisp
  (use-package company
    :general
    (:keymaps 'company-active-map
              "RET" nil
              [return] nil
              "C-l" 'company-complete-selection)
    :hook '(prog-mode org-mode ielm-mode)
    :init
    (setq company-idle-delay 0.2
          evil-collection-company-use-tng nil
          company-require-match nil)
    (evil-collection-init 'company)
    ($leader-set-key
      "tc" 'company-mode)
    :config
    (defun $company-select-prev-or-comint-match-input (&optional _)
      (when (and (eq major-mode 'shell-mode)
                 (eq company-selection 0))
        (company-abort)
        (call-interactively 'comint-previous-matching-input-from-input)))
    (advice-add 'company-select-previous :before-until #'$company-select-prev-or-comint-match-input))

  (with-eval-after-load 'company-dabbrev-code
    (add-to-list 'company-dabbrev-code-modes 'shell-mode))


  (use-package company-shell
    :after company)
#+END_SRC

collect usage statistics and filter candidates based on that

#+BEGIN_SRC emacs-lisp
  (use-package company-statistics
    :demand t
    :after company
    :config
    (company-statistics-mode))
#+END_SRC

helm company provides a helm interface to helm completion
#+BEGIN_SRC emacs-lisp
  (use-package helm-company
    :init
    :general
    (:keymaps '(company-mode-map company-active-map)
              "C-/" 'helm-company))
#+END_SRC

** elisp

*** general
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :straight nil
    :init
    ($leader-local-set-key
      :keymaps 'emacs-lisp-mode-map
      "ee" 'eval-last-sexp
      "eb" 'eval-buffer
      "er" 'eval-region
      "ef" 'eval-defun))
#+END_SRC

*** ielm
ielm is an emacs lisp repl. We are going to patch the function so that
it will split the current window instead of replacing it. See
[[https://github.com/wasamasa/shackle/issues/33][wasamasa/shackle#33]]
#+BEGIN_SRC emacs-lisp
  ($leader-local-set-key
    :keymaps 'emacs-lisp-mode-map
    "'" 'ielm)

  (add-to-list 'shackle-rules `("*ielm*" :custom ,($shacklize display-buffer-below-selected) :select t))

  (el-patch-feature 'ielm)
  (with-eval-after-load 'ielm
    (el-patch-defun ielm ()
      "Interactively evaluate Emacs Lisp expressions.
  Switches to the buffer `*ielm*', or creates it if it does not exist.
  See `inferior-emacs-lisp-mode' for details."
      (interactive)
      (let (old-point)
        (unless (comint-check-proc "*ielm*")
          (with-current-buffer (get-buffer-create "*ielm*")
            (unless (zerop (buffer-size)) (setq old-point (point)))
            (inferior-emacs-lisp-mode)))
        (el-patch-swap (pop-to-buffer-same-window "*ielm*")
                       (display-buffer  "*ielm*"))
        (when old-point (push-mark old-point)))))
#+END_SRC

*** prettify symbols
make things look a litle nicer. we have to "cycle"
=prettify-symbols-mode= because our prog-mode hook enables it and
therefore it won't process any changes to =prettify-symbols-alist=
unless we turn it back on.
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            (defun $prettify-cons ()
              (add-to-list 'prettify-symbols-alist '("lambda" . ?λ))
              (add-to-list 'prettify-symbols-alist '("." . ?•))
              (prettify-symbols-mode -1)
              (prettify-symbols-mode 1)
              (setq-local prettify-symbols-compose-predicate
                          (defun $prettify-symbols-handle-dot (start end match)
                            (if (equal "." match)
                                (prettify-symbols-default-compose-p start end match)
                              t)))))
#+END_SRC

*** page breaks
make page breaks easier to see
#+BEGIN_SRC emacs-lisp
  (use-package page-break-lines
    :hook (emacs-lisp-mode . page-break-lines-mode))
#+END_SRC

*** indent
never have to worry about tab indenting again.
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :hook emacs-lisp-mode)
#+END_SRC

*** extra font lock
let's you visually distinguish between let bound dynamic and lexical
variables. also shows interpolated parts of backquoted sexps.

#+BEGIN_SRC emacs-lisp
  (use-package lisp-extra-font-lock
    :hook emacs-lisp-mode
    :config
    (dolist (fn '("when-let" "when-let*" "if-let" "if-let*" "-let" "-let*"))
      (add-to-list 'lisp-extra-font-lock-let-functions fn)))
#+END_SRC

*** quick expand
using speed of though lisp to quicky create edit emacs-lisp
#+BEGIN_SRC emacs-lisp
  (use-package sotlisp
    :hook emacs-lisp-mode)
#+END_SRC

*** macro step
#+BEGIN_SRC emacs-lisp
  (use-package macrostep
    :init
    (defhydra macrostep (:exit nil :foreign-keys run)
      "expand macros one step at a time"
      ("e" macrostep-expand "expand")
      ("c" macrostep-collapse "collapse")
      ("n" macrostep-next-macro "next")
      ("N" macrostep-prev-macro "prev")
      ("q" macrostep-collapse-all "quit" :exit t))
    ($leader-local-set-key
      :keymaps 'emacs-lisp-mode-map
      "m" 'macrostep/body))
#+END_SRC

*** rainbow delimiters
packages to help manage parens
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook prog-mode)

  (use-package paren
    :straight nil
    :demand t
    :after prog-mode
    :init
    (csetq evil-show-paren-range 3
           show-paren-delay 0)
    (evil-collection-init 'paren)
    :config
    (show-paren-mode))
#+END_SRC

*** benchmarking
Some useful macros for profiling and benchmarking elisp code

#+BEGIN_SRC emacs-lisp
  (defmacro $profile (&rest body)
    "generate a CPU profile report for BODY"
    `(progn (profiler-start 'cpu)
            ,@body
            (profiler-report)
            (profiler-stop)
            (profiler-reset)))

  (defmacro measure-time (&rest body)
    "Measure the time it takes to evaluate BODY."
    `(let ((time (current-time)))
       ,@body
       (message "%.06f" (float-time (time-since time)))))

  (cl-defmacro bench (&optional (times 100000) &rest body)
    "Call `benchmark-run-compiled' on BODY with TIMES iterations, returning list suitable for Org source block evaluation.
    Garbage is collected before calling `benchmark-run-compiled' to
    avoid counting existing garbage which needs collection."
    (declare (indent defun))
    `(progn
       (garbage-collect)
       (list '("Total runtime" "# of GCs" "Total GC runtime")
             'hline
             (benchmark-run-compiled ,times
               (progn
                 ,@body)))))

  (cl-defmacro bench-multi (&key (times 1) forms ensure-equal)
    "Run FORMS with `benchmark-run-compiled' for TIMES iterations, returning list suitable for Org source block evaluation.

  When ENSURE-EQUAL is non-nil, compare the results of FORMS and
  ensure they are `equal'.  If they aren't, raise an error, and if
  the results are sequences, show the difference between them using
  `seq-difference'.

  If the first element of a form is a string, the string is used as
  the form's description in the results; otherwise, forms are
  numbered from 0.

  Before `benchmark-run-compiled' is called for each form,
  `garbage-collect' is called."
    (declare (indent defun))
    (let ((results (gensym))
          (result-times (gensym))
          (header '(("Form" "x faster than next" "Total runtime" "# of GCs" "Total GC runtime")
                    hline))
          (descriptions (cl-loop for form in forms
                                 for i from 0
                                 collect (if (stringp (car form))
                                             (prog1 (car form)
                                               (setf (nth i forms) (cadr (nth i forms))))
                                           i))))
      `(let* ((,results (make-hash-table))
              (,result-times (sort (list ,@(cl-loop for form in forms
                                                    for i from 0
                                                    for description = (nth i descriptions)
                                                    collect `(progn
                                                               (garbage-collect)
                                                               (cons ,description
                                                                     (benchmark-run-compiled ,times
                                                                       ,(if ensure-equal
                                                                            `(puthash ,description ,form ,results)
                                                                          form))))))
                                   (lambda (a b)
                                     (< (second a) (second b))))))
         ,(when ensure-equal
            `(cl-loop with keys = (hash-table-keys ,results)
                      for i from 0 to (- (length keys) 2)
                      unless (equal (gethash (nth i keys) ,results)
                                    (gethash (nth (1+ i) keys) ,results))
                      do (if (sequencep (gethash (car (hash-table-keys ,results)) ,results))
                             (let* ((k1) (k2)
                                    ;; If the difference in one order is nil, try in other order.
                                    (difference (or (setq k1 (nth i keys)
                                                          k2 (nth (1+ i) keys)
                                                          difference (seq-difference (gethash k1 ,results)
                                                                                     (gethash k2 ,results)))
                                                    (setq k1 (nth (1+ i) keys)
                                                          k2 (nth i keys)
                                                          difference (seq-difference (gethash k1 ,results)
                                                                                     (gethash k2 ,results))))))
                               (user-error "Forms' results not equal: difference (%s - %s): %S"
                                           k1 k2 difference))
                           ;; Not a sequence
                           (user-error "Forms' results not equal: %s:%S  %s:%S"
                                       (nth i keys) (nth (1+ i) keys)
                                       (gethash (nth i keys) ,results)
                                       (gethash (nth (1+ i) keys) ,results)))))
         ;; Add factors to times and return table
         (append ',header
                 (cl-loop with length = (length ,result-times)
                          for i from 0 to (1- length)
                          for time = (second (nth i ,result-times))
                          for description = (car (nth i ,result-times))
                          for factor = (if (< i (1- length))
                                           (format "%.2f" (/ (second (nth (1+ i) ,result-times))
                                                             (second (nth i ,result-times))))
                                         "slowest")
                          collect (append (list description factor)
                                          (cdr (nth i ,result-times))))))))

  (defmacro elp-profile (times prefixes &rest body)
    (declare (indent defun))
    `(let (output)
       (dolist (prefix ,prefixes)
         (elp-instrument-package (symbol-name prefix)))
       (dotimes (x ,times)
         ,@body)
       (elp-results)
       (elp-restore-all)
       (point-min)
       (forward-line 20)
       (delete-region (point) (point-max))
       (setq output (buffer-substring-no-properties (point-min) (point-max)))
       (kill-buffer)
       (delete-window)
       (let ((rows (s-lines output)))
         (append (list (list "Function" "Times called" "Total time" "Average time")
                       'hline)
                 (cl-loop for row in rows
                          collect (s-split (rx (1+ space)) row 'omit-nulls))))))
#+END_SRC

** perl
all the enviroment variables are set so as to make it easier for
flycheck to get a clean compile. We also change =:= to be a
punctuation character to match perl mode. This fixes a ligature issue.
#+BEGIN_SRC emacs-lisp
  (use-package cperl-mode
    :straight nil
    :init
    (setq
     ;; highlight all scalar variables not just the instantiation
     cperl-highlight-variables-indiscriminately t
     cperl-indent-level 4        ; 4 spaces is the standard indentation
     cperl-close-paren-offset -4 ; indent the closing paren back four spaces
     cperl-continued-statement-offset 4 ; if a statement continues indent it to four spaces
     cperl-indent-parens-as-block t)

    (setq flycheck-perl-executable "/usr/intel/pkgs/perl/5.14.1/bin/perl"
          flycheck-perl-perlcritic-executable "/usr/intel/pkgs/perl/5.14.1-threads/bin/perlcritic"
          flycheck-perl-include-path '("/p/hdk/cad/spf/latest/lib/perl5"
                                       "../lib/perl5"
                                       "../../lib/perl5"
                                       "..")) ;; library files need to see the library ¯\_(ツ)_/¯
    (setenv "SPF_ROOT" "/p/hdk/cad/spf/latest")
    (setenv "SPF_PERL_LIB" "/p/hdk/cad/spf/latest/lib/perl5")
    (setenv "XWEAVE_REPO_ROOT" "/p/hdk/rtl/ip_releases/shdk74/xweave/v17ww43a")
    (setenv "IDS_HOME" "/p/hdk/rtl/cad/x86-64_linux26/dteg/ideas_shell/0.15.1")
    :config
    (modify-syntax-entry ?: "." cperl-mode-syntax-table))
#+END_SRC

highlight variables in strings
#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'perl-mode
                          `((,(rx (group-n 1 "$" (opt "{")) (group-n 2 (1+ (any alnum "_"))) (group-n 3 (opt "}")))
                             (1 (when (not (nth 4 (syntax-ppss)))
                                  'default)
                                prepend)
                             (2 (when (not (nth 4 (syntax-ppss)))
                                  font-lock-variable-name-face)
                                prepend)
                             (3 (when (not (nth 4 (syntax-ppss)))
                                  'default)
                                prepend))))
#+END_SRC

prefer perl mode over cperl mode
#+BEGIN_SRC emacs-lisp
  (defalias 'cperl-mode 'perl-mode)
#+END_SRC

I use regular perl-mode for files that are considered read-only.
#+BEGIN_SRC emacs-lisp
  (use-package perl-mode
    :straight nil
    :mode (rx ".ip_info" eos)
    :mode (rx ".espflist" eos)
    :mode (rx ".udf" eos)
    :init
    (setq perl-indent-parens-as-block t
          perl-continued-brace-offset -4))
#+END_SRC

*** highlight escape sequences

#+BEGIN_SRC emacs-lisp
  (use-package highlight-escape-sequences
    :hook ((cperl-mode . hes-mode)
           (perl-mode . hes-mode))
    :config
    (add-to-list 'hes-mode-alist (cons 'perl-mode  hes-common-escape-sequence-re))
    (add-to-list 'hes-mode-alist (cons 'cperl-mode hes-common-escape-sequence-re)))
#+END_SRC


*** perltidy
perltidy is a perl foratting tool
#+BEGIN_SRC emacs-lisp
  (use-package perltidy
    :general
    (:definer
     'leader
     :keymaps '(perl-mode-map
                cperl-mode-map)
     "f" '(:ignore t :wk "format")
     "fr" 'perltidy-region
     "ff" 'perltidy-dwim-safe
     "fb" 'perltidy-buffer
     "fs" 'perltidy-subroutine))
#+END_SRC

*** ffap module
when using ffap expand modules to their source
#+BEGIN_SRC emacs-lisp
  (use-package ffap-perl-module
    :config
    (ffap-perl-module-unload-function))
#+END_SRC


** verilog
we have some nonstandard extensions for SV
#+BEGIN_SRC emacs-lisp
  (use-package verilog-mode
    :straight nil
    :mode (rx ".vs" eos)
    :mode (rx ".svh" eos)
    :mode (rx ".vf" eos)
    :mode (rx ".hier" eos))
#+END_SRC

** TCL
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist `(,(rx ".upf" eos) . tcl-mode))
#+END_SRC

** json
add hide-show support to json mode and make comments properly font
locked
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :gfhook 'flycheck-mode 'hs-minor-mode
    :init
    (setq flycheck-json-python-json-executable "python3.6.3")
    :config
    (add-to-list 'hs-special-modes-alist (list 'json-mode (rx (any "{[")) (rx (any "]}")) (rx "/" (any "/*"))))
    (font-lock-add-keywords 'json-mode
                            `((,(rx (group "//" (0+ nonl)) eol) 1 font-lock-comment-face))))
#+END_SRC

we are using the design_report.json as reference for our json coding
standard. This varies from the standard json Emacs json pretty printer in
the following ways:
- add a space before plist seperators
- use empty objects ={}= instead of =null=. null causes the json
  reader to choke
- indentation level is 4

#+BEGIN_SRC emacs-lisp
  (setq json-encoding-default-indentation "    ")

  (advice-add 'json-pretty-print :after
              (defun $json-convert-null-to-emtpy-obj (beg end)
                (save-excursion
                  (goto-char beg)
                  (while (re-search-forward (rx ": null") end 'noerror)
                    (replace-match ": {}")))))

  (el-patch-defun json-encode-alist (alist)
    "Return a JSON representation of ALIST."
    (when json-encoding-object-sort-predicate
      (setq alist
            (sort alist (lambda (a b)
                          (funcall json-encoding-object-sort-predicate
                                   (car a) (car b))))))
    (format "{%s%s}"
            (json-join
             (json--with-indentation
              (mapcar (lambda (cons)
                        (format (if json-encoding-pretty-print
                                    (el-patch-swap "%s%s: %s" "%s%s : %s")
                                  "%s%s:%s")
                                json--encoding-current-indentation
                                (json-encode-key (car cons))
                                (json-encode (cdr cons))))
                      alist))
             json-encoding-separator)
            (if (or (not json-encoding-pretty-print)
                    json-encoding-lisp-style-closings)
                ""
              json--encoding-current-indentation)))
#+END_SRC

** makefile
#+BEGIN_SRC emacs-lisp
  (add-to-list 'interpreter-mode-alist '("gmake" . makefile-gmake-mode))
#+END_SRC

** markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode)
#+END_SRC

** other
collection of major modes that I use for different file types.
#+BEGIN_SRC emacs-lisp
  (use-package major-modes
    :straight
    (major-modes
     :type git :host github :repo "CeleritasCelery/major-modes")
    :init
    ($leader-local-set-key
      :keymaps 'spfspec-mode-map
      "g" 'spfspec-goto-definition))
#+END_SRC

when I break out major-modes into different packages this should not
longer be necessary
#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :hook log-mode
    :config
    (setq highlight-numbers-generic-regexp
          ($rx (or (seq "0x" (1+ hex))
                   (seq "'" nums "'")
                   (seq (or bol spc ":")
                        (or (seq nums (any "./-") nums)
                            nums))))))
#+END_SRC

itools is a conf file
#+BEGIN_SRC emacs-lisp
  (use-package conf-mode
    :mode (rx "itools" eos))
#+END_SRC


*** digit groups
allows us to more easily read binary numbers by visually grouping them
into nibbles.

#+BEGIN_SRC emacs-lisp
  (use-package digit-groups
    :hook (spfspec-mode itpp-mode)
    :init
    (require 'dash)
    (setq digit-groups-digits "01LHX"
          digit-groups-groups
          (mapcar (lambda (x) `(,x . digit-groups-default-face))
                  (--mapcat (list (+ 7 (* 8 it)) (+ 6 (* 8 it)) (+ 5 (* 8 it)) (+ 4 (* 8 it)))
                            '(9 8 7 6 5 4 3 2 1 0))))
    :config
    (set-face-attribute 'digit-groups-default-face nil :underline t))
#+END_SRC
