#+TITLE: Emacs Literate Configuration
#+AUTHOR: Troy Hinckley
#+PROPERTY: header-args :tangle yes

* Configuration
:PROPERTIES:
:VISIBILITY: children
:END:
** Design Choices
I have some basic design principles that I am trying to keep
consistent through all of my config.

*** namespace
I am using =$= as my personal namespace. I like it because it reminds
me of perl, it is really simple, and this is elisp, so I can make my
namespace whatever I want.

*** lambdas
the easiest way add a simple wrapper function to a hook or advice is
to use lambdas. However that has the problem of making them very hard
to inspect and remove. It is better to use named functions. However it
can be confusing if a function is only used as a named lambda or if it
is being used elsewhere. Therefore I will put named functions (using
=defun=) inside of =add-hook= or =advice-add=. This allows me to
clearly associate the function with the purpose but also avoids the
confusion surrounding anonymous functions. However unless it is
necessary, I am not going to add a doc string to these named lambda
functions.

*** overrides
Never override a function when an advice will do. when I actually do
need to override a function, I will try to use the package =el-patch=
to make it maintainable.

** Emacs Initialization

*** lexical bindings

make this file lexically bound
#+BEGIN_SRC elisp
  ;;; init.el --- personal emacs config file -*- lexical-binding: t -*-
#+END_SRC

*** Personal Information
Let's set some variables with basic user information.

#+BEGIN_SRC elisp
  (setq user-full-name "Troy Hinckley"
        user-mail-address "t.macman@gmail.com")
#+END_SRC

*** customization

stolen from https://github.com/abo-abo/oremacs/blob/github/init.el
and modified to be more flexible

This lets us move away from =customize= completely. This is because I
find it annoying when after a "save for future sessions?" prompt Emacs
messes up my nicely categorized customizations by writing them in one
single lump to =~/.emacs.d= avoids =customize=, while still using
the variable's :set property.
#+BEGIN_SRC elisp
  (defmacro csetq (&rest pairs)
    "For each SYMBOL VALUE pair, calls either `custom-set' or `set-default'."
    (let (forms)
      (while pairs
        (let ((variable (pop pairs))
              (value (pop pairs)))
          (push `(funcall (or (get ',variable 'custom-set) 'set-default)
                          ',variable ,value)
                forms)))
      `(progn ,@(nreverse forms))))
#+END_SRC

a simple function to
convert from a cons cell to list for use with
apply.
#+BEGIN_SRC elisp
  (defsubst $flatten-cons (cons)
    (list (car cons) (cdr cons)))
#+END_SRC

*** Settings

#+BEGIN_SRC elisp
  (defvar $leader-key ";"
    "leader key used to quicky access commands.")

  (defvar $mm-leader-key ","
    "leader key for major mode specific commands")
#+END_SRC

don't use menu or scroll bars. We want the UI to be as clean as
possible.
#+BEGIN_SRC elisp
  (setq inhibit-startup-screen t)
  (toggle-frame-fullscreen)
  (add-hook 'focus-in-hook 'redraw-display)
#+END_SRC

Don't create auto save and lock files. I am only working with 1 emacs instance.
#+BEGIN_SRC elisp
  (setq create-lockfiles nil
        auto-save-default nil)
#+END_SRC

#+BEGIN_SRC elisp
  (electric-pair-mode)
#+END_SRC

use =y= and =n= instead of =yes= and =no=
#+BEGIN_SRC elisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

move the custom file to its own loaction so it does not clutter us.
#+BEGIN_SRC elisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load-file custom-file)
#+END_SRC

Never load outdated byte code
#+BEGIN_SRC elisp
  (csetq load-prefer-newer t)
#+END_SRC

We never use right to left scripts, so disable that feature for better
performace
#+BEGIN_SRC elisp
  (setq-default bidi-display-reordering nil)
#+END_SRC

[[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][fix movement lag]] not sure if this will do anything. But since I don't
see any positive improvment from having it enabled I might as well
turn it off.
#+BEGIN_SRC elisp
  (setq auto-window-vscroll nil)
#+END_SRC

*** tangling
we want to tangle on exit so that it will make startup time quicker.
#+BEGIN_SRC elisp
  (require 'cl)

  (defvar $emacs-init-files
    (cl-loop for file in '("emacs" "src/compilation")
             collect (expand-file-name (concat file ".org") user-emacs-directory))
    "All files used in my Emacs config")

  (defun $tangle-init-file ()
    "tangle my emacs org file before closing to make startup faster."
    (interactive)
    (cl-loop for src in $emacs-init-files
             do (let ((dst (concat (file-name-sans-extension src) ".el")))
                  (when (file-newer-than-file-p src dst)
                    (require 'ob-tangle)
                    (org-babel-tangle-file src dst)))))

  (add-hook 'kill-emacs-hook '$tangle-init-file)
#+END_SRC

by setting the initial mode we won't have to load lisp at startup
#+BEGIN_SRC elisp
  (setq initial-major-mode 'fundamental-mode)
#+END_SRC

*** git version

fix the path to use a new version of git
#+BEGIN_SRC elisp
  (setq exec-path (delete "/p/hdk/rtl/proj_tools/proj_binx/shdk74/latest" exec-path))
#+END_SRC

*** server
use the emacs client server so that we can send output to this emacs instance
#+BEGIN_SRC elisp
  (add-hook 'after-init-hook 'server-start)
#+END_SRC

*** Garbage collection
#+BEGIN_SRC elisp
  (defvar $gc-timer nil)
  (defvar $use-gc-timer t)
  (defun $maybe-gc ()
    (setq gc-cons-threshold 800000)
    (setq $gc-timer (run-with-timer 5 nil #'$schedule-maybe-gc))
    (setq gc-cons-threshold 100000000))

  (defun $schedule-maybe-gc ()
    (if $use-gc-timer
        (setq $gc-timer (run-with-idle-timer 3 nil #'$maybe-gc))
      (setq gc-cons-threshold 800000
            $gc-timer nil)))

  (add-hook 'after-init-hook '$schedule-maybe-gc)
#+END_SRC

Set the max eval depth higher. Occasionally I will hit these errors and I want to see if this will fix it.
#+BEGIN_SRC elisp
  (setq max-lisp-eval-depth 10000)
  (setq max-specpdl-size 10000)
#+END_SRC

*** site
set the site I will be working in
#+BEGIN_SRC elisp
  (load-file (expand-file-name "site/site.el" user-emacs-directory))
#+END_SRC

** Package Manager
We are going to use =straight.el= as package manager because it allows
us to easily maintain private repos of packages.
The intel proxy does not work with HTTPS so we need to use the http repo
#+BEGIN_SRC elisp
  (setq straight-recipes-gnu-elpa-url "http://git.savannah.gnu.org/git/emacs/elpa.git")
#+END_SRC

This is still slower then using package.el, but I think it is worth
it. below is the bootstrap code to download the package manager and
run it.
#+BEGIN_SRC elisp
  (setq straight-check-for-modifications '(check-on-save find-when-checking))
  (defvar bootstrap-version 5)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory)))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

** use package

=use-package= is a macro that allows to easily define and load other
packages.  It is the first thing we want to install. I am using my own
fork of the package that contains more sane defaults for the =:hook=
keyword (essentially it automatically adds the =-mode= suffix).

*** use-package
#+BEGIN_SRC elisp
  (straight-use-package
   '(use-package
      :host github :repo "jwiegley/use-package"
      :fork (:host github :repo "CeleritasCelery/use-package")))
#+END_SRC

Setting =straight-use-package-by-default= to =t= we can ensure that
=use-pacakge= will use =straight.el= to install missing packages for
us. Always defer will guarantee that all packages are autoloaded
unless explicitly stated otherwise.
#+BEGIN_SRC elisp
  (setq straight-use-package-by-default t
        use-package-always-defer t)
#+END_SRC

** emacs startup profiler
The "Emacs Startup profiler". This allows us to see what parts of the
config are most heavily impacting start up time. you can't optimize
until you have good info
#+BEGIN_SRC elisp
  (use-package esup)
#+END_SRC

* Packages
:PROPERTIES:
:VISIBILITY: children
:END:
** setup
packages that are used to setup my emacs enviroment. They are
needed as dependaceies for other packages later on.

*** general package
This package lets us use =SPC= as leader key for other keybindings. It
also provides a lot of helper functions to make binding keys easier
and smarter.
#+BEGIN_SRC elisp
  (use-package general
    :demand t)

  (general-create-definer $leader-set-key
    :prefix $leader-key
    :states 'motion
    :keymaps 'override)

  (general-create-definer $leader-local-set-key
    :prefix $mm-leader-key
    :states 'motion)

  (defun general-leader-define-key (_state keymap key def _orig-def _kargs)
    "define a new key based on leader"
    (if (eq keymap 'global)
        (eval `($leader-set-key ,key ',def))
      (eval `($leader-local-set-key :keymaps ',keymap ,key ',def))))

  (defalias 'use-package-handler/:keys 'use-package-handler/:general)
  (defalias 'use-package-normalize/:keys 'use-package-normalize/:general)
  (add-to-list 'use-package-keywords :keys)
#+END_SRC

*** compdef
Short hand for defining company backends for major modes. Needs to be loaded
before we use it in use package
#+BEGIN_SRC elisp
  (use-package compdef
    :demand t)
#+END_SRC

*** no littering
make sure that third party files cannot leave conifg and save files
all over the place
#+BEGIN_SRC elisp
  (use-package no-littering
    :demand t)
#+END_SRC

*** save hist
save minibuffer history between sessions.
#+BEGIN_SRC elisp
  (use-package savehist
    :straight nil
    :defer 1
    :custom
    (savehist-additional-variables '(helm-ff-history))
    :config
    (savehist-mode))
#+END_SRC

*** hydra
hydra provides repeatable keybindings to quickly execute multiple
commands
#+BEGIN_SRC elisp
  (use-package hydra)
#+END_SRC

Make hydra uses posframe
#+BEGIN_SRC elisp
  (use-package hydra-posframe
    :straight
    (:host github :repo "Ladicle/hydra-posframe")
    :custom
    (hydra-posframe-poshandler 'posframe-poshandler-frame-top-center)
    :hook (after-init . hydra-posframe-enable))
#+END_SRC

*** el-patch
#+BEGIN_SRC elisp
  (use-package el-patch)
#+END_SRC

** UI
packages that are used to improve the visuals and interface for Emacs

*** highlight line

highlight the current line with a background face
#+BEGIN_SRC elisp
  (use-package hl-line
    :demand t
    :config
    (global-hl-line-mode))

  (general-add-hook '(evil-visual-state-entry-hook evil-insert-state-entry-hook)
                    (defun $disable-hl-line ()
                      (global-hl-line-mode -1)))

  (general-add-hook '(evil-visual-state-exit-hook evil-insert-state-exit-hook)
                    (defun $enable-hl-line ()
                      (global-hl-line-mode)))
#+END_SRC

*** font
Setup the font that I want to use. Symbola is a backup font that has
many unicode symbols
#+BEGIN_SRC elisp
  (set-face-attribute 'default nil :family "Source Code Pro" :height 120)
  (set-fontset-font t nil "Symbola" nil 'append)
#+END_SRC

use a hydra to scale the text size
#+BEGIN_SRC elisp
  (defhydra text-scale (:hint nil)
    "
  Text Scale
    _i_n _o_ut _s_cale _r_eset _q_uit
  "
    ("i" text-scale-increase)
    ("o" text-scale-decrease)
    ("s" (text-scale-set 3) :exit t)
    ("r" (text-scale-set 0) :exit t)
    ("q" nil :exit t))
  ($leader-set-key
    "z" '(:ignore t :wk "util")
    "zs" 'text-scale/body)
#+END_SRC

*** line numbers
Emacs 26 ships with native line numbers. I am testing out relative
numbers, but I need a way to show absolute line numbers when needed.
#+BEGIN_SRC elisp
  (setq display-line-numbers-type 'relative
        display-line-numbers-current-absolute nil)

  (add-hook 'prog-mode-hook #'display-line-numbers-mode)

  (defun $toggle-absolute-line-numbers ()
    (interactive)
    (setq-local display-line-numbers-type
                (if (eq t display-line-numbers-type)
                    'relative t))
    ;; toggle the minor mode
    (display-line-numbers-mode -1)
    (display-line-numbers-mode))

  ($leader-set-key
    "tN" '$toggle-absolute-line-numbers)
#+END_SRC

*** ligatures
ligatures use a custom symbol to represent two or more characters.
Emacs does not have built-in support for ligatures, so we have to use
a font that maps them to open unicode points. This lets us compose our
own ligatures.
#+BEGIN_SRC elisp
  (setq $fira-ligature-alist
        '(("&&"   . #xEF3B)
          ("||"   . #xEF3C)
          ("::"   . #xEF07)
          ("=="   . #xEF4C)
          ("->"   . #xEF15)
          ("=>"   . #xEF4F)
          ("/*"   . #xEF32)
          ("*/"   . #xEF03)
          ("*>"   . #xEF02)
          (">>"   . #xEF58)
          ("<<"   . #xEF72)
          (".."   . #xEF28)
          ("__"   . #xEF39)
          ("~~"   . #xEF7F)
          ("++"   . #xEF47)
          ("!="   . #xEF0F)
          (".="   . #xEF27)
          ("=~"   . #xEF83)
          ("!~"   . #xEF84)
          (";;"   . #xEF31)
          ("##"   . #xEF1E)
          ("#!"   . #xEF1D)
          ("//"   . #xEF36)
          (":="   . #xEF0A)
          ("?="   . #xEF2E)
          ("?:"   . #xEF2D)
          ("<="   . #xEF91)
          (">="   . #xEF90)
          ("</"   . #xEF79)
          ("/>"   . #xEF35)
          ("</>"  . #xEF7A)
          ("///"  . #xEF37)
          ("==="  . #xEF4D)
          ("!=="  . #xEF10)
          ("<=>"  . #xEF6F)
          ("..."  . #xEF2B)
          ("->>"  . #xEF16)
          ("-->"  . #xEF14)
          ("<--"  . #xEF67)
          ("|->"  . #xEF8C)
          ("|=>"  . #xEF8D)
          ("<<<"  . #xEF75)
          (">>>"  . #xEF5B)
          ("###"  . #xEF1F)
          ("####" . #xEF20)
          ("<!--" . #xEF65)
          ("\\\\" . #xEF85)))

  (set-fontset-font t '(#xEF00 . #xEFFF) "Fira Code Extended")

  (defun $make-ligature-glyph (str glyph)
    (if (or (listp glyph)
            (eq 1 (string-width str)))
        glyph
      `(,@(mapcan (lambda (x) (list ?\s '(Br . Bl)))
                  (number-sequence 2 (string-width str)))
        ?\s (Br . Br) ,(decode-char 'ucs glyph))))

  (defun $set-ligature (symbol)
    (cl-destructuring-bind (str . glyph) symbol
      (setf (alist-get str prettify-symbols-alist nil nil 'equal)
            ($make-ligature-glyph str glyph))))

  (defun $prettify-base-symbols ()
    "enable hasklig ligatures"
    (interactive)
    (mapc '$set-ligature $fira-ligature-alist)
    (prettify-symbols-mode))

  (add-hook 'prog-mode-hook '$prettify-base-symbols)
#+END_SRC

compose symbols (ligatures) no matter where they are. also unformat at
point so we can easily see the representation
#+BEGIN_SRC elisp
  (csetq prettify-symbols-unprettify-at-point t
         prettify-symbols-compose-predicate
         (defun $prettify-symbols-all-p (start end match)
           (not (or (eq (char-before start) (char-after start))
                    (eq (char-before end) (char-after end))
                    (and (member match '("//" "/*" "*/"))
                         (not (nth 4 (syntax-ppss)))) ;; inside comment
                    (and (equal match "..")
                         (or (eq (char-before start) ?/)
                             (eq (char-after end) ?/)))
                    (and (equal match "=~")
                         (eq (char-after end) ?/))
                    (and (equal match ">=")
                         (eq (char-after end) ?<))))))
#+END_SRC

Fix a little issue where closing html tags are not highlighted
properly when using ligatures.
#+BEGIN_SRC elisp
  (add-hook 'html-mode-hook
            (lambda ()
              (font-lock-add-keywords
               nil '(("/>" . 'rainbow-delimiters-depth-1-face)))))
#+END_SRC

*** vnc size
change the size of the VNC to match the size of the monitor that I am
using. Since I always run my VNC fullscreen having the VNC resolution
not match the resolution of my monitor results in weird text sizes.
#+BEGIN_SRC elisp
  (defun vnc-resize (size)
    "Use xrandr to resize my VNC window"
    (let ((default-directory "~/")
          (inhibit-message t))
      (shell-command (concat "xrandr --size " size))))

  (defhydra vnc-resize (:columns 2 :exit t)
    "VNC Resize"
    ("l" (vnc-resize "1920x1200") "single monitor (large)")
    ("m" (vnc-resize "1536x864") "mobile")
    ("w" (vnc-resize "3840x1200") "double monitor (wide)")
    ("s" (vnc-resize "1920x1080") "short")
    ("h" (vnc-resize "2400x1350") "huge")
    ("r" (vnc-resize "1600x1200") "square"))

  ($leader-set-key
    "zn"  'vnc-resize/body)

  (general-def "<f5>"
    (defun $vnc-resize-large ()
      (interactive)
      (vnc-resize "1920x1200")))
#+END_SRC

*** themes
Creating a collection of themes that I like. I can use =helm-themes=
to switch between them. Some of these themes do not have all faces
that I would like, so When I get some time I will modify them. See
[[https://github.com/raxod502/straight.el/issues/265][this]] issue for conflict with challenger-deep and dracula.
#+BEGIN_SRC elisp
  (use-package challenger-deep-theme
    :straight (:local-repo "challenger-deep-theme"))
  (use-package dracula-theme
    :straight (:local-repo "dracula-theme"))
  (use-package gruvbox-theme)
  (use-package darktooth-theme
    :straight
    (:fork "CeleritasCelery/emacs-theme-darktooth"))
  (use-package spacemacs-theme)
  (use-package moe-theme
    :init
    (add-to-list 'custom-theme-load-path "~/.emacs.d/straight/build/moe-theme/"))
  (use-package doom-themes)
  (use-package solarized-theme)
  (use-package color-theme-sanityinc-tomorrow)
  (use-package noctilux-theme)
  (use-package flatland-theme)
  (use-package monokai-theme)
  (use-package twilight-anti-bright-theme)
  (use-package twilight-bright-theme)

  (load-theme 'darktooth t)
#+END_SRC

Get face at point for inspection
#+BEGIN_SRC elisp
  (defun $whatis-face ()
    "Display the face at point"
    (interactive)
    (message "CurrentFace: %s"
             (get-text-property (point) 'face)))
#+END_SRC

**** colors
These two packages provide some great tools for editing and analying
themes visually.

With rainbow mode, colors are highlighted with their actual color. We
don't want to highlight color "names" in elisp though.
#+BEGIN_SRC elisp
  (use-package rainbow-mode
    :init
    (setq rainbow-x-colors nil))
#+END_SRC

fontify face will colorize faces with their face. we combine this with
rainbow mode to make a minor mode that is perfect for editing themes.
#+BEGIN_SRC elisp
  (use-package fontify-face)

  (define-minor-mode $color-mode
    "turn on rainbow and fontify-face modes"
    :group '$color-mode
    (if $color-mode
        (progn (rainbow-mode)
               (fontify-face-mode))
      (rainbow-mode -1)
      (fontify-face-mode -1)))

  ($leader-set-key
    "zc" '(:ignore t :wk "color")
    "zcc" '$color-mode)
#+END_SRC

use helm to look at all availible colors
#+BEGIN_SRC elisp
  ($leader-set-key
    "zcs" 'helm-colors)
#+END_SRC

*** modeline
Doom modeline works great, but a couple of small tweaks. First we
don't need the evil-state in the modeline, it is obvious enough.
Second we want to make sure that all "buffer info" flags can be
displayed at the same time.
#+BEGIN_SRC elisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :custom
    (doom-modeline-buffer-file-name-style 'relative-from-project)
    (doom-modeline-env-version nil)
    (doom-modeline-github nil)
    (doom-modeline-major-mode-color-icon t)
    :config
    (setq eldoc-eval-preferred-function 'eval-expression)
    (doom-modeline-def-segment buffer-encoding-simple
      (propertize
       (concat (pcase (coding-system-eol-type buffer-file-coding-system)
                 (1 " CRLF")
                 (2 " CR"))
               (let ((sys (coding-system-plist buffer-file-coding-system)))
                 (unless (or (memq (plist-get sys :category)
                                   '(coding-category-undecided coding-category-utf-8))
                             (eq (plist-get sys :name) 'no-conversion))
                   (upcase (symbol-name (plist-get sys :name))))))
       'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
       'help-echo 'mode-line-mule-info-help-echo
       'mouse-face '(:box 0)
       'local-map mode-line-coding-system-map))
    (doom-modeline-def-modeline 'custom
      '(bar workspace-name window-number modals matches buffer-info remote-host buffer-position selection-info)
      '(objed-state misc-info debug lsp minor-modes buffer-encoding-simple major-mode process vcs checker))
    (add-hook 'doom-modeline-mode-hook
              (defun $custom-doom-modeline ()
                (doom-modeline-set-modeline 'custom 'default)))
    (column-number-mode))
#+END_SRC

*** which key
which key is an awesome package that shows me the key I can press
after choosing a prefix key.
#+BEGIN_SRC elisp
  (use-package which-key
    :demand t
    :init
    (setq which-key-idle-delay 0.5
          which-key-idle-secondary-delay 0.1
          which-key-allow-evil-operators t)
    :config
    (which-key-mode)
    (push '((nil . "\\$") . (nil . "")) which-key-replacement-alist))
#+END_SRC

*** ace window
This is a window managment package that I am testing out. it works
pretty well, but I have a couple of things I would like to change.
1. there is no good way to operate on the current window, you have to
   knows its letter first, which is not always easy. my idea is that
   the capital of action would operate on the current window. For
   example =Q X= would delete the current window. This would take a
   fair amount of work to change the package however. Or at least so I
   think, I have not actually looked at it yet. I want to wait for
   while to make this change so that I can get the muscle memory down
   and see if that makes this easier with this package.
2. This package will split the window but leave the cursor in the old
   window. I relalize this is just a little thing. but it is very
   unintuitive for me and I have to think about it every time.
#+BEGIN_SRC elisp
  (use-package ace-window
    :general
    (:states '(motion)
     "Q" 'ace-window)
    :init
    (setq aw-dispatch-always t
          aw-background nil)
    :config
    (add-to-list 'aw-dispatch-alist '(?w $toggle-maximize-window))
    (add-to-list 'aw-dispatch-alist '(?d aw-delete-window "delete window"))
    (add-to-list 'aw-dispatch-alist '(?s aw-split-window-horz "Split Horz window")))

  ;; from https://gist.github.com/3402786
  (defun $toggle-maximize-window ()
    "Maximize buffer"
    (interactive)
    (if (and (= 1 (length (window-list)))
             (assoc ?_ register-alist))
        (jump-to-register ?_)
      (progn
        (window-configuration-to-register ?_)
        (delete-other-windows))))
#+END_SRC

*** shackle
this is a window managment package that is very minimalistic. I am
going to use it until I find a case where it won't work, then I might
try a more powerful package like popwin.
#+BEGIN_SRC elisp
  (use-package shackle
    :demand t
    :config
    (shackle-mode))

  (defmacro $shacklize (fn)
    "change the function signature of display-buffer functions to
  account for shackle calling convetion"
    `(lambda (buf alist _plist) (,fn buf alist)))
#+END_SRC

*** buffers
A collection of functions stolen from Spacemacs that allows me to more
easily manipulate files, buffers, and windows.

#+BEGIN_SRC elisp
  (defun $alternate-buffer (&optional window)
    "Switch back and forth between current and last buffer in the
  current window."
    (interactive)
     (let ((current-buffer (window-buffer window))
          (buffer-predicate
           (frame-parameter (window-frame window) 'buffer-predicate)))
      ;; switch to first buffer previously shown in this window that matches
      ;; frame-parameter `buffer-predicate'
      (switch-to-buffer
       (or (cl-find-if (lambda (buffer)
                         (and (not (eq buffer current-buffer))
                              (or (null buffer-predicate)
                                  (funcall buffer-predicate buffer))))
                       (mapcar #'car (window-prev-buffers window)))
           ;; `other-buffer' honors `buffer-predicate' so no need to filter
           (other-buffer current-buffer t)))))

  (defun $quit-emacs ()
    "save buffers and quit"
    (interactive)
    (save-some-buffers)
    (kill-emacs))

  (defun $show-and-copy-buffer-filename (arg)
    "Show and copy the full path to the current file in the minibuffer."
    (interactive "P")
    ;; list-buffers-directory is the variable set in dired buffers
    (if-let ((file-name (or (buffer-file-name)
                            list-buffers-directory
                            default-directory)))
        (message (kill-new ($correct-file-path file-name arg)))
      (error "Buffer not visiting a file")))

  (defun $correct-file-path (file &optional invert)
    "If file is in a work disk, get the absolute path.
  If INVERT, do the opposite of the normal behavior."
    (let ((home (expand-file-name "~")))
      (if (eq (null invert)
              (or (string-prefix-p (concat home "/workspace") file)
                  (string-prefix-p (concat home "/GLS") file)
                  (string-prefix-p (concat home "/temp") file)))
          (file-truename file)
        file)))

  ($leader-set-key
    "TAB" '$alternate-buffer
    "fy" '$show-and-copy-buffer-filename
    "q" '(:ignore t :wk "quit")
    "qq" '$quit-emacs)
#+END_SRC

quick movement hydra and keybindings
#+BEGIN_SRC elisp
  (defhydra buffer-nav (:exit nil)
    "move quickly through recent buffers"
    ("p" previous-buffer "prev")
    ("N" previous-buffer "prev")
    ("n" next-buffer "next"))

  ($leader-set-key
    "b" '(:ignore t :wk "buffers")
    "bp" 'buffer-nav/previous-buffer
    "bn" 'buffer-nav/next-buffer)

  (general-def "C-x k" 'kill-this-buffer)
#+END_SRC

**** scratch
#+BEGIN_SRC elisp
  (setq initial-scratch-message ";; scratch buffer -*- lexical-binding: t -*-\n")

  (defun $open-scratch-buffer ()
    "open the scratch buffer"
    (interactive)
    (set-window-buffer
     (selected-window)
     (get-buffer-create "*scratch*")))

  ($leader-set-key
    "bs" '$open-scratch-buffer)
#+END_SRC

**** buffer expose
show all buffers in a buffer switcher popup. usefull if you can't
remember the name of a buffer, but know what it "looks like".
#+BEGIN_SRC elisp
  (use-package buffer-expose
    :custom
    (buffer-expose-rescale-factor 0.5)
    :general
    (:definer 'leader
     "bj" 'buffer-expose)
    (buffer-expose-grid-map
     "h" 'buffer-expose-left-window
     "j" 'buffer-expose-down-window
     "k" 'buffer-expose-up-window
     "l" 'buffer-expose-right-window))
#+END_SRC

*** window
switch back to minibuffer when it is active.

#+BEGIN_SRC elisp
  (defun $switch-to-minibuffer-window ()
    "switch to minibuffer window (if active)"
    (interactive)
    (when (active-minibuffer-window)
      (select-frame-set-input-focus (window-frame (active-minibuffer-window)))
      (select-window (active-minibuffer-window))))

  ($leader-set-key
    "bm" '$switch-to-minibuffer-window)
#+END_SRC

**** rotate
rotate the window configuration
#+BEGIN_SRC elisp
  (use-package rotate
    :general
    (:definer 'leader
     "bw" 'rotate-layout))
#+END_SRC

**** winum
winum adds the window number to the mode-line and gives us easy
bindings to jump between windows. We need to update
=winum-assign-functions= so that we are using the same ordering as
ace-window.
#+BEGIN_SRC elisp
  (use-package winum
    :defer 1
    :init
    (dolist (num (number-sequence 0 9))
      (let ((str (number-to-string num)))
        (eval `($leader-set-key
                 ,str (intern (concat "winum-select-window-" ,str))))))
    :config
    (add-to-list 'winum-assign-functions
                 (defun $winum-use-ace-window-numbering ()
                   (require 'ace-window)
                   (when-let ((windows (cl-sort (winum--window-list) 'aw-window<))
                              (pos (cl-position (selected-window) windows)))
                     (1+ pos))))
    (winum-mode))
#+END_SRC

**** zoom
zoom lets me make a smaller window larger so that we can see it easier
#+BEGIN_SRC elisp
  (use-package zoom
    :general
    (:definer 'leader "zw" 'zoom))
#+END_SRC

*** scroll bar
add a fringe scroll bar it make it visually clearer where we are in the buffer
#+BEGIN_SRC elisp
  (use-package yascroll
    :defer 2
    :init
    (fringe-mode '(8 . 5))
    :config
    (global-yascroll-bar-mode)
    (setq yascroll:disabled-modes '(compilation-mode bman-mode ipgen-mode))
    (advice-add 'yascroll:enabled-buffer-p :filter-return #'$yascroll-disable-large-files))

  (defun $yascroll-disable-large-files (ret)
    (when (<= (buffer-size) 50000000)
      ret))
#+END_SRC

*** helpful
helpful provides better information about variables and
functions. only tweak we need to make is let the window close with q
#+BEGIN_SRC elisp
  (use-package helpful
    :general ("C-h k" 'helpful-key)
    :init
    (setq find-function-C-source-directory
          (expand-file-name "~/custom/emacs-mirror/src/")))
#+END_SRC

Always select the help window
#+BEGIN_SRC elisp
  (setq help-window-select t)
#+END_SRC

we are going to add helpful to the completing read handler for
helm. This will let us preview the variable with TAB.
#+BEGIN_SRC elisp
  (with-eval-after-load 'helm-mode
    (require 'map)
    (dolist (help-fn '(helpful-variable
                       helpful-function
                       helpful-macro
                       helpful-key
                       helpful-callable))
      (map-put helm-completing-read-handlers-alist help-fn 'helm-completing-read-symbols)))
#+END_SRC

Also add it to the ivy handler
#+BEGIN_SRC elisp
  (csetq counsel-describe-variable-function 'helpful-variable
        counsel-describe-function-function 'helpful-callable)

  (general-def
    "C-h f" 'counsel-describe-function
    "C-h v" 'counsel-describe-variable
    "C-h x" 'describe-char)
#+END_SRC

*** eyebrowse
minimal window managment package.
#+BEGIN_SRC elisp
  (use-package eyebrowse
    :init
    (defhydra eyebrowse (:exit t :pre (eyebrowse-mode))
      "Window Config"
      ("e" eyebrowse-switch-to-window-config "switch")
      ("n" eyebrowse-next-window-config "next" :exit nil)
      ("p" eyebrowse-prev-window-config "previous" :exit nil)
      ("d" eyebrowse-close-window-config-prompt "close")
      ("r" eyebrowse-rename-window-config "rename")
      ("1" eyebrowse-switch-to-window-config-1)
      ("2" eyebrowse-switch-to-window-config-2)
      ("3" eyebrowse-switch-to-window-config-3)
      ("4" eyebrowse-switch-to-window-config-4)
      ("5" eyebrowse-switch-to-window-config-5))
    ($leader-set-key
      "e" 'eyebrowse/body))
#+END_SRC

*** toggles
minor modes that I commonly toggle on and off
#+BEGIN_SRC elisp
  ($leader-set-key
    "t" '(:ignore t :wk "toggle")
    "tn" 'display-line-numbers-mode
    "tl" 'toggle-truncate-lines
    "te" 'toggle-debug-on-error
    "tq" 'toggle-debug-on-quit
    "tg" 'git-gutter-mode)
#+END_SRC

When a form is wrapped in a condtion case, it can handle its own
errors. However if you are trying to debug an error that caught by a
=condtion-case= it can get in the way. However if =debug-on-signal is
set then all errors will trigger a back trace.
#+BEGIN_SRC elisp
  (defun $toggle-debug-on-signal ()
    "Used when debugging something wrapped in a condition-case"
    (interactive)
    (if debug-on-signal
        (progn (message "debug on signal disabled")
               (setq debug-on-signal nil))
      (message "debug on signal enabled")
      (setq debug-on-signal t)))

  ($leader-set-key
    "ts" '$toggle-debug-on-signal)
#+END_SRC

*** outshine
The outshine package is an advanced version of outline mode that aims
to add more org like features. It may eventually replace my literate
config. Navi allows navigation of outshine headers.
#+BEGIN_SRC elisp
  (use-package outshine
    :hook emacs-lisp-mode
    :straight
    (:fork "CeleritasCelery/outshine"))

  (use-package navi-mode)
#+END_SRC

*** restart
#+BEGIN_SRC elisp
  (use-package restart-emacs
    :init
    ($leader-set-key
      "qr" 'restart-emacs))
#+END_SRC

#+BEGIN_SRC elisp
  (setq confirm-kill-emacs 'y-or-n-p
        confirm-kill-processes nil)
#+END_SRC

changing the volume on my mic triggers these bindings. So we ignore them.
#+BEGIN_SRC elisp
  (general-def
    "<XF86AudioLowerVolume>" 'ignore
    "<XF86AudioRaiseVolume>" 'ignore)
#+END_SRC

Accidentally hit this key a lot
#+BEGIN_SRC elisp
  (general-def "C-x C-z" 'ignore)
#+END_SRC

*** highlight escape sequences

#+BEGIN_SRC elisp
  (use-package highlight-escape-sequences
    :ghook ('(cperl-mode-hook perl-mode-hook python-mode-hook) 'hes-mode)
    :config
    (dolist (mode '(perl-mode cperl-mode python-mode))
      (add-to-list 'hes-mode-alist (cons mode hes-common-escape-sequence-re))))
#+END_SRC

** Ivy
I feel like ivy is simpler to setup so I am going to give it a try. I
am going to have to try to fix =counsel-ag= out of order matching if I
want to live with it though.

#+BEGIN_SRC elisp
  (use-package ivy
    :general
    (ivy-minibuffer-map
     "C-j" 'ivy-next-line
     "C-k" 'ivy-previous-line
     "C-h" "DEL"
     "C-w" 'ivy-backward-kill-word
     "C-S-H" help-map
     "C-l" 'ivy-alt-done
     "TAB" 'ivy-alt-done
     "<C-return>" 'ivy-immediate-done
     [mouse-1] 'ignore
     [mouse-2] 'ignore
     [mouse-3] 'ignore)
    (ivy-reverse-i-search-map
     "C-k" 'ivy-previous-line)
    (ivy-switch-buffer-map
     "C-k" 'ivy-previous-line
     "C-d" 'ivy-switch-buffer-kill)
    ("C-x r b" 'counsel-bookmark
     "C-x C-r" 'ivy-resume)
    (ivy-occur-grep-mode-map
     "SPC" nil)
    :init
    (setq ivy-height 15
          ivy-use-virtual-buffers t
          ivy-virtual-abbreviate 'abbreviate
          ivy-extra-directories nil
          ivy-use-selectable-prompt t
          ivy-count-format "%d/%d "
          ivy-re-builders-alist '((t . ivy--regex-ignore-order))
          ivy-magic-slash-non-match-action 'ivy-magic-slash-non-match-create)
    :config
    (ivy-mode)
    (setq ivy-sort-matches-functions-alist '((t))) ;; don't resort my functions
    (add-to-list 'ivy-ignore-buffers (rx bos "magit-" (1+ word) (or ":" "("))))
#+END_SRC

Some faces have org-level-4 use a larger face, which really messes
with the display
#+BEGIN_SRC elisp
  (setq ivy-switch-buffer-faces-alist '((dired-mode . ivy-subdir)
                                         (org-mode . org-level-8)))
#+END_SRC

#+BEGIN_SRC elisp
  (use-package ivy-hydra
    :after (ivy hydra))
#+END_SRC

*** actions
#+BEGIN_SRC elisp
  (with-eval-after-load 'counsel
    (ivy-add-actions
     t
     '(("y" kill-new "yank" $ivy-yank-all)))
    (ivy-add-actions
     'counsel-find-file
     '(("g" $magit-status-in-dir "git status")
       ("d" $async-delete-file "delete")
       ("y" $yank-file-name "yank" $yank-file-name-list)
       ("s" (lambda (x) (counsel-rg nil x)) "search")
       ("f" $ivy-file-jump "find")
       ("o" find-file-other-window "other window")
       ("x" (lambda (x) ($shell-pop ivy-current-prefix-arg nil x)) "shell")
       ("j" (lambda (x) (let ((default-directory x)) (counsel-git))) "jump"))))

  (defun $ivy-file-jump (x)
    (let ((args (split-string x)))
      (counsel-fd-jump (cdr args) (car args))))

  (defun $ivy-yank-all (x)
    (kill-new (mapconcat 'identity x "\n")))

  (defun $yank-file-name (x)
    (kill-new ($correct-file-path x)))

  (defun $yank-file-name-list (x)
    (kill-new
     (mapconcat
      (lambda (f)
        ($correct-file-path (expand-file-name f ivy--directory)))
      x "\n")))

  (general-def ivy-minibuffer-map ";" 'ivy-dispatching-done)
#+END_SRC

*** swiper
#+BEGIN_SRC elisp
  (use-package swiper
    :general
    ("C-s" 'swiper)
    :config
    (setf (alist-get 'swiper-isearch ivy-display-functions-alist) 'ivy-display-function-window)
    (setf (alist-get 'swiper ivy-display-functions-alist) 'ivy-display-function-window))

  (defun ivy-display-function-window (text)
    (let ((buffer (get-buffer-create "*ivy-candidate-window*"))
          (str (with-current-buffer (window-buffer (active-minibuffer-window))
                 (let ((point (point))
                       (string (concat (buffer-string) "  " text)))
                   (ivy-add-face-text-property
                    (- point 1) point 'ivy-cursor string t)
                   string))))
      (with-current-buffer buffer
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert str)))
      (with-ivy-window
        (display-buffer
         buffer
         `((display-buffer-reuse-window
            display-buffer-below-selected)
           (window-height . ,(1+ (ivy--height (ivy-state-caller ivy-last)))))))))
#+END_SRC

*** counsel
#+BEGIN_SRC elisp
  (use-package counsel
    :bind (("C-x C-f" . counsel-find-file)
           ("C-x f" . counsel-find-file)
           ("C-x C-j" . counsel-git)
           ("C-x j" . counsel-git)
           ("C-c s" . counsel-ag)
           ("M-x" . counsel-M-x))
    :init
    (setq counsel-rg-base-command "rg --with-filename --no-heading --line-number --search-zip --color never %s"
          counsel-find-file-ignore-regexp (rx (or (: bos (any "#.")) (: (any "#~") eos)))
          counsel-bookmark-avoid-dired t)
    :config
    ($normalize-git-version 'counsel-git-cmd)
    ($normalize-git-version 'counsel-git-grep-cmd-default)
    ($normalize-git-version 'counsel-git-log-cmd)
    (setq ivy-initial-inputs-alist nil)
    (setf (alist-get 'counsel-M-x ivy-initial-inputs-alist) nil))

  (defun $normalize-git-version (symbol)
    (set symbol (replace-regexp-in-string
                 (rx symbol-start "git ")
                 "/usr/intel/bin/git "
                 (symbol-value symbol))))
#+END_SRC

a function to call counsel-rg from the current directory
#+BEGIN_SRC elisp
  (defun $counsel-rg-here ()
    (interactive)
    (let ((ivy-posframe-height 30))
      (counsel-rg nil default-directory)))
#+END_SRC

**** functions
Use fd instead of find to search faster
#+BEGIN_SRC elisp
  (defun counsel-fd-jump (&optional initial-input initial-directory)
    (interactive)
    (let ((default-directory (or initial-directory default-directory)))
      (ivy-read "Jump file: "
                (counsel--call '("fd" "--no-ignore" "--hidden" "--exclude" ".git" "--type" "f")
                               (lambda () (split-string (buffer-string) "\n")))
                :matcher #'counsel--find-file-matcher
                :initial-input initial-input
                :action #'find-file
                :preselect (counsel--preselect-file)
                :require-match 'confirm-after-completion
                :history 'file-name-history
                :keymap counsel-find-file-map
                :caller 'counsel-file-jump)))
#+END_SRC

packages used to support counsel
**** smex
#+BEGIN_SRC elisp
  (use-package smex)
#+END_SRC

**** wgrep
Make grep buffers writable
#+BEGIN_SRC elisp
  (use-package wgrep
    :init
    (setq wgrep-auto-save-buffer t))
#+END_SRC

*** posframe
posframe uses child frames to open ivy in the middle of my screen
instead of the bottom left. The only time that we don't want this is
when we are searching the current buffer, so we use a window in that
situtation instead. A window is better then the minibuffer because it
will always be the same width as a window we are searching.
#+BEGIN_SRC elisp
  (use-package ivy-posframe
    :demand t
    :after ivy
    :custom
    (ivy-posframe-size-function '$ivy-posframe-size)
    (ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
    :config
    (ivy-posframe-mode))

  (defun $ivy-posframe-size ()
    (let ((width (round (* (frame-width) 0.5))))
      (list
       :min-height ivy-height
       :width width
       :min-width width)))
#+END_SRC

**** flashing fix
I have an issue with my window manager where the frame will flash
white when removing the ivy posframe. This seems to be because Emacs
does not acknowledge the WM if it has other code to run. The following
code will wait to remove the frame until emacs is idle. This fixes the
flashing issue.
#+BEGIN_SRC elisp
  (defvar posframe-timer nil)

  (defun posframe-force-valid (new-buf &rest _)
    "If we are reusing an exisiting posframe, don't hide the
  previous one. this prevents blanking the frame unnecessarily."
    (let ((timer (cdr posframe-timer))
          (old-buf (car posframe-timer)))
      (when (and (memq timer timer-idle-list)
                 (eq new-buf (get-buffer old-buf)))
        (cancel-timer timer))))

  (el-patch-feature posframe)
  (with-eval-after-load 'posframe
    (advice-add 'posframe--create-posframe :before #'posframe-force-valid)
    (el-patch-defun posframe-hide (posframe-buffer)
      "Hide posframe which buffer is POSFRAME-BUFFER."
      (dolist (frame (frame-list))
        (let ((buffer-info (frame-parameter frame 'posframe-buffer)))
          (when (or (equal posframe-buffer (car buffer-info))
                    (equal posframe-buffer (cdr buffer-info)))
            (el-patch-swap
              (posframe--make-frame-invisible frame)
              (setq posframe-timer
                    (cons posframe-buffer
                          (run-with-idle-timer
                           0.01 nil
                           (lambda ()
                             (posframe--make-frame-invisible frame)))))))))))
#+END_SRC

*** rich
#+BEGIN_SRC elisp
  (use-package ivy-rich
    :demand t
    :after counsel
    :custom
    (ivy-rich-parse-remote-buffer nil)
    :config
    (plist-put ivy-rich-display-transformers-list
               'counsel-find-file
               '(:columns
                 ((ivy-read-file-transformer)
                  (ivy-rich-counsel-find-file-truename (:face font-lock-doc-face)))))
    (plist-put ivy-rich-display-transformers-list
               'counsel-describe-variable
               '(:columns
                 ((counsel-describe-variable-transformer (:width 40))
                  (ivy-rich-counsel-variable-value (:width 10))
                  (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face)))))
    (plist-put ivy-rich-display-transformers-list
               'ivy-switch-buffer
               '(:columns
                 ((ivy-rich-candidate (:width 40))
                  (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right))
                  (ivy-rich-switch-buffer-major-mode (:width 15 :face warning))
                  (ivy-rich-switch-buffer-project (:width 25 :face success)))
                 :predicate
                 (lambda (cand) (get-buffer cand))))
    (plist-put ivy-rich-display-transformers-list
               'counsel-describe-function
               '(:columns
                 ((counsel-describe-function-transformer (:width 40))
                  (ivy-rich-counsel-function-docstring (:width 80 :face font-lock-doc-face)))))
    (ivy-rich-mode))

  (defun ivy-rich-counsel-find-file-truename (candidate)
    (let ((type (and (not (file-remote-p ivy--directory))
                     (car (file-attributes
                           (directory-file-name
                            (expand-file-name candidate ivy--directory)))))))
      (if (stringp type)
          (concat "â†’ " (expand-file-name type ivy--directory))
        "")))

  (defun ivy-rich-counsel-variable-value (candidate)
    (let* ((var (intern candidate))
           (val (prin1-to-string
                 (if (boundp var)
                     (symbol-value var)
                   '<unbound>))))
      (if (< 31 (length val))
          (substring val 0 30)
        val)))
#+END_SRC

*** prescient
#+BEGIN_SRC elisp
  (use-package ivy-prescient
    :demand t
    :after counsel
    :init
    (setq prescient-filter-method '(regexp initialism)
          ivy-prescient-sort-commands '(counsel-bookmark))
    :config
    (prescient-persist-mode)
    (advice-add #'ivy-read :filter-args #'ivy-prescient--enable-sort-commands)
    (advice-add #'ivy--get-action :filter-return #'ivy-prescient--wrap-action)
    (setf (alist-get 'counsel-describe-variable ivy-re-builders-alist) 'ivy-prescient-re-builder)
    (setf (alist-get 'counsel-describe-variable ivy-sort-functions-alist) 'ivy-string<)
    (setf (alist-get 'counsel-describe-function ivy-re-builders-alist) 'ivy-prescient-re-builder)
    (setf (alist-get 'counsel-describe-function ivy-sort-functions-alist) 'ivy-string<)
    (setf (alist-get 'read-file-name-internal ivy-sort-functions-alist) 'ivy-prescient-sort-function)
    (setf (alist-get t ivy-sort-functions-alist) 'ivy-prescient-sort-function))
#+END_SRC

** evil
evil is the Extensible VI Layer. It gives us all the power of vim
without the draw back of using vimscript for config.

*** general

we want to overide most control keybindings to make them behave like
Vim instead of like Emacs.
#+BEGIN_SRC elisp
  (use-package evil
    :demand t
    :custom
    (evil-jumps-cross-buffers nil)
    (evil-want-C-i-jump nil)
    (evil-want-Y-yank-to-eol t)
    (evil-symbol-word-search t "Using * and #, search foward for symbols, not words")
    (evil-ex-substitute-global t)
    (evil-want-keybinding nil "Evil collection will provide this for us")
    (evil-want-abbrev-expand-on-insert-exit nil "Don't try abbrev expand on exit. Causes real issues in verilog mode")
    :config
    (general-swap-key nil 'motion "0" "^")
    (evil-mode 1))
#+END_SRC

I want to preserve the functionality of =C=u=, but still want to use
standard keys to scroll. =C-f= and =C-b= are used for scrolling in
vim/less, but they scroll a whole page, which is too much. So we
rebind these to the normal scroll function.
#+BEGIN_SRC elisp
  (general-def '(normal visual)
    "C-f" 'evil-scroll-down
    "C-b" 'evil-scroll-up)
#+END_SRC

we want to use visual lines, but then the line operators don't work
(i.e. =dj= will not operate on literal lines). So we do some simple
remapping instead of setting =evil-respect-visual-line-mode=.
[[https://github.com/emacs-evil/evil/issues/188][emacs-evil/evil#188]]
#+BEGIN_SRC elisp
  (general-def 'motion
    [remap evil-next-line] 'evil-next-visual-line
    [remap evil-previous-line] 'evil-previous-visual-line)

  (general-def 'operator
    [remap evil-next-line] 'evil-next-line
    [remap evil-previous-line] 'evil-previous-line)
#+END_SRC

add a little hack to prevent =v$= from grabbing the newline. This is a
much better default, but the evil people don't like it and won't add
an option to support it. Nice thing about Emacs though, is we can do
it anyway.  [[https://github.com/emacs-evil/evil/issues/897][emacs-evil/evil#897]]
#+BEGIN_SRC elisp
  (evil-define-motion evil-end-of-line (count)
    "Move the cursor to the end of the current line. If COUNT is
      given, move COUNT - 1 lines downward first."
    :type inclusive
    (move-end-of-line count)
    (when evil-track-eol
      (setq temporary-goal-column most-positive-fixnum
            this-command 'next-line))
    (evil-adjust-cursor)
    (when (eolp)
      (setq evil-this-type 'exclusive)))
#+END_SRC

Sometimes when I am clicking on a window I will accidentally drag.
This leaves me in visual state, so my next comamnd behaves
differently. We can fix this by not letting us drag to select less
then 4 characters.
#+BEGIN_SRC elisp
  (advice-add 'evil-mouse-drag-region :after
              (defun $fix-miss-drag (&rest _x)
                (when (region-active-p)
                  (cl-destructuring-bind (beg . end) (car (region-bounds))
                    (when (> 4 (- end beg))
                      (evil-normal-state))))))

  (advice-add 'mouse-set-region :after 'deactivate-mark)
#+END_SRC

prevent "vimmers" from quiting my Emacs. Old habbits die hard.
#+BEGIN_SRC elisp
  (evil-ex-define-cmd "q" 'kill-current-buffer)
  (evil-ex-define-cmd "q!" 'kill-current-buffer)
  (evil-ex-define-cmd "wq" (defun $save-and-kill-buffer ()
                             (interactive)
                             (save-buffer)
                             (kill-this-buffer)))
#+END_SRC

*** magic searching
by default =evil-ex= uses the emacs regex engine which has some very
weird syntax and annoying escaping. instead we want to use evil's
=very-magic= mode which provdies something much more PCRE
compatible. however we can't just set this directly because
=evil-multiedit= relies on =evil-ex= to be "non-magic". Therefore we
just create user callable wrapper around evil-ex functions. Magic mode
only works if the search module is =evil-search=.
#+BEGIN_SRC elisp
  (setq evil-search-module 'evil-search
        evil-ex-search-vim-style-regexp t)

  (defmacro $make-magic (cmd)
    "make an evil ex command magic"
    `(defun ,(intern (concat "$magic-" (symbol-name cmd))) ()
       (interactive)
       (let ((evil-magic 'very-magic))
         (call-interactively (quote ,cmd)))))

  (general-def '(motion normal visual)
    ":" ($make-magic evil-ex)
    "/" ($make-magic evil-ex-search-forward)
    "?" ($make-magic evil-ex-search-backward)
    "n" ($make-magic evil-ex-search-next)
    "N" ($make-magic evil-ex-search-previous))
#+END_SRC

*** text objects
**** custom
create text objects for the buffer, pasted region, and filename
#+BEGIN_SRC elisp
  (evil-define-text-object evil-entire-buffer (count &optional _beg _end _type)
    (list (point-min) (point-max)))

  (evil-define-text-object evil-pasted (count &rest _args)
    (list (save-excursion (evil-goto-mark ?\[) (point))
          (save-excursion (evil-goto-mark ?\]) (1+ (point)))))

  (evil-define-text-object evil-filename (count &rest _args)
    (let ((bounds (bounds-of-thing-at-point 'filename)))
      (list (car bounds) (cdr bounds))))

  (evil-define-text-object evil-a-dir (count &rest _args)
    (list (save-excursion (search-backward "/") (point))
          (save-excursion (search-forward "/") (1- (point)))))

  (defmacro $define-evil-inner-object (name char)
    `(evil-define-text-object ,(evil-unquote name) (count &rest _args)
       (list (save-excursion (search-backward ,char) (1+ (point)))
             (save-excursion (search-forward ,char) (1- (point))))))

  ($define-evil-inner-object 'evil-i-dir "/")
  ($define-evil-inner-object 'evil-i-tilde "~")
  ($define-evil-inner-object 'evil-i-equal "=")
  ($define-evil-inner-object 'evil-i-dot ".")

  (general-def 'outer
    "/" 'evil-a-dir)

  (general-def 'inner
    "P" 'evil-pasted
    "n" 'evil-filename
    "/" 'evil-i-dir
    "~" 'evil-i-tilde
    "=" 'evil-i-equal
    "." 'evil-i-dot
    "g" 'evil-entire-buffer)
#+END_SRC

**** indentation
The =evil-indent-plus= pakcage provides =i=, =I=, and =J= text objects
the select based on indentation.
#+BEGIN_SRC elisp
  (use-package evil-indent-plus
    :demand t
    :config
    (evil-indent-plus-default-bindings))
#+END_SRC

**** syntax
a text object that highlights everything with the same font lock
#+BEGIN_SRC elisp
  (use-package evil-textobj-syntax
    :straight
    (:host github :repo "laishulu/evil-textobj-syntax")
    :general
    (inner "h" 'evil-i-syntax)
    (outer "h" 'evil-a-syntax))
#+END_SRC

**** columns
#+BEGIN_SRC elisp
  (use-package evil-textobj-column
    :general
    ('inner
     "k" 'evil-textobj-column-word
     "K" 'evil-textobj-column-WORD))
#+END_SRC

**** line
#+BEGIN_SRC elisp
  (use-package evil-textobj-line
    :init
    (setq evil-textobj-line-i-key "v"
          evil-textobj-line-a-key "v")
    :general
    (inner "v" 'evil-inner-line)
    (outer "v" 'evil-a-line))
#+END_SRC
*** EX
Use additional evil-ex bindings
#+BEGIN_SRC elisp
  (evil-ex-define-cmd "rg" '$counsel-rg-here)
  (evil-ex-define-cmd "j" 'counsel-fd-jump)
  (evil-ex-define-cmd "perl" 'perl-mode)
  (evil-ex-define-cmd "lisp" 'emacs-lisp-mode)
  (evil-ex-define-cmd "pkg" 'straight-use-package)
#+END_SRC

*** keybindings
We want to hybridize some useful emacs commands with better evil
keybindings
#+BEGIN_SRC elisp
  (general-def 'insert
    "C-v" 'yank
    "C-y" 'yank)
  (general-def 'emacs
    "<escape>" 'evil-normal-state)
#+END_SRC

general leader key bindings
#+BEGIN_SRC elisp
  ($leader-set-key
    "hs"  'profiler-start
    "hS"  'profiler-stop
    "hr"  'profiler-report
    "hR"  'profiler-reset
    "br" 'rename-buffer
    "bR" 'revert-buffer
    "s" '(:ignore t :wk "search")
    "sc" 'evil-ex-nohighlight
    "u" 'universal-argument)
#+END_SRC

Use a keymap for evil change keybinding. This allows us to bind arbitrary
commands to open keys in =evil-change= map
#+BEGIN_SRC elisp
  (defvar evil-change-map
    (let ((map (make-sparse-keymap)))
      (define-key map "c" (general-simulate-key ('evil-change "c")))
      map))

  (general-def 'normal "c"
    (general-key-dispatch 'evil-change
      :inherit-keymap evil-change-map))
  (general-def 'visual "c" 'evil-change)
#+END_SRC

*** undo-tree
#+BEGIN_SRC elisp
  ($leader-set-key
    "U" 'undo-tree-visualize)
  (general-def '(normal visual)
    "u" 'undo-tree-undo
    "C-r" 'undo-tree-redo)
#+END_SRC

Disable warnings about reverting large buffers
#+BEGIN_SRC elisp
  (with-eval-after-load 'warnings
    (add-to-list 'warning-suppress-types '(undo discard-info)))
#+END_SRC

*** unimpaired
evil unimpaired binds some usefull functions to some quick keys.
#+BEGIN_SRC elisp
  (use-package evil-unimpaired
    :defer 2
    :straight
    (:repo "zmaas/evil-unimpaired")
    :init
    (setq evil-unimpaired-leader-keys '("gk" . "gj"))
    :config
    (evil-unimpaired-mode))
#+END_SRC

*** anzu
provides total number of searches in the modeline
#+BEGIN_SRC elisp
  (use-package evil-anzu
    :straight
    (:fork "CeleritasCelery/emacs-evil-anzu")
    :custom
    (anzu-cons-mode-line-p nil)
    :general
    (:definer 'leader
     "ta" 'anzu-mode))
#+END_SRC

*** escape

use a quick key combo to enter normal state. We don't want to escape
magit because I do that by accident all the time.
#+BEGIN_SRC elisp
  (use-package evil-escape
    :demand t
    :init
    (setq evil-escape-unordered-key-sequence t
          evil-escape-key-sequence "jk")
    :config
    (evil-escape-mode)
    (advice-add 'evil-escape--is-magit-buffer :override (defun $dont-escape-magit () nil)))
#+END_SRC

*** collection
evil collection evilifies several major and minor modes to make them
behave better with evil.
#+BEGIN_SRC elisp
  (use-package evil-collection
    :demand t
    :config
    (add-hook 'evil-collection-setup-hook
              (defun $unmap-leader (_mode keymaps)
                (when (and keymaps
                           (not (memq 'eshell-mode-map keymaps))
                           (not (memq 'ediff-mode-map keymaps)))
                  (general-define-key
                   :states 'normal
                    :keymaps keymaps
                   $leader-key nil
                   $mm-leader-key nil))))
    (evil-collection-init))
#+END_SRC

*** surround
#+BEGIN_SRC elisp
  (use-package evil-surround
    :defer 4
    :general
    ('visual evil-surround-mode-map
             "s" 'evil-surround-region
             "S" 'evil-Surround-region)
    :config
    (setf (alist-get ?\( evil-surround-pairs-alist) '("(" . ")"))
    (setf (alist-get ?\[ evil-surround-pairs-alist) '("[" . "]"))
    (setf (alist-get ?\{ evil-surround-pairs-alist) '("{" . "}"))
    (setf (alist-get ?t  evil-surround-pairs-alist) '$evil-surround-tcl)
    (global-evil-surround-mode))

  (defun $evil-surround-tcl ()
    "Read a functionname from the minibuffer and wrap selection in tcl set command"
    (let ((var (evil-surround-read-from-minibuffer "" "")))
      (cons (format "set %s [" (or var "")) "]")))
#+END_SRC

*** commenting
#+BEGIN_SRC elisp
  (use-package evil-nerd-commenter
    :commands (evilnc-copy-and-comment-operator
               evilnc-comment-operator)
    :general
    ('normal
     "gc" 'evilnc-comment-operator
     "gC" 'evilnc-copy-and-comment-operator))
#+END_SRC

*** replace with register
This package is a great way to replace text with the clipboard without
having to enable visual mode
#+BEGIN_SRC elisp
  (use-package evil-replace-with-register
    :general
    ('normal "go" 'evil-replace-with-register))
#+END_SRC

*** exchange
swap two regions with evil exchange
#+BEGIN_SRC elisp
  (use-package evil-exchange
    :general
    (:states '(visual normal)
     "gx" 'evil-exchange
     "gX" 'evil-exchange-cancel))
#+END_SRC

*** numbers
#+BEGIN_SRC elisp
  (use-package evil-numbers
    :straight (:fork "janpath/evil-numbers"))
#+END_SRC

*** match it
Use =%= to match more then just parens. Such as =module= keyword in verilog.
#+BEGIN_SRC elisp
(use-package evil-matchit
  :hook prog-mode)
#+END_SRC

*** lispy
I tried lispy for a long time, and tried hard to like it. But
eventually I had to admit that it is clahses with the design patterns
of modal editing. Even using lispville (Lispy + evil) can't save it.
However I will keep using lispyville. Not because of its lispy
integration but because it reimplements evil-cleverparens in a nice
package.
#+BEGIN_SRC elisp
  (use-package lispyville
    :hook (perl-mode emacs-lisp-mode)
    :init
    (setq lispyville-key-theme
          '(operators
            c-w
            prettify
            text-objects
            (atom-movement t)
            additional-movement
            slurp/barf-cp
            wrap
            additional
            additional-insert
            additional-wrap))
    (defhydra lispyville-mark (:pre (require 'lispyville)
                               :exit nil)
      ("v" lispyville-wrap-lispy-mark-symbol-visual "symbol")
      ("V" lispyville-wrap-lispy-mark-visual "sexp"))
    ($leader-set-key
      "v" 'lispyville-mark/lispyville-wrap-lispy-mark-visual)
    :config
    (lispyville-wrap-command lispy-mark-symbol visual)
    (lispyville-wrap-command lispy-mark visual))
#+END_SRC

add new keybindings for evil paragraph navigation
#+BEGIN_SRC elisp
  (general-def 'motion
   "H-[" 'evil-backward-paragraph
   "C-]" 'evil-forward-paragraph)
#+END_SRC

Fix moving by sexp when at the end of the line
#+BEGIN_SRC elisp
  (defun $forward-sexp (arg)
    (interactive "^p")
    (when (and (null evil-move-beyond-eol)
               (memq (char-after) '(?\) ?\} ?\])))
      (forward-char))
    (forward-sexp arg))

  (defun $backward-sexp (arg)
    (interactive "^p")
    (when (and (null evil-move-beyond-eol)
               (memq (char-after) '(?\) ?\} ?\])))
      (forward-char))
    (backward-sexp arg))

  (general-def 'normal "C-M-f" '$forward-sexp)
  (general-def 'normal "C-M-b" '$backward-sexp)
#+END_SRC

Make the wrap function sane. Currently if on the closing paren of a sexp it
wraps the last element instead of wrapping the sexp itself.
#+BEGIN_SRC elisp
  (defun $lispy-wrap-adjust-paren (_arg)
    "Always wrap the sexp that the cursor is on"
    (when (eq ?\) (char-syntax (char-after)))
      (evil-jump-item)))
  (advice-add 'lispy-wrap-round :before '$lispy-wrap-adjust-paren)
#+END_SRC

*** parens

=evil-cleverparens= requires paredit, unfortunately the default
paredit recipe does not work for me and I need to update it.
Thankfully, straight.el makes that super easy!
#+BEGIN_SRC elisp
  (use-package paredit
    :straight
    (:files ("paredit.el")
     :repo "http://mumble.net/~campbell/git/paredit.git"))
#+END_SRC

evil cleverparens is a smartparens based paren editor. Lispyville
reimplements all of this functionality, but evil-cleverparens
implements it better. Some examples:

- when entering insert state cleverparens will automatically add a
  space. Lispville can't because it has to leave you in "special"
- when wrapping a form, lispy will try and wrap the quote (='foo ->
  ('foo)=) which is almost never what I want. Smartparens will leave
  the whole sexp wrapped (='foo -> '(foo)=)

However for the most part, I can just use lispyville with lispy
disabled. And a lot of cleverparens functionality requires
=evil-cleverparens= or =smartparens= to be enabled, which I would
prefer not to do.
#+BEGIN_SRC elisp
  (use-package evil-cleverparens
    :commands (evil-cp-insert
               evil-cp-append)
    :general
    ('normal
     emacs-lisp-mode-map
     "i" 'evil-cp-insert
     "a" 'evil-cp-append))
#+END_SRC

For a long time I used =evil-lisp-state= and loved it. However I
realized that it was overkill for what I wanted, and it relied
exclusivly on smartparens. So instead I created my own hydra that
takes the best functions from lispy, evil-cleverparens, and
smartparens and puts them into one dispatcher.
#+BEGIN_SRC elisp
  (defhydra lisp-quick (:pre (require 'evil-cleverparens))
    "quick commands evil-lisp-state"
    ("I" evil-cp-insert-at-beginning-of-form "insert list")
    ("A" evil-cp-insert-at-end-of-form "append list")
    ("O" lispyville-open-above-list "open above")
    ("o" lispyville-open-below-list "open below")
    ("J" lispy-join "join" :exit nil)
    ("r" sp-raise-sexp "raise" :exit nil)
    ("R" lispyville-raise-list "raise list" :exit nil)
    ("w" (sp-wrap-with-pair "(") "wrap" :exit nil))

  ($leader-set-key
    "m" 'lisp-quick/body)
#+END_SRC

** Helm
helm is the more powerfull of the two between itself and ivy. I really
want to give Ivy a good try because it seems snappier on large files,
but there are still some issues that gives helm the advantage
- helm supports marking, which is very efficient.

I have decided to switch from using advices to make helm behave as I
want and am now maintaining my own helm fork. This fork differs from
the stock helm in these ways
- prevent buffers from resorting the initial order
- add adaptive sorting to find files and symbol helms
- reorder the sources of helm-bookmarks to list directories first
- remove the parent hardlink .. from the find file candidates

*** general

we want to make the helm keybindings more evil friendly. also change
the display function to be more consistent.
#+BEGIN_SRC elisp
  (use-package helm
    :straight
    (:fork "CeleritasCelery/helm")
    :commands helm-find-files-1
    :general
    (:keymaps 'minibuffer-local-map
     "C-c C-l" 'helm-minibuffer-history)
    (:keymaps 'helm-map
     "C-j" 'helm-next-line
     "C-k" 'helm-previous-line
     "C-h" 'helm-next-source
     "C-S-h" 'helm-help
     "C-c C-h" 'describe-key
     "C-l" "RET"
     "C-z" 'helm-select-action
     "TAB" 'helm-execute-persistent-action)
    (:keymaps '(helm-find-files-map
                helm-read-file-map)
     "C-l" 'helm-execute-persistent-action
     "C-h" 'helm-find-files-up-one-level)
    ("M-y" 'helm-show-kill-ring
     "C-x C-x" 'helm-all-mark-rings
     "C-c C-f" 'helm-find-files)
    (:definer 'leader
     "fr" 'helm-recentf
     "r"  'helm-resume)
    :custom
    (helm-split-window-in-side-p t)
    (helm-buffer-max-length 60)
    (helm-ff-candidate-number-limit 500)
    (helm-ff-fuzzy-matching nil)
    (helm-buffer-skip-remote-checking t)
    (helm-echo-input-in-header-line t)
    (helm-ff-delete-files-function 'helm-delete-marked-files-async)
    (helm-adaptive-history-length 100)
    (helm-find-files-ignore-thing-at-point t)
    :config
    (setq helm-grep-git-grep-command (concat "/usr/intel/bin/" helm-grep-git-grep-command))
    (helm-adaptive-mode)
    (dired-async-mode))
#+END_SRC

*** evil
some hacks to make helm more evil compatible See
[[https://github.com/syl20bnr/spacemacs/issues/3700][syl20bnr/spacemacs#3700]]
#+BEGIN_SRC elisp
  (defun $helm-unprevent-minibuffer-escape ()
    (when helm-prevent-escaping-from-minibuffer
      (general-def 'motion
        [down-mouse-1] 'evil-mouse-drag-region)
      (general-def 'normal
        [mouse-2] 'mouse-yank-primary)))

  (defun $helm-prevent-minibuffer-escape ()
    (when helm-prevent-escaping-from-minibuffer
      (general-def 'motion [down-mouse-1] nil)
      (general-def 'normal [mouse-2] nil)))

  (add-hook 'helm-after-initialize-hook #'$helm-prevent-minibuffer-escape)
  (add-hook 'helm-cleanup-hook #'$helm-unprevent-minibuffer-escape)
#+END_SRC

*** files
ignore lockfiles and backups when looking through the filesystem
#+BEGIN_SRC elisp
  (csetq helm-boring-file-regexp-list
         (list "~" "#" (rx ".#" (1+ nonl))))
  (csetq helm-ff-skip-boring-files t)
#+END_SRC

Create a key dispatcher for commonly used commands
#+BEGIN_SRC elisp
  (with-eval-after-load 'helm
    (general-def '(helm-find-files-map
                   helm-read-file-map
                   helm-generic-files-map)
      :prefix ";"
      "b" 'helm-find-files-toggle-to-bookmark
      "c" 'helm-ff-run-copy-file
      "'" '$helm-ff-switch-to-shell
      "s" '$helm-ag-from-session
      "m" '$meld-from-helm-session
      "g" '$magit-from-helm-session
      "d" 'helm-ff-run-delete-file))
#+END_SRC

get helm history when writing a file
[[https://github.com/emacs-helm/helm/issues/2088#issuecomment-421999031][emacs-helm/helm#2088]]
#+BEGIN_SRC elisp
  (with-eval-after-load 'helm-mode
    (add-to-list 'helm-completing-read-handlers-alist '(write-file . helm-read-file-name-handler-1)))
#+END_SRC

*** dispatcher
these are functions that I often want to run, but normally have to
exit helm to call their keybindings. So we create wrapper thats lets
us call them from helm.
#+BEGIN_SRC elisp
  (defun $helm-ag-from-session ()
    "Launch `helm-ag' from within a helm session"
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       'helm-do-ag
       helm-ff-default-directory
       (let ((cand (helm-marked-candidates)))
         ;; if we have not marked anything we want to search the current directory
         (unless (equal (list (helm-get-selection))
                        cand)
           cand)))))

  (defun $magit-from-helm-session ()
    "run magit from a helm session"
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       '$magit-status-in-dir
       helm-ff-default-directory)))

  (defun $meld-from-helm-session ()
    "run meld from a helm session"
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       (lambda (paths)
         (async-start-process "Helm Meld" "meld" nil
                              (nth 0 paths)
                              (nth 1 paths)))
       (helm-marked-candidates))))

  (defun $helm-ff-switch-to-shell ()
    "Run switch to shell action from `helm-source-find-files'."
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       '$shell-pop
       helm-current-prefix-arg
       helm-current-buffer
       helm-ff-default-directory)))

  (defun $helm-copy-to-kill-ring ()
    "Copy selection or marked candidates to the kill ring.
  Note that the real values of candidates are copied and not the
  display values.
  If a file name, copy the full path unless C-u prefix is given."
    (interactive)
    (with-helm-alive-p
      (helm-run-after-exit
       (lambda (cands)
         (with-helm-current-buffer
           (kill-new (mapconcat
                      (lambda (c)
                        (format "%s" (if (and (null helm-current-prefix-arg)
                                              (stringp c)
                                              (not (file-remote-p c))
                                              (file-exists-p c))
                                         (file-truename c)
                                       c)))
                      cands "\n"))))
       (helm-marked-candidates))))
#+END_SRC

more convient keybindings for dispatcher functions as well as some
helm builtins
#+BEGIN_SRC elisp
  (with-eval-after-load 'helm
    (general-def helm-map
      "C-c y" '$helm-copy-to-kill-ring)
    (general-def '(helm-find-files-map helm-read-file-map helm-generic-files-map)
      "C-r"   'helm-find-files-history
      "C-c b" 'helm-find-files-toggle-to-bookmark
      "C-c c" 'helm-ff-run-copy-file
      "C-c '" '$helm-ff-switch-to-shell
      "C-c s" '$helm-ag-from-session
      "C-c C-s" '$helm-ag-from-session
      "C-c m" '$meld-from-helm-session
      "C-c g" '$magit-from-helm-session
      "C-c C-g" '$magit-from-helm-session))
#+END_SRC

*** swoop
#+BEGIN_SRC elisp
  (use-package helm-swoop
    :init
    (setq helm-swoop-split-with-multiple-windows t
          helm-swoop-speed-or-color t
          helm-swoop-candidate-number-limit 1000)
    :config
    (add-hook 'after-revert-hook 'helm-swoop--clear-cache)
    (general-def helm-swoop-edit-map
      "C-c C-c" 'helm-swoop--edit-complete
      "C-c C-k" 'helm-swoop--edit-cancel))

  (defun $helm-swoop (arg)
    "If called with a prefix argument, search for the symbol or
  region at point. If called with a numeric prefix argument, enable
  multiline searches"
    (interactive "P")
    (require 'helm-swoop)
    (let* ((prefix (equal arg '(4)))
           (helm-swoop-pre-input-function
            (if prefix
                (lambda ()
                  (if (region-active-p)
                      (buffer-substring (region-beginning)
                                        (region-end))
                    (or (thing-at-point 'symbol t) "")))
              (lambda () ""))))
      (helm-swoop :$multiline (unless prefix arg))))
#+END_SRC

*** ag
use the ag utility to search through files. The pcre package provides
us with PCRE compatible functions. PCRE is more intuitive then emacs
regex
#+BEGIN_SRC elisp
  (use-package helm-ag
    :custom
    (helm-ag-base-command "ag --nocolor --nogroup --search-zip")
    ($leader-set-key
      "sf" 'helm-do-ag
      "sF" '$helm-do-ag-region-or-symbol)
    (general-def
      "C-c s" '$helm-do-ag-current-dir
      "C-c C-s" '$helm-do-ag-current-dir))

  (defun $helm-do-ag-current-dir (arg)
    "search in the current directory with Ag"
    (interactive "P")
    (funcall (if arg '$helm-do-ag-region-or-symbol 'helm-do-ag) default-directory))

  (defun $helm-do-ag-region-or-symbol (&optional dir)
    "Search with `ag' with a default input."
    (interactive)
    (require 'helm-ag)
    (cl-letf* (((symbol-value 'helm-ag-insert-at-point) 'symbol)
               ;; make thing-at-point choosing the active region first
               ((symbol-function 'this-fn) (symbol-function 'thing-at-point))
               ((symbol-function 'thing-at-point)
                (lambda (thing)
                  (let ((res (if (region-active-p)
                                 (buffer-substring-no-properties
                                  (region-beginning) (region-end))
                               (this-fn thing))))
                    (when res (rxt-quote-pcre res))))))
      (helm-do-ag dir)))
#+END_SRC

*** git
helm-ls-git is an awesome package that lets me quickly operate on any
git controlled files in the current repo. for things like staging it
is faster then magit because I don't need to load a diff. This is
especially true for files that are in different directories but are
similar. In magit they are spaced out because they are not in the same
part of the hierarchy, so I have to stage one, wait, stage the next
one, wait, etc. With helm-ls-git I can just narrow the files and stage
or commit them all at once.

Also in my limited testing $helm-browse-project is faster at listing
files then projectile. I will have to see if that holds true for large
repos.
#+BEGIN_SRC elisp
  (use-package helm-ls-git
    :custom
    (helm-ls-git-default-sources '(helm-source-ls-git-status))
    (helm-ls-git-status-command 'magit-status-internal)
    :general
    (:definer 'leader
     "gj" 'helm-ls-git-ls
     "sg" 'helm-grep-do-git-grep
     "pf" '$helm-browse-project
     "pb" '$helm-project-buffers)
    (:prefix ";"
     :keymaps 'helm-ls-git-map
     "s" 'helm-ls-git-stage-files
     "u" 'helm-ls-git-unstage-files
     "c" 'helm-ls-git-stage-marked-and-commit))

  (defun $helm-browse-project (arg)
    "find files in current project with git ls"
    (interactive "P")
    (require 'helm-ls-git)
    (let ((helm-ls-git-default-sources '(helm-source-ls-git)))
      (helm-ls-git-ls arg)))

  (defun $helm-project-buffers (arg)
    "open buffers in the current project"
    (interactive "P")
    (require 'helm-ls-git)
    (let ((helm-ls-git-default-sources '(helm-source-ls-git-buffers)))
      (helm-ls-git-ls arg)))
#+END_SRC

*** org
use helm to quickly navigate org headings. We can also use this to
jump to a init header from anywhere.
#+BEGIN_SRC elisp
  ($leader-local-set-key
    :keymaps 'org-mode-map
    "j" 'helm-org-in-buffer-headings)

  (csetq helm-org-format-outline-path t)
#+END_SRC

use this function to jump to any part of the config, whether it is in
this file or not
#+BEGIN_SRC elisp
  (defun $helm-org-init-files-headings ()
    "Helm for init file headings."
    (interactive)
    (require 'helm-org)
    (let (helm-org-show-filename)
      (helm :sources (helm-source-org-headings-for-files
                      $emacs-init-files)
            :candidate-number-limit 99999
            :preselect (helm-org-in-buffer-preselect)
            :truncate-lines helm-org-truncate-lines
            :buffer "*helm org inbuffer*")))

  ($leader-set-key
    "fj" '$helm-org-init-files-headings)
#+END_SRC

*** navi
use helm for outshine navigation with navi
#+BEGIN_SRC elisp
  (use-package helm-navi
    :general
    (:definer 'leader
     :keymaps 'emacs-lisp-mode-map
     "j" 'helm-navi))
#+END_SRC

*** themes
switch themes using helm
#+BEGIN_SRC elisp
  (use-package helm-themes
    :general
    (:definer 'leader
     "T" 'helm-themes))
#+END_SRC

*** ediff
running ediff from helm is very convient. But the problem is that is
not reproducible. You have to reselect the files everytime, which is
time consuming. So we create a function to save the last ediff.
#+BEGIN_SRC elisp
  (defvar $ediff-targets nil
    "The last two files that were diffed")
  (defun $save-ediff-targets (&rest args)
    "Save the last two ediffed files"
    (setq $ediff-targets (car args)))
  (advice-add 'ediff-files-internal :filter-args #'$save-ediff-targets)

  (defun $run-last-ediff ()
    "Run ediff with the last used files"
    (interactive)
    (apply 'ediff-files-internal $ediff-targets))
  ($leader-set-key "fd" '$run-last-ediff)
#+END_SRC

** editing
*** general
make interprogram paste work correctly. don't update the primary when
in evil
#+BEGIN_SRC elisp
  (setq interprogram-paste-function 'x-cut-buffer-or-selection-value
        evil-kill-on-visual-paste nil
        select-enable-primary t)
  (fset 'evil-visual-update-x-selection 'ignore)
#+END_SRC

general editing configuration. We only want to use tabs in specific
major modes
#+BEGIN_SRC elisp
  (csetq indent-tabs-mode nil)
#+END_SRC

my filesystem generates regular backups, so having Emacs create
backups is redundant.
#+BEGIN_SRC elisp
  (setq make-backup-files nil)
#+END_SRC

some log files are *really* large, so don't warn about opening files
less the 500 MB
#+BEGIN_SRC elisp
  (csetq large-file-warning-threshold 500000000)
#+END_SRC

Only communists end sentences with two spaces.
#+BEGIN_SRC elisp
  (csetq sentence-end-double-space nil)
#+END_SRC

Give us some breathing room
#+BEGIN_SRC elisp
  (setq-default fill-column 80)
#+END_SRC

*** TAB key
Emacs has an interesting way of handling the tab key. Both <tab> and
C-i share the same terminal keycode. This means that in terminal
applications, using C-i is the equivalent of pressing tab. Emacs
distinguishes between the two by assigning C-i to =TAB=. under normal
circumstances, <tab> will be automatically translated to =TAB= (C-i)
before being dispatched. However this means that we can't use the C-i
binding in the GUI for anything other then tab. Evil provides the
ablitity to use C-i to jump to the next mark. So to get both C-i to
jump to the next mark and still retain our tab indent behavior, we
setup the following code. We remap the C-i key to the H-i (hyper)
keycode in the =input-decode-map=, then we bind =evil-jump-forward=.
So now pressing C-i will trigger the keycode for H-i, which is bound
to evil-jump-forward.
#+BEGIN_SRC elisp
  (general-def input-decode-map
    "C-i" "H-i"
    "C-[" "H-["
    "C-m" "H-m")
  (general-def 'normal
    "H-i" 'evil-jump-forward)
#+END_SRC

Use tab for completion if at a symbol
#+BEGIN_SRC elisp
  (setq tab-always-indent 'complete)
#+END_SRC

*** whitespace

use ws-butler to only fix trailing whitespace on lines that I
touch. That way it won't unnecessarily effect git diffs, but still
keeps me from being sloppy.
#+BEGIN_SRC elisp
  (use-package ws-butler
    :hook (org-mode prog-mode)
    :config
    (setq ws-butler-convert-leading-tabs-or-spaces t))
#+END_SRC

*always* add a final newline. some really stupid languages (looking at
you tcsh) require a final newline or the last line of a script never
gets executed.
#+BEGIN_SRC elisp
  (csetq require-final-newline t)
#+END_SRC

don't show me long lines in whitespace mode
#+BEGIN_SRC elisp
  (with-eval-after-load 'whitespace
    (delq 'lines whitespace-style))
#+END_SRC

whitespace managment keybindings
#+BEGIN_SRC elisp
  ($leader-set-key
    "tw" 'whitespace-mode
    "xd" 'delete-trailing-whitespace)
#+END_SRC

show empty lines at the end of files
#+BEGIN_SRC elisp
  (setq-default indicate-empty-lines t)
#+END_SRC

*** normalization
Outlook is stupid and tries to replace the normal accent characters
with nonascii versions. This can cause problems when copying from the
an email or word doc. The function below will replace the formating
with their ascii equiviments.
#+BEGIN_SRC elisp
  (defun $normalize-text (beg end)
    "normalize characters used in Microsoft formatting"
    (let* ((orig-text (buffer-substring beg end))
           (normalized-text
            (thread-last orig-text
              (replace-regexp-in-string "â€“" "--")
              (replace-regexp-in-string (rx (char "â€˜â€™")) "'")
              (replace-regexp-in-string (rx (char "â€œâ€")) "\""))))
      (unless (equal orig-text normalized-text)
        (save-excursion
          (goto-char beg)
          (delete-region beg end)
          (insert normalized-text)))))

  (defun $normalize-region (beg end)
    "normalzie the last paste, or if region is selected, normalize
  that region."
    (interactive "r")
    (if (region-active-p)
        (progn ($normalize-text beg end)
               (deactivate-mark))
      (apply #'$normalize-text (cl-sort (list (point) (mark t)) '<))))

  ($leader-set-key
    "xn" '$normalize-region)
#+END_SRC

*** keybindings
#+BEGIN_SRC elisp
  ($leader-set-key
    "xa" 'align
    "xr" 'align-regexp
    "xt" 'untabify
    "zq" 'quick-calc)
#+END_SRC

*** minibuffer
Use our next and previous commands to navigate minibuffer history
#+BEGIN_SRC elisp
  (general-def '(evil-ex-completion-map minibuffer-local-map)
    "C-j" 'next-complete-history-element
    "C-k" 'previous-complete-history-element)
#+END_SRC

#+BEGIN_SRC elisp
  (defun insert-current-file-name-at-point (&optional full-path)
    "Insert the current filename at point.
   With prefix argument, use full path."
    (interactive "P")
    (let* ((buffer (if (minibufferp)
                       (window-buffer (minibuffer-selected-window))
                     (current-buffer)))
           (filename (buffer-file-name buffer)))
      (if filename
          (insert (if full-path
                      (file-truename filename)
                    (file-name-nondirectory filename)))
        (error (format "Buffer %s is not visiting a file" (buffer-name buffer))))))

  (general-def minibuffer-local-map
    "H-i" #'insert-current-file-name-at-point)
#+END_SRC

*** narrowing
#+BEGIN_SRC elisp
  ($leader-set-key
    "n" '(:ignore t :wk "narrow")
    "nw" 'widen
    "nr" 'narrow-to-region
    "np" '$narrow-to-paragraph
    "nf" 'narrow-to-defun)

  (defun $narrow-to-paragraph ()
    "Narrow to the current evil paragraph"
    (interactive)
    (cl-destructuring-bind (beg . end)
        (bounds-of-thing-at-point 'evil-paragraph)
      (narrow-to-region beg end)))
#+END_SRC

*** save place
Return to the last point I was in a buffer
#+BEGIN_SRC elisp
  (use-package saveplace
    :defer 5
    :config
    (save-place-mode))
#+END_SRC
*** navigation
**** move where I mean
move me to the start of the line or start of code, based on heuristics
#+BEGIN_SRC elisp
  (use-package mwim
    :general
    (:states 'insert
     "C-e" 'mwim-end
     "C-a" 'mwim-beginning))
#+END_SRC

**** dumb jump
dumb jump uses regexp search to try and find the definition of a symbol
#+BEGIN_SRC elisp
  (use-package dumb-jump
    :general
    (:definer 'leader
     "J" 'dumb-jump-go))
#+END_SRC

**** avy
avy is an awesome jump to point package.
#+BEGIN_SRC elisp
  (use-package avy
    :init
    (setq avy-timeout-seconds 0.3)
    :general
    (:states '(motion normal)
     "s" 'avy-goto-char-timer))
#+END_SRC

**** easy motion
a evil motion package. by default the =F,f,T,t= bindings have buffer
scope, but that makes it too complex, so we will limit that to current
line only
#+BEGIN_SRC elisp
  (use-package evil-easymotion
    :general
    (:states '(normal visual)
     "f" 'evilem-motion-find-char
     "F" 'evilem-motion-find-char-backward
     "t" 'evilem-motion-find-char-to
     "T" 'evilem-motion-find-char-to-backward)
    ('normal
     "gs" '(:keymap evilem-map :package evil-easymotion)))
#+END_SRC

*** symbols
This pacakge highlights the symbol at point, and provides shortcuts to
interact with it when the cursor is over it
#+BEGIN_SRC elisp
  (use-package symbol-overlay
    :init
    ($leader-set-key
      "ii" 'symbol-overlay-put
      "ic" 'symbol-overlay-remove-all))
#+END_SRC

*** quick run
Quickly run the file you are working on. Use =C-u= to define the
arguments. Can also launch a repl for some languages
#+BEGIN_SRC elisp
  (use-package quickrun
    :general
    (:definer 'leader
     :keymaps '(python-mode-map sh-mode-map tcl-mode-map)
     "r" 'quickrun
     "R" 'quickrun-with-arg)
    :custom
    (quickrun-timeout-seconds 30))
#+END_SRC

*** yasnippet
provides snippets for adding complex blocks. use it with =M-/=
#+BEGIN_SRC elisp
  (use-package yasnippet
    :diminish
    :defer 3
    :config
    (let ((inhibit-message t))
      (yas-global-mode)))
  (use-package yasnippet-snippets
    :diminish
    :after yasnippet)
#+END_SRC

*** multiedit
mutliedit is a hybrid of evil-iedit-state and evil-mc.

#+BEGIN_SRC elisp
  (use-package evil-multiedit
    :custom
    (evil-multiedit-use-symbols t)
    ($leader-set-key
      "se" 'evil-multiedit-match-all)
    :general
    (:states 'visual
     "M-d" 'evil-multiedit-match-and-next
     "M-D" 'evil-multiedit-match-and-prev
     "C-M-D" 'evil-multiedit-restore
     "R" 'evil-multiedit-match-all)
    (:states 'normal
     "M-d" 'evil-multiedit-match-symbol-and-next
     "M-D" 'evil-multiedit-match-symbol-and-prev
     "R" 'evil-multiedit-match-all)
    (:states 'insert
     "M-d" 'evil-multiedit-toggle-marker-here)
    (:keymaps 'evil-multiedit-state-map
     "RET" 'evil-multiedit-toggle-or-restrict-region)
    (:keymaps '(evil-multiedit-state-map
                evil-multiedit-insert-state-map)
     "C-n" 'evil-multiedit-next
     "C-p" 'evil-multiedit-prev))
#+END_SRC

*** radix conversion

#+BEGIN_SRC elisp
  (use-package 0xc
    :general
    (:definer 'leader
     "xc" '0xc-kill))
#+END_SRC

*** regex

ample regexps lets us define =rx= short hand that we can use to make
writing regexp clearer.
#+BEGIN_SRC elisp
  (defvar $rx-defaults
    '((spc (any " \t"))
      (spc+ (1+ spc))
      (spc* (0+ spc))
      (-> (1+ any))
      (^ bol)
      (file (1+ (any alnum "-_/.~")))
      (symbol (1+ (any alnum "_")))
      (nums (1+ num))
      (fp (1+ (any num "."))))
    "modified rx forms that are really usefull")

  (use-package ample-regexps
    :commands $rx
    :config
    (define-arx $rx $rx-defaults))
#+END_SRC

pcre2el lets us convert between Emacs regexp and PCRE. very
usefull for debugging.
#+BEGIN_SRC elisp
  (use-package pcre2el
    :commands reb-change-syntax)
#+END_SRC

*** tramp
Add the default intel binary path the remote path so tramp can find up
to date tools
#+BEGIN_SRC elisp
  (with-eval-after-load 'tramp
    (add-to-list 'tramp-remote-path "/usr/intel/bin"))
#+END_SRC

by default tramp tries to parse =/etc/ssh2/hostkeys= for the hostkey
names but this file does not exist. This leads to an error everytime
we try to get the hostkey names. I tried just defining the completion
functions after tramp was loaded, something is still setting it back
to the defaults. So I created a function to be called as part of helm
that will set the completion functions right before tramp tries to use
them. I would love to remove this advice and only set it once.
#+BEGIN_SRC elisp
  (advice-add 'helm-ff--tramp-hostnames :before
              (defun $helm-set-tramp-host-names ()
                "parse the ssh2_config if hostnames are not set"
                (unless  (equal '("ssh" (tramp-parse-hosts "~/.ssh2/ssh2_config"))
                                (assoc "ssh" tramp-completion-function-alist))
                  (cl-loop for method in '("ssh" "scp" "rsync")
                           do (tramp-set-completion-function
                               method '((tramp-parse-hosts "~/.ssh2/ssh2_config")))))))
#+END_SRC

*** projects
I used to use projectile, but I found that it was just too slow and
invasive. I am able to replace that package with simpler function from
counsel and git as well as the specialized functions below.
#+BEGIN_SRC elisp
  (defun $project-buffers (arg &optional dir)
    (interactive "P")
    (let ((root (cdr (project-current
                      nil (or dir default-directory))))
          ivy-use-virtual-buffers
          buffers)
      (if (null root)
          (user-error "no project root found")
        (setq root (file-truename root))
        (setq buffers (all-completions
                       "" #'internal-complete-buffer
                       (lambda (buf) ($buffer-in-project buf root arg))))
        (ivy-read (if arg "project buffers: "
                    "open project files: ")
                  buffers
                  :keymap ivy-switch-buffer-map
                  :action #'ivy--switch-buffer-action
                  :matcher #'ivy--switch-buffer-matcher))))

  (defun $get-project-root (buffer)
    (thread-last
        (or (buffer-local-value 'buffer-file-truename buffer)
            (file-truename (buffer-local-value 'default-directory buffer)))
      (project-current nil)
      (cdr)))

  (defun $buffer-in-project (buf project include-dirs)
    (let* ((buffer (cdr buf)))
      (and (not (string-match-p "\\*" (buffer-name buffer)))
           (not (file-remote-p (buffer-local-value 'default-directory buffer)))
           (or include-dirs
               (buffer-local-value 'buffer-file-name buffer))
           (equal ($get-project-root buffer)
                  project))))

  (with-eval-after-load 'ivy
    (ivy-add-actions 'counsel-find-file
                     '(("b" (lambda (x)
                              ($project-buffers ivy-current-prefix-arg x))
                        "buffers")))
    (ivy-add-actions '$project-buffers
                     '(("k" ivy--kill-buffer-action "kill"))))

  (general-def "C-x C-b" '$project-buffers)
#+END_SRC

**** bookmars
#+BEGIN_SRC elisp
  (defvar $project-bookmarks
    '(("hier define" "target/*/collage/work/*/gen/tb_specs/soc_ip_hier_define.sv")
      ("collage output" "target/*/collage/source")
      ("espf output" "target/*/espfmodel/mdf_s_v_0")
      ("espflist" "verif/tests/espflist/*master.espflist"))
    "Alist of project bookmarks to a list of potential paths. File
    paths are wildcard expanded.")

  (defun $read-common-file (file-list &optional prompt)
    "read a file amoung common paths"
    (unless file-list (user-error "no files found"))
    (if (cdr file-list)
        (let ((parent (f-common-parent file-list)))
          (f-expand (completing-read
                     (or prompt "Select file: ")
                     (mapcar (lambda (x) (f-relative x parent)) file-list))
                    parent))
      (car file-list)))

  (defun $jump-project-bookmark ()
    "Jump to a project bookmark."
    (interactive)
    (let* ((bookmark (completing-read "Jump to bookmark: " (mapcar 'car $project-bookmarks)))
           (paths (cdr (assoc bookmark $project-bookmarks)))
           (file-list (cl-loop for path in paths
                               for files = (file-expand-wildcards (expand-file-name path ($model-root)))
                               if files
                               return files))
           (file (condition-case-unless-debug nil
                     ($read-common-file file-list)
                   (error (user-error "No file found for '%s'" bookmark)))))
      (if (file-directory-p file)
          (find-file (read-file-name "Find file: " file))
        (find-file file))))

  ($leader-set-key
    "pj" '$jump-project-bookmark)
#+END_SRC

*** parens
packages to help manage parens
#+BEGIN_SRC elisp
  (use-package rainbow-delimiters
    :hook prog-mode)

  (use-package paren
    :straight nil
    :demand t
    :after prog-mode
    :custom
    (evil-show-paren-range 3)
    (show-paren-delay 0)
    :config
    (show-paren-mode))
#+END_SRC

**** matching parens off screen
A function taken from [[https://with-emacs.com/posts/editing/show-matching-lines-when-parentheses-go-off-screen/][here]] that will use an overlay to echo the
matching paren line. I am just afraid that this will lead to issues
when looking at really large JSON file and the function tries to back
track through the whole file to find a match.
#+BEGIN_SRC elisp
  ;; we will call `blink-matching-open` ourselves...
  (remove-hook 'post-self-insert-hook
               #'blink-paren-post-self-insert-function)
  ;; this still needs to be set for `blink-matching-open` to work
  (setq blink-matching-paren 'show)

  (let ((ov nil)) ; keep track of the overlay
    (advice-add
     #'show-paren-function
     :after
     (defun show-paren--off-screen+ (&rest _args)
       "Display matching line for off-screen paren."
       (when (overlayp ov)
         (delete-overlay ov))
       ;; check if it's appropriate to show match info,
       ;; see `blink-paren-post-self-insert-function'
       (when (and (overlay-buffer show-paren--overlay)
                  (not (or cursor-in-echo-area
                           executing-kbd-macro
                           noninteractive
                           (minibufferp)
                           this-command))
                  (and (not (bobp))
                       (memq (char-syntax (if (eq evil-state 'insert)
                                              (char-before)
                                            (or (char-after) 41)))
                             '(?\) ?\$)))
                  (= 1 (logand 1 (- (point)
                                    (save-excursion
                                      (forward-char -1)
                                      (skip-syntax-backward "/\\")
                                      (point))))))
         ;; rebind `minibuffer-message' called by
         ;; `blink-matching-open' to handle the overlay display
         (cl-letf (((symbol-function #'minibuffer-message)
                    (lambda (msg &rest args)
                      (let ((msg (apply #'format-message msg args)))
                        (setq ov (display-line-overlay+
                                  (window-start) msg )))))
                   ((point) (if (eq evil-state 'insert)
                                (point)
                              (1+ (point)))))
           (blink-matching-open))))))

  (defun display-line-overlay+ (pos str &optional face)
    "Display line at POS as STR with FACE.
  FACE defaults to inheriting from default and highlight."
    (let ((ol (save-excursion
                (goto-char pos)
                (make-overlay (line-beginning-position)
                              (line-end-position)))))
      (overlay-put ol 'display str)
      (overlay-put ol 'face
                   (or face '(:inherit default :inherit highlight)))
      ol))

  (setq show-paren-style 'parenthesis
        show-paren-when-point-in-periphery t)
#+END_SRC

** files

don't ask me to revert files that I have not changed.
#+BEGIN_SRC elisp
  (csetq revert-without-query `(,(rx (1+ nonl))))
#+END_SRC

*** crux
a collection of usefull file and buffer function from prelude.
#+BEGIN_SRC elisp
  (use-package crux
    :general
    (:definer 'leader
     "fR" 'crux-rename-file-and-buffer
     "fD" 'crux-delete-file-and-buffer)
    ("C-c e" 'crux-eval-and-replace))
#+END_SRC

*** functions
collection of functions stolen from spacemacs
#+BEGIN_SRC elisp
  (defun $find-user-config-file ()
    "Edit the org file we use for config, in the current window."
    (interactive)
    (find-file-existing (expand-file-name "emacs.org" user-emacs-directory)))

  (defun $async-delete-file (target &optional targets no-prompt)
    "delete a file or directory by moving it to a tmp location and
  then removing in the background"
    (interactive "D")
    (when (and (file-exists-p (or target (car targets)))
               (or no-prompt
                   (y-or-n-p "really delete file(s)?")))
      (cl-loop for file in (or targets (list target))
               do (let ((tmp-file (make-temp-name
                                   (concat
                                    (string-remove-suffix "/" file)
                                    ".del."))))
                    (async-start
                     (lambda ()
                       (rename-file file tmp-file)
                       (if (file-directory-p tmp-file)
                           (delete-directory tmp-file 'recursive)
                         (delete-file tmp-file)))
                     (lambda (_result)
                       (message (format "file %s deleted successfully" file))))))))

  (defun $copy-file ()
    "Copy the current file and create any directories along the way"
    (interactive)
    (let* ((destination (read-file-name "Write File: "))
           (dir (file-name-directory destination)))
      (unless (file-exists-p dir)
        (make-directory dir 'parents))
      (when (file-directory-p destination)
        (setq destination (expand-file-name
                           (file-name-nondirectory (buffer-file-name))
                           destination)))
      (setq doom-modeline-project-root nil)
      (write-file destination 'confirm)))

  ($leader-set-key
    "f" '(:ignore t :wk "files")
    "fc" '$copy-file
    "fe" '$find-user-config-file)
#+END_SRC

open file in clipboard. Usually something I copied from an
email. automatically add the tramp header if from a different site
#+BEGIN_SRC elisp
  (defun $normalize-file-name (file)
    "This functions does 3 things.
  1. update MODEL_ROOT to the current model
  2. automatically add remote prefix if required
  3. Remove problematic formating from files"
    ;; set MODEL_ROOT if variable is present in file name
    (when-let ((root (and (string-match-p "MODEL_ROOT" file)
                          (vc-git-root default-directory))))
      (--> root
           (file-truename it)
           (string-remove-suffix "/" it)
           (string-remove-prefix (or (file-remote-p it) "") it)
           (setenv "MODEL_ROOT" it)))
    ;; add remote url if required
    (let* ((current-site (getenv "EC_SITE"))
           (target-site (if (string-match (rx bos "/nfs/" (group (1+ word))) file)
                            (match-string 1 file)
                          current-site))
           (remote-url (if (or (equal target-site "site")
                               (equal current-site target-site))
                           ""
                         (format "/%s:%s:" tramp-default-method target-site))))
      (when (and (not (string-suffix-p "/" file))
                 (file-directory-p file))
        (cl-callf concat file "/"))
      ;; remove problematic formatting from files
      (thread-last file
        (concat remote-url)
        (replace-regexp-in-string (rx (1+ (any space "\""))) "")
        (replace-regexp-in-string (rx (1+ "/")) "/")
        (replace-regexp-in-string "\"" "")
        (string-remove-prefix "./")
        (replace-regexp-in-string "$ENV" "$")
        (substitute-in-file-name))))

  (defun $get-chars-at-point (chars)
    (let ((beg (save-excursion
                 (skip-chars-backward chars)
                 (point)))
          (end (save-excursion
                 (skip-chars-forward chars)
                 (point))))
      (cons beg end)))

  (defun $get-path-at-point ()
    "Get the filepath at point.
  This includes remote paths and enviroment variables."
    (let* ((bounds ($get-chars-at-point "-{}[:alnum:]$/._~\""))
           (beg (car bounds))
           (end (cdr bounds))
           (path (buffer-substring-no-properties beg end)))
      (if (save-excursion
            (goto-char beg)
            (or (looking-back ($rx "cfg::MODEL_ROOT()" spc* "." spc*) (line-beginning-position))
                (looking-back (regexp-quote "$::env(MODEL_ROOT)") (line-beginning-position))))
          (concat "$MODEL_ROOT" path)
        path)))

  (defun $counsel-initial-input (file)
    (unless (file-directory-p file)
      (concat (file-name-nondirectory file) "\\_>")))

  (defun $open-file-in-clipboard ()
    "Open the file name in the clipboard"
    (interactive)
    (find-file ($normalize-file-name (string-trim (current-kill 0)))))

  (defun $find-file-at-point ()
    "A better replacement for `find-file-at-point'"
    (interactive)
    (let* ((file ($normalize-file-name
                  (concat (file-remote-p default-directory)
                          ($get-path-at-point))))
           (context (buffer-substring-no-properties (line-beginning-position)
                                                    (line-end-position 2)))
           (line (when (string-match ($rx (any alnum "\"'")
                                          (or ":"
                                              (: "," (* (any " \n")))
                                              (: (opt ",") " line ")
                                              (: ", Line: "))
                                          (group nums))
                                     context)
                   (match-string 1 context))))
      (if (file-exists-p file)
          (progn (find-file file)
                 (when line
                   (goto-line (string-to-number line))))
        (user-error (format "File %s does not exists" file)))))

  (defun $file-at-point-exists ()
    "Check if file at point exists."
    (interactive)
    (if (file-exists-p
         ($normalize-file-name
          (concat (file-remote-p default-directory)
                  ($get-path-at-point))))
        (message "File exists")
      (message "File does not exist!")))

  (defun $change-model ()
    "Open a model in workspace"
    (interactive)
    (let ((default-directory
            (expand-file-name "~/workspace/")))
      (counsel-find-file)))

  (defun $goto-repo ()
    (interactive)
    (let ((default-directory "~/.emacs.d/straight/repos/"))
      (counsel-find-file)))

  ($leader-set-key
    "fo" '$open-file-in-clipboard
    "fw" '$change-model
    "fa" '$file-at-point-exists
    "fd" '$goto-repo)
  (general-def '(normal visual motion)
    "gf" '$find-file-at-point)
#+END_SRC

start a find file session from project root
#+BEGIN_SRC elisp
  (defun $find-file-project-root ()
    "start a find files session from project root"
    (interactive)
    (require 'helm-files)
    (if-let ((root (vc-git-root default-directory))
             (default-directory root))
        (counsel-find-file)
      (user-error "no root found for current file")))

  (general-def
    "C-x C-p" '$find-file-project-root)
#+END_SRC

*** find similar file
search up the directory stack looking for files that only differ from
the current file by one directory. This is useful for mulitply
instantiated files that use the same path with a different parent. For example

foo/bar/baz.txt
foo/bat/baz.txt
foo/ban/baz.txt

would all be considered similar files.
#+BEGIN_SRC elisp
  (defun $switch-to-similar-file ()
    "find a file of the same name with only one directory different"
    (interactive)
    (require 'f)
    (if-let ((file (buffer-file-name))
             (parts (f-split file))
             (head (butlast parts 2))
             (dir (car (last parts 2)))
             (tail (last parts))
             (other-files (or ($find-similar-file head dir tail)
                              ($find-similar-file head dir
                                                  (list (concat "*" ($file-name-extension (car tail)))))))
             (common-parent (f-common-parent (cons file other-files)))
             (unique-file (completing-read "select other file: "
                                           (mapcar (lambda (f)
                                                     (string-remove-prefix common-parent f))
                                                   other-files))))
        (find-file (f-join common-parent unique-file))
      (cond ((buffer-file-name) (user-error "No similar file found"))
            (t (user-error "buffer not visitng a file")))))

  (defun $file-name-extension (file)
    (when (string-match (rx "." (1+ nonl) eos) file)
      (match-string 0 file)))

  (defun $find-similar-file (head dir tail)
    "search up the directory path for paths that very by only one
  directory pointing to the same file name"
    ;; anything above 5 depth is not worth searching becase we are out
    ;; of the disk
    (when (>= (length head) 5)
      (let* ((parent (apply 'f-join head))
             (child (apply 'f-join tail))
             (rootp (file-exists-p (f-join parent ".git")))
             (orig (car (file-expand-wildcards
                         (f-join parent dir child))))
             (paths (delete orig (file-expand-wildcards
                                  (f-join parent "*" child))))
             (valid-paths (cl-remove-if (lambda (f) (file-equal-p f orig)) paths)))
        (unless rootp
          (or valid-paths
              ($find-similar-file (butlast head) (car (last head)) (cons dir tail)))))))

  (defun $find-file-other-model ()
    "find the same file in a different model in the same directory"
    (interactive)
    (let* ((file (buffer-file-name))
           (root (vc-git-root file))
           (path (string-remove-prefix root file))
           (workspace (f-parent root))
           (models (file-expand-wildcards (concat workspace "/*/" path)))
           (model (completing-read "Select Model: "
                                   (mapcar (lambda (f)
                                             (thread-last f
                                               (string-remove-suffix (concat "/" path))
                                               (string-remove-prefix (concat workspace "/") )))
                                           models))))
      (find-file (format "%s/%s/%s" workspace model path))))

  ($leader-set-key
    "fs" '$switch-to-similar-file
    "fm" '$find-file-other-model)
#+END_SRC

*** dired
we don't need so many dired confirmation prompts
#+BEGIN_SRC elisp
  (setq dired-no-confirm t
        wdired-allow-to-change-permissions t
        dired-listing-switches "-alh"
        dired-dwim-target t
        dired-auto-revert-buffer t)

  (general-def dired-mode-map
    "C-c C-e" 'wdired-change-to-wdired-mode)

  (with-eval-after-load 'dired-aux
    (add-to-list 'dired-compress-file-suffixes '("\\.gtar\\'" ".tar" nil)))
#+END_SRC

*** recentf
#+BEGIN_SRC elisp
  (use-package recentf
    :init
    (setq recentf-max-saved-items 500
          recentf-auto-cleanup "11:00pm"))
#+END_SRC

*** path check
#+BEGIN_SRC elisp
  (defface path-check-exists
    '((t :inherit 'diff-refine-added :foreground "black"))
    "Face used to highlight paths that exist")
  (defface path-check-nonexistent
    '((t :inherit 'diff-refine-removed :foreground "black"))
    "Face used to highlight paths that exist")

  (defvar path-check-font-lock-keywords
    `((,($rx (group "/" alpha file))
       1 (if (file-exists-p (match-string 1))
             'path-check-exists
           'path-check-nonexistent)
       prepend)))

  (define-minor-mode path-check-mode
    "check if paths in file exisit"
    nil nil nil
    (if path-check-mode
        (font-lock-add-keywords nil path-check-font-lock-keywords)
      (font-lock-remove-keywords nil path-check-font-lock-keywords))
    (font-lock-flush))
#+END_SRC

*** midnight mode
midnight mode is mode to automatically kill old buffers at midnight
based on a set of rules. We want to follow all of the default rules
execept for compilation buffers. We keep those because they provide
clear status.
#+BEGIN_SRC elisp
  (midnight-mode)

  (defun $never-kill-compilation-buffers (buffer)
    (with-current-buffer buffer
      (derived-mode-p 'compilation-mode)))

  (add-to-list 'clean-buffer-list-kill-never-regexps '$never-kill-compilation-buffers)

  (add-hook 'midnight-hook 'recentf-save-list)
#+END_SRC

*** auto-insert
auto insert is a builtin templating library. It is not very easy to
use, but thankfully my usecases are very simple.
#+BEGIN_SRC elisp
  (use-package auto-insert
    :straight nil
    :defer 5
    :init
    (setq auto-insert-query nil
          auto-insert-alist
          '(((emacs-lisp-mode . "Emacs Lisp header")
             nil ";;; -*- lexical-binding: t; -*-\n\n" _)
            (("\\.p[lm]\\'" . "Perl shebang")
             nil "#!/usr/intel/pkgs/perl/5.14.1/bin/perl\n\n"
             "use strict;\n" "use warnings;\n\n" _)
            ((python-mode . "Python shebang")
             nil "#!/usr/intel/bin/python3.6.3a\n\n" _)))
    :config
    (auto-insert-mode))
#+END_SRC

*** winner
#+BEGIN_SRC elisp
  (winner-mode)
  (defhydra $winner ()
    "Hydra for winner-mode"
    ("u" winner-undo "undo")
    ("r" winner-redo "redo"))
  (with-eval-after-load 'ace-window
    (add-to-list 'aw-dispatch-alist '(?u $winner/winner-undo))
    (add-to-list 'aw-dispatch-alist '(?J aw-switch-buffer-other-window "Switch Buffer Other Window")))
#+END_SRC

*** ediff
I like to keep everything in one frame. I am not a mutli-window
heathen from 2003. We also want to restore the window config after we
are done with ediff.
#+BEGIN_SRC elisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally
        ediff-diff-options "-w")

  (setq-default ediff-ignore-similar-regions t)

  (winner-mode)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

*** vdiff
Vdiff is based on vim-diff. Rather then using native elisp for the
diffing algorithm it uses an external backend like git or diff. This
means that we can use better diffing algorithms like patient or
historgram that are not part of ediff. Also this supports auto
folding, which looks nice.
#+BEGIN_SRC elisp
  (use-package vdiff
    :general
    (:definer 'leader
     "fvf" 'vdiff-files
     "fvb" 'vdiff-buffers)
    (:keymaps 'vdiff-mode-map
     "C-c" '(:keymap vdiff-mode-prefix-map :package vdiff))
    :custom
    (vdiff-diff-algorithm 'git-diff-patience))
#+END_SRC

** git

don't ask about following symlinks
#+BEGIN_SRC elisp
  (csetq vc-follow-symlinks t)
#+END_SRC

only look for git registered files
#+BEGIN_SRC elisp
  (csetq vc-handled-backends '(Git))
#+END_SRC

A simple wrapper to call git
#+BEGIN_SRC elisp
  (defun $git-command (&rest cmd)
    (string-trim-right
     (shell-command-to-string
      (concat (executable-find "git") " " (string-join cmd " ")))))
#+END_SRC

*** vc-git
Emacs built in version control
#+BEGIN_SRC elisp
  (autoload (function vc-git-root) "vc-git")
#+END_SRC

*** magit
magit is the best git porcelain that exists, so far as I can tell. we
need to set the git version to a newer version because the default at
intel is not supported. We have to require transient first or else we
get weird errors in magit.
#+BEGIN_SRC elisp
  (use-package transient :demand t)
  (use-package magit
    :general
    ("C-x g" 'magit-status
     "C-x M-g" 'magit-dispatch
     "C-c M-g" 'magit-file-dispatch)
    (magit-diff-mode-map
     "SPC" nil)
    :custom
    (magit-git-executable "/usr/intel/pkgs/git/2.12.0/bin/git")
    :init
    ($leader-set-key
      "g" '(:ignore t :wk "git"))
    (evil-ex-define-cmd "git" 'magit-status)
    ;; make transient not take the width of the whole frame
    (setq transient-display-buffer-action
          '(display-buffer-below-selected))
:config
    (add-hook 'dired-mode-hook 'magit-file-mode))
#+END_SRC

the trash at Intel is in the home disk, which is only 100 MB.
Therefore we must delete without moving to trash.
#+BEGIN_SRC elisp
  (csetq magit-delete-by-moving-to-trash nil)
#+END_SRC

improve [[https://magit.vc/manual/magit/Performance.html][performance]] by only reverting buffers in the local repo
#+BEGIN_SRC elisp
  (setq auto-revert-buffer-list-filter 'magit-auto-revert-repository-buffer-p)
#+END_SRC

expanding the diffs can often take too long
#+BEGIN_SRC elisp
  (csetq magit-diff-expansion-threshold 20)
#+END_SRC

show both added and removed whitespace
#+BEGIN_SRC elisp
  (csetq magit-diff-paint-whitespace-lines 'both)
#+END_SRC

start the commit message editor in insert state
#+BEGIN_SRC elisp
  (with-eval-after-load 'with-editor
    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

calling =magit-status= on a whole IP can be very time consumuing.
Often I am just trying to look at a single directory, and this gives
me the power to do that.

#+BEGIN_SRC elisp
  (defun $magit-status-in-dir (dir)
    "limit magit status to directory"
    (interactive "D")
    (require 'magit)
    (let* ((root (vc-git-root dir))
           (dir (list (file-relative-name dir root)))
           (magit-status-mode-hook
            (cons (if (equal (car dir) "./")
                      '$magit-clear-diff-args-if-not-dir-local
                    (lambda () (setq-local magit-diff-section-file-args dir)))
                  magit-status-mode-hook)))
      (magit-status-internal root)))

  (defun $magit-status-current-dir ()
    "run magit in current dir"
    (interactive)
    ($magit-status-in-dir default-directory))

  (defun $magit-clear-diff-args-if-not-dir-local ()
    (unless (assq 'magit-diff-section-file-args dir-local-variables-alist)
      (setq-local magit-diff-section-file-args nil)))

  (advice-add 'magit-status :around
              (defun $magit-remove-diff-args (fn &rest args)
                (let ((magit-status-mode-hook (cons '$magit-clear-diff-args-if-not-dir-local
                                                    magit-status-mode-hook)))
                  (apply fn args))))

  ($leader-set-key
    "gd" '$magit-status-current-dir
    "gs" 'magit-status)
  (general-def
    "C-c g" '$magit-status-current-dir)
#+END_SRC

**** org
When visiting a line from a diff in magit, expand point.
#+BEGIN_SRC elisp
  (defun $expand-org-mode-entry ()
    "When opening an org-mode file, show the current entry and all
  headings that it is contained in."
    (when (derived-mode-p 'org-mode)
      (org-reveal '(4))))

  (add-hook 'magit-diff-visit-file-hook '$expand-org-mode-entry)
#+END_SRC

*** smerge
smerge mode is a built in package that lets one quickly resolve merge
conflicts. The following hydra will be triggered automatically when
resolving merge conflicts in magit. stolen for [[https://github.com/alphapapa/unpackaged.el#hydra][here]].
#+BEGIN_SRC elisp
  (use-package smerge-mode
    :straight nil
    :config
    (defun $enable-smerge-keys ()
      (when smerge-mode
        (revert-buffer)
        ($smerge-keys/body)))
    (defhydra $smerge-keys
      (:color pink :hint nil :post (smerge-auto-leave))
      "
  ^Move^       ^Keep^               ^Diff^                 ^Other^
  ^^-----------^^-------------------^^---------------------^^-------
  _n_ext       _b_ase               _<_: upper/base        _C_ombine
  _p_rev       _u_pper              _=_: upper/lower       _r_esolve
  ^^           _l_ower              _>_: base/lower        _x_: kill current
  ^^           _a_ll                _R_efine
  ^^           _RET_: current       _E_diff
  "
      ("n" smerge-next)
      ("p" smerge-prev)
      ("b" smerge-keep-base)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("RET" smerge-keep-current)
      ("<" smerge-diff-base-upper)
      ("=" smerge-diff-upper-lower)
      (">" smerge-diff-base-lower)
      ("R" smerge-refine)
      ("E" smerge-ediff)
      ("C" smerge-combine-with-next)
      ("r" smerge-resolve)
      ("x" smerge-kill-current)
      ("ZZ" (lambda ()
              (interactive)
              (save-buffer)
              (bury-buffer))
       "Save and bury buffer" :color blue)
      ("q" nil "cancel" :color blue))
    :hook (magit-diff-visit-file . $enable-smerge-keys ))
#+END_SRC

*** evil
#+BEGIN_SRC elisp
  (use-package evil-magit
    :demand t
    :after magit
    :general
    (magit-mode-map
     "SPC" nil))

  (use-package git-timemachine
    :general
    (:definer 'leader
     "gt" 'git-timemachine))
#+END_SRC

*** git gutter
git gutter uses the the margin to display the git status. the frige
package uses the fringe instead of the margin. This means that it
won't conflict with linum-mode. However since I don't need linum mode
I can probably remove git gutter fringe all together. All the that it
would offer me is that I could display of the left side, which I may
want to do when I enable flycheck.
#+BEGIN_SRC elisp
  (use-package git-gutter
    :defer 3
    :init
    (setq git-gutter:diff-option "-w")
    (defhydra $git-hunk (:exit nil)
      ("n" git-gutter:next-hunk "next")
      ("N" git-gutter:previous-hunk "prev")
      ("p" git-gutter:previous-hunk "prev")
      ("r" git-gutter:revert-hunk "revert")
      ("s" git-gutter:stage-hunk "stage"))
    ($leader-set-key
      "gr" '$git-hunk/git-gutter:revert-hunk
      "gh" '$git-gutter-show-hunk
      "gs" '$git-hunk/git-gutter:stage-hunk
      "gn" '$git-hunk/git-gutter:next-hunk
      "gN" '$git-hunk/git-gutter:previous-hunk)
    :config
    (push `((nil . ,(rx (opt "$git-hunk/") "git-gutter:")) . (nil . "")) which-key-replacement-alist)
    (global-git-gutter-mode))

  (use-package git-gutter-fringe
    :diminish
    :demand t
    :after git-gutter)
#+END_SRC

these changes the behavior of the git gutter popup so that I can quit
with =q= and the window is selected.
#+BEGIN_SRC elisp
  (advice-add 'git-gutter:update-popuped-buffer :after
              (defun $git-gutter-window-quit (&rest _)
                (when-let ((buffer (get-buffer git-gutter:popup-buffer)))
                  (with-current-buffer buffer
                    (general-def 'normal local
                      "q" 'quit-window)))))

  (defun $git-gutter-show-hunk ()
    (interactive)
    (git-gutter:popup-hunk)
    (pop-to-buffer git-gutter:popup-buffer))
#+END_SRC

since git-gutter is so slow over tramp we want to disable it from
automatically refreshing when we switch to a tramp buffer.
#+BEGIN_SRC elisp
  (with-eval-after-load 'git-gutter
    (ad-disable-advice 'quit-window 'after 'git-gutter:quit-window)
    (ad-activate 'quit-window)
    (ad-disable-advice 'switch-to-buffer 'after 'git-gutter:switch-to-buffer)
    (ad-activate 'switch-to-buffer)
    (general-advice-add '(switch-to-buffer quit-window)
                        :after (defun $git-gutter-reload (&rest _)
                                 (when (and (not (file-remote-p default-directory))
                                            git-gutter-mode)
                                   (git-gutter)))))
#+END_SRC

**** comment text object
a text object to get the current hunk
#+BEGIN_SRC elisp
  (with-eval-after-load 'evil
    (evil-define-text-object evil-inner-hunk (count &optional _beg _end _type)
      (let ((hunk (git-gutter:search-here-diffinfo git-gutter:diffinfos)))
        (list (git-gutter:line-point (git-gutter-hunk-start-line hunk))
              (git-gutter:line-point (1+ (git-gutter-hunk-end-line hunk)))))))

  (general-def 'inner
    "u" 'evil-inner-hunk)
#+END_SRC

*** functions
some general purpose git functions that make life easier in my
particular work enviroment

commit all generated files from IPGen. This is much faster then try to
open magit and doing it manually
#+BEGIN_SRC elisp
  (defun $git-commit-ipgen-output ()
    "Stage ipgen output and commit it"
    (interactive)
    (if (equal 0 (call-process "git" nil nil nil "diff-index" "--quiet" "--cached" "HEAD"))
        (let ((models (file-expand-wildcards (expand-file-name "tools/ipgen/*/output" (vc-git-root default-directory))))
              (msg (read-string "output files commit message: " "Update IPGen output for ")))
          (message "staging output files...")
          (cl-loop for model in models
                   do ($git-clean-corekits model)
                   and do ($git-command "add --all" model))
          (message "committing output files...")
          ($git-command "commit -m" (format "\"%s\"" msg))
          (message "done")
          (when (eq major-mode 'magit-status-mode)
            (magit-refresh-buffer)))
      (user-error "index not clean")))

  (defun $git-clean-corekits (dir)
    "Remove all corekits that are unchanged.
  CoreKits are binary files that include things like the timestamp,
  which means they change after every run. But we can look at the
  build.summary file to see if there are any actual changes. If the
  build summary file has changed then we know the corekit has
  changed as well. This will prevent all the corekits from
  polluting our diffs."
    (interactive "D")
    (let* ((default-directory (expand-file-name "dft/tools/collage/reports/" dir)))
      (cl-loop for build in (split-string ($git-command "ls-files -m"))
               do ($git-command
                   "add" (concat "../coreKit/"
                                 (file-name-base
                                  (file-name-base build))
                                 ".coreKit")))
      ($git-command "checkout -- ../coreKit/")))

  (defun $git-discard-ipgen-output ()
    "Discard all IPGen output"
    (interactive)
    (let ((models (file-expand-wildcards (expand-file-name "tools/ipgen/*/output" (vc-git-root default-directory)))))
      (message "discarding output files...")
      (cl-loop for model in models
               do ($git-command "checkout HEAD --" model)
               and do ($git-command "clean --force" model))
      (message "done")
      (when (eq major-mode 'magit-status-mode)
        (magit-refresh-buffer))))
#+END_SRC


I don't like to commit to my github repos using my work credentials,
but I can't use my private credentials on my work repos. therefore I
set ~useconfigonly = true~ so that I have to set the credentials for
every repo. This hook will automatically set my credentials based on
where the repo is located
#+BEGIN_SRC elisp
  (defun $git-set-user ()
    "set the git user based on where the repo is located."
    (when (and (equal "tjhinckl" (nth 2 (file-attributes (vc-git-root default-directory) 'string)))
               (equal "" (shell-command-to-string "git config --local user.name")))
      (shell-command-to-string
       (apply 'format "git config --local user.name %s && git config --local user.email %s"
              ($user-credentials)))
      (message "setting git user credentials")))

  (add-hook 'magit-status-mode-hook '$git-set-user)
#+END_SRC

** shell

#+BEGIN_SRC elisp
  (csetq shell-file-name "/usr/intel/bin/bash")
#+END_SRC

*** comint
comint is the generic backend for REPL's and shells. We are giving it
more bash-it style behavior where I can enter some text and then use
the previous command to match against it. Also we can use ivy to
search through the command history. also whenever we try to go to the
previous command it will automatically move us the the command line.
#+BEGIN_SRC elisp
  (use-package comint
    :straight nil
    :general
    (:keymaps 'comint-mode-map
     :states '(normal insert visual)
     "C-k" 'comint-previous-matching-input-from-input
     "C-j" 'comint-next-matching-input-from-input
     "C-S-k" 'comint-previous-prompt
     "C-S-j" 'comint-next-prompt
     [remap comint-dynamic-list-input-ring] 'counsel-shell-history)
    :custom
    (comint-input-ring-size 1000)
    (comint-scroll-to-bottom-on-input t)
    (comint-prompt-read-only t))

  (defun $goto-cmd-line (&rest _)
    (goto-char (point-max)))

  (general-advice-add '(comint-next-matching-input-from-input
                        comint-previous-matching-input-from-input) :before '$goto-cmd-line)
#+END_SRC

*** shell
these are utility functions used to setting up the Emacs shell.
#+BEGIN_SRC elisp
  (use-package shell
    :straight nil
    :gfhook #'company-mode)

  (defvar $dir-history nil
    "previous shell directories")
  (make-variable-buffer-local '$dir-history)

  (defun $select-shell-history ()
    "Select a previous directory using completing read"
    (interactive)
    (goto-char (point-max))
    (insert (concat "cd " (string-remove-prefix (or (file-remote-p default-directory) "")
                                                (completing-read "directory:" $dir-history)))))

  (general-def shell-mode-map
    "C-c C-j" '$select-shell-history)

  (defun $track-shell-directory (str)
    "use the proc filesytem to get the current directory.
    Works on remote shells as well if `shx' and `shx-cmd-set-pid' are used. The
    remote shell will need to echo it's PID in the rc file in the form of `shx'
    markup."
    (if shell-dirtrack-mode
        (when (string-match (rx bol "Directory: " (group (+ (any alnum "-_/.")))) str)
          (let ((dir (match-string 1 str)))
            (cd dir)
            (unless (equal dir (car $dir-history))
              (push dir $dir-history))))
      (when (string-match-p comint-prompt-regexp str)
        (when-let ((remote (or (file-remote-p default-directory) ""))
                   (dir (-some->> (local-env-get-shell-pid)
                                  (format "/proc/%s/cwd")
                                  (concat remote)
                                  file-symlink-p))
                   (full-dir (concat remote dir)))
          (when (file-directory-p full-dir)
            (cd full-dir)
            (unless (equal dir (car $dir-history))
              (push dir $dir-history))))))
    str)

  (with-eval-after-load 'shell
    (modify-syntax-entry ?= "." shell-mode-syntax-table)
    (modify-syntax-entry ?> "." shell-mode-syntax-table)
    (modify-syntax-entry ?> "." shell-mode-syntax-table))

  (defun $shell-mode-hook ()
    (shell-dirtrack-mode 0)
    (setq-local comint-prompt-regexp ($rx bol (or "â•°â”€â†’"
                                                  (: symbol "(" nums ")%")
                                                  (: symbol "@" symbol ":" file "(" nums ")>")
                                                  (: "bash-" num "." num "$")
                                                  (: symbol ">"))
                                          " "))
    (setq-local evil-search-wrap nil)
    (local-env-mode)
    (add-hook 'comint-preoutput-filter-functions '$track-shell-directory nil 'local))
  (add-hook 'shell-mode-hook '$shell-mode-hook)
#+END_SRC

generic wrapper function that can be called from other code. currently
used in helm
#+BEGIN_SRC elisp
  (defun $shell-pop (arg buffer dir)
    "shell-pop to current buffers directory or dir"
    (if (and (boundp 'shell-pop-last-shell-buffer-name)
             (equal (buffer-name buffer)
                    shell-pop-last-shell-buffer-name))
        (shell-pop--cd-to-cwd dir)
      (let ((default-directory dir))
        (shell-pop arg))))
#+END_SRC


*** Ansi term
#+BEGIN_SRC elisp
  (add-hook 'term-mode-hook
            (defun $disable-yas ()
              (setq yas-dont-activate t)))
#+END_SRC

*** shx
shx mode allows us to call emacs lisp functions from within the
builtin shell, gives us the best of both worlds.
#+BEGIN_SRC elisp
  (use-package shx
    :diminish
    :hook shell-mode
    :general
    (:keymaps 'shx-mode-map
     "C-<return>" '$shx-send-input-or-copy-path))

  (defun $shx-send-input-or-copy-path ()
    "send command or copy path at point"
    (interactive)
    (if (shx-point-on-input-p)
        (shx-send-input)
      (let ((path ($get-path-at-point)))
        (goto-char (point-max))
        (insert path))))
#+END_SRC

*** shell pop
pop up the shell in my current directory
#+BEGIN_SRC elisp
  (use-package shell-pop
    :general
    (:definer 'leader
     "'" 'shell-pop
     "\"" '$shell-pop-root))

  (defun $shell-pop-root (arg)
    "open a shell in the project root"
    (interactive "P")
    (let ((default-directory (vc-git-root default-directory)))
      (shell-pop arg)))
#+END_SRC

only send a cd command if we are not already in that directory
#+BEGIN_SRC elisp
  (advice-add 'shell-pop--cd-to-cwd
              :before-until
              (defun $shell-in-cwd-p (cwd)
                (file-equal-p default-directory cwd)))
#+END_SRC

my current bash prompt is 2 lines, so we always scroll one line down
so that I can see the whole thing. probably need to make this code
smarter
#+BEGIN_SRC elisp
  (advice-add 'shell-pop--cd-to-cwd
              :after
              (defun $scroll-shell-pop (_)
                (scroll-down 1)))
#+END_SRC

fix [[https://github.com/kyagi/shell-pop-el/issues/51][kyagi/shell-pop-el#51]]
#+BEGIN_SRC elisp
  (add-to-list 'shackle-rules `(,(rx "*shell*") :regexp t :same t))
#+END_SRC

This advice endeavors to fix two problems.
1. It can be frustrating when you run a long running command in a
   shell and then later try to pop shell and it will fail because the
   shell is not available. This code will always grab an available
   shell or create a new one if no shell is available.
2. When on a remote machine, shell-pop will try and cd a local shell
   to a remote path, which does not work. This code will instead open
   a new shell on remote machines.
#+BEGIN_SRC elisp
  (defun $shell-available (name)
    "Check if the specified shell NAME is either uncreated or an
  available shell. An available shell is defined as one which is
  waiting at the prompt line."
    (let ((buffer (get-buffer name)))
      (or (not (buffer-live-p buffer))
          (and (process-live-p (get-buffer-process buffer))
               (with-current-buffer buffer
                 (save-excursion
                   (goto-char (point-max))
                   (goto-char (line-beginning-position))
                   (let ((prompt (string-remove-suffix
                                  (rx eos) comint-prompt-regexp)))
                     (looking-back prompt
                                   (- (point) (length prompt))))))))))

  (defun $get-available-shell (func arg)
    "Return the first available shell that can be used for shell
  pop."
    (let* ((remote (file-remote-p default-directory 'host))
           (type (format "*%sshell*" (if remote (concat remote ":") ""))))
      (cl-loop for i in (cons (or arg shell-pop-last-shell-buffer-index)
                              (number-sequence 1 10))
               for shell = (replace-regexp-in-string
                            (rx "*" eos)
                            (format "-%d*" i) type)
               until ($shell-available shell)
               finally (let ((shell-pop-internal-mode-buffer type))
                         (funcall func i)))))

  (advice-add 'shell-pop--switch-to-shell-buffer :around '$get-available-shell)
#+END_SRC

*** native completion
Use the native completion in shells
#+BEGIN_SRC elisp
  (use-package native-complete
    :straight
    (:host github :repo "CeleritasCelery/emacs-native-shell-complete")
    :compdef shell-mode
    :capf native-complete-at-point
    :company company-native-complete
    :init
    (with-eval-after-load 'shell
      (native-complete-setup-bash))
    :custom
    (native-complete-style-regex-alist
     `(("â•°â”€â†’ " . bash)
       (,(rx (or "% " (: (+ (in "0-9")) "> ") ")> ")) . zsh)
       ("[A-Z]+> " . tab))))
#+END_SRC

*** async file completion
I wrote this package to do async file completion. This is especially
true when using this in a shell, where you don't want to block the ui
while typing.
#+BEGIN_SRC elisp
  (use-package company-async-files
    :after company
    :straight
    (:host github :repo "CeleritasCelery/company-async-files")
    :config
    (unless (memq 'company-async-files company-backends)
      (setq company-backends (append '(company-capf company-async-files) (cdr company-backends))))
    (add-to-list 'company-backends 'company-async-files))
#+END_SRC

*** argument completion
provide auto completion for the command line arguments of the command
at point.
#+BEGIN_SRC elisp
  (use-package company-arguments
    :straight
    (:host github :repo "CeleritasCelery/company-arguments"))
#+END_SRC

*** local env
These packages will be loaded by shell-mode. They let me share the
environment of my local process with the buffer. very useful.
#+BEGIN_SRC elisp
  (use-package local-env
    :straight
    (:host github
     :repo "CeleritasCelery/local-env-mode"
     :files ("local-env.el"))
    :init
    (setq local-env-capture-variables '("MODEL_ROOT"
                                        "STF_SPFSPEC"
                                        "TAP_SPFSPEC"
                                        "TAP2STF_MAP_FILE"
                                        "XWEAVE"
                                        "XWEAVE_REPO_ROOT"
                                        "SPF_ROOT"
                                        "SPF_PERL_LIB"
                                        "LD_LIBRARY_PATH"
                                        "DFT_REPO_ROOT"))
    ($leader-local-set-key
      :keymaps 'shell-mode-map
      "e" 'local-env-capture))

  (use-package company-env
    :straight
    (:host github
     :repo "CeleritasCelery/local-env-mode"
     :files ("company-env.el")))

  (use-package company-command
    :straight
    (:host github
     :repo "CeleritasCelery/local-env-mode"
     :files ("company-command.el")))
#+END_SRC

** web

*** eww
Eww is the =Emacs Web Wowser= and allows basic views of webpages.

A small package to jump to links in eww buffer.
#+BEGIN_SRC elisp
  (use-package eww-lnum
    :demand t
    :after eww
    :general
    ('normal
     eww-mode-map
     "J" 'eww-lnum-follow))
#+END_SRC

** compilation
packages that assist in compiling and building code
#+BEGIN_SRC elisp
  (use-package compile
    :straight nil
    :general
    (:definer 'leader
     "o" '(:ignore t :wk "compile")
     "oc" '$compile
     "ob" 'bman-cmd/body
     "oi" '$run-ipgen
     "ot" '$run-turnin
     "os" '$run-simregress
     "oj" '$compilation-jump-to-buffer)
    :custom
    (compilation-always-kill t)
    :config
    ($load-literate-file "src/compilation")
    (general-unbind compilation-mode-map "SPC"))
#+END_SRC

*** alert
the alert package lets us creat notification for any event we want. In
this case we are intersted in knowing when a compliation finishes or
stalls.
#+BEGIN_SRC elisp
  (use-package alert
    :init
    (setq alert-default-style 'fringe))
#+END_SRC

* Org
:PROPERTIES:
:VISIBILITY: children
:END:
** todos and general
#+BEGIN_SRC elisp
  (use-package org
    :straight (:type built-in)
    :gfhook #'org-indent-mode #'$org-truncate-lines
    :general
    (:definer 'leader
     :keymaps 'org-mode-map
     "," 'org-edit-special
     "g" '$org-navigate/body)
    (:definer 'leader
     "ol" 'org-store-link)
    :custom
    (org-lowest-priority ?D)
    (org-enforce-todo-dependencies t)
    (org-hide-emphasis-markers t)
    (org-startup-indented t)
    (org-todo-keywords '((sequence "NEXT(n)" "TODO(t)" "WAIT(w@)" "PENDING(p)" "|" "DONE(d)")
                         (sequence "|" "CANCELED(c@)")))
    (org-priority-faces '((?A . (:foreground "OrangeRed"))
                          (?B . (:foreground "yellow3"))
                          (?C . (:foreground "ForestGreen"))))
    :init
    (defun $org-truncate-lines ()
      (let ((inhibit-message t))
        (toggle-truncate-lines)))
    :config
    (general-advice-add '(org-insert-subheading org-insert-todo-subheading)
                        :before
                        (defun $org-insert-subheading (_arg)
                          (let ((undo-inhibit-record-point t))
                            (end-of-line))))
    (add-hook 'org-capture-mode-hook 'evil-insert-state)
    (general-def org-mode-map
      "C-c C-<return>" 'org-insert-subheading
      "C-c C-SPC" 'org-insert-todo-subheading)
    (add-to-list 'org-structure-template-alist
                 '("el" "#+BEGIN_SRC elisp\n?\n#+END_SRC" "")))
#+END_SRC

*** inherit priority
inherit the priority of the parent heading and make sure the default state is always todo
#+BEGIN_SRC elisp
  (defun $org-insert-header-priority (_arg &optional force)
    (when (org-at-heading-p)
      (let ((parent-priority (save-excursion (if force
                                                 (org-up-heading-safe)
                                               (org-backward-heading-same-level 1))
                                             (org-show-priority))))
        (org-todo "TODO")
        (cl-loop do (org-priority (if (string< (org-show-priority) parent-priority) 'up 'down))
                 until (equal parent-priority (org-show-priority))))))

  (advice-add 'org-insert-todo-heading :after '$org-insert-header-priority)
#+END_SRC

** navigation
#+BEGIN_SRC elisp
  (defhydra $org-navigate ()
    "navigate through org headers"
    ("J" org-next-visible-heading "next heading")
    ("K" org-previous-visible-heading "prev heading")
    ("j" org-forward-element "foward")
    ("k" org-backward-element "back")
    ("h" org-up-element "up")
    ("l" org-down-element "down")
    ("q" nil)
    ("<tab>" org-cycle "cycle"))
#+END_SRC

** functions
#+BEGIN_SRC elisp
  (defun $org-show-current-heading-tidily ()
    "Show next entry, keeping other entries closed."
    (interactive)
    (if (save-excursion (end-of-line) (outline-invisible-p))
        (progn (org-show-entry) (outline-show-children))
      (outline-back-to-heading)
      (unless (and (bolp) (org-at-heading-p))
        (org-up-heading-safe)
        (outline-hide-subtree)
        (error "Boundary reached"))
      (org-overview)
      (org-reveal t)
      (org-show-entry)
      (outline-show-children)))
  (advice-add 'counsel-org-goto :after '$org-show-current-heading-tidily)

  (defun $org-archive-done-tasks ()
    "move tasks that are completed to the archive file."
    (interactive)
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (outline-previous-heading)))
     "/DONE" 'file)
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (outline-previous-heading)))
     "/CANCELED" 'file))

  ($leader-local-set-key
    :keymaps 'org-mode-map
    "a" '$org-archive-done-tasks
    "h" '$org-show-current-heading-tidily)

  (defun $org-smart-return ()
    "if in a list return should add a new item. If the item is
  blank, we want to break out of the list and delete the blank
  item"
    (interactive)
    (if (org-at-item-p)
        (if (and (looking-back (rx space) (- (point) 1))
                 (memq (- (point) (org-in-item-p))
                       (number-sequence 1 3)))
            ;; If at a blank item, delete it
            (progn
              (beginning-of-line)
              (kill-line)
              (org-return))
          ;; If at a non-blank item, insert a new item
          (org-return)
          (org-insert-item))
      ;; If not at item, normal return
      (org-return)))
  (general-def '(insert normal) org-mode-map
    "<ret>" '$org-smart-return
    "RET" '$org-smart-return)

  (defun $org-procrastinate (arg)
    "shedule the selected item for tomrrow, effectivly removing
  it from todays agenda."
    (interactive "P")
    (let ((fn (if (eq major-mode 'org-agenda-mode)
                  'org-agenda-schedule
                'org-schedule)))
      (defvar org-state)
      (let ((org-state "DONE"))
        (require 'org-clock)
        (org-clock-out-if-current))
      (funcall fn arg "+1d")))
  ($leader-local-set-key
    :keymaps '(org-mode-map org-agenda-mode-map)
    "s" '$org-procrastinate)
#+END_SRC

** agenda
#+BEGIN_SRC elisp
  (csetq org-agenda-todo-ignore-scheduled 'future
         org-agenda-tags-todo-honor-ignore-options t
         org-agenda-dim-blocked-tasks 'invisible
         org-agenda-files "~/org/.agenda-files")

  ($leader-set-key
    "a" 'org-agenda)
  (general-def org-agenda-mode-map "o" 'org-agenda-log-mode)
#+END_SRC

The default cursor movement requires one press per hierarchy level.
Don't ask me why, but I have never found it useful. It just makes
everything more annoying. So we disable it.
#+BEGIN_SRC elisp

  (defun $org-agenda-next-visual-line ()
    (interactive)
    (evil-next-visual-line)
    (org-agenda-do-context-action))
  (defun $org-agenda-prev-visual-line ()
    (interactive)
    (evil-previous-visual-line)
    (org-agenda-do-context-action))

  (add-hook 'org-agenda-mode-hook
            (defun $org-agenda-visual-lines ()
              (general-def 'motion org-agenda-mode-map
                "j" '$org-agenda-next-visual-line
                "k" '$org-agenda-prev-visual-line))
            'append)
#+END_SRC

** projects
projects allow to me to manage progess and see what items are stuck
#+BEGIN_SRC elisp
  (csetq org-stuck-projects
         '("/PROJ"
           ("TODO")
           nil ""))
#+END_SRC

** refile
this allows me to quickly move headers around files based on these
refile targets. we enable caching because we do not expect these files
to change outside of Emacs.
#+BEGIN_SRC elisp
  (csetq org-refile-use-cache t)
#+END_SRC

since I am using helm, it makes the most sense to show the whole
outline path instead of trying to refile in steps.
#+BEGIN_SRC elisp
  (csetq org-refile-use-outline-path 'file
         org-outline-path-complete-in-steps nil)
#+END_SRC

** clock
I am trying to always be clocked into a task. Not so much so that I
can see how I am using my time, though that is useful, more just to
keep me on task.
#+BEGIN_SRC elisp
  (use-package org-clock
    :straight nil
    :init
    ($leader-set-key
      "og" 'org-clock-goto
      "oo" 'org-clock-out)
    ($leader-local-set-key
      :keymaps 'org-mode-map
      "i" 'org-clock-in
      "o" 'org-clock-out)
    ($leader-local-set-key
      :keymaps 'org-agenda-mode-map
      "i" 'org-agenda-clock-in
      "o" 'org-agenda-clock-out))
#+END_SRC

*** mru
Easily clock into most-recently-used clocks
#+BEGIN_SRC elisp
(use-package org-mru-clock
  :general
  (:definer 'leader
   "of" 'org-mru-clock-in))
#+END_SRC

** export
org has the awesome functionality to export org markup to HTML. My
most common use case is to write an email in an org capture buffer and
then export that to HTML and insert it into outlook. Therefore we are
going to set our defaults based on that use case. For other exports we
are going to have to override these variables explicitly

don't add section numbers
#+BEGIN_SRC elisp
  (setq org-export-with-section-numbers nil)
#+END_SRC

don't add a table of contents
#+BEGIN_SRC elisp
  (setq org-export-with-toc nil)
#+END_SRC

only make something a subscript if we had braces around
it. i.e. make 5_{4} a subscript but not 5_4. Otherwise we end up
with subscripts anytime we don't markup a variable name.
#+BEGIN_SRC elisp
  (setq org-export-with-sub-superscripts '{})
#+END_SRC

include a priority element when exporting todos
#+BEGIN_SRC elisp
  (setq org-export-with-priority t)
#+END_SRC

preserve line breaks when exporting. This makes the exported format
closer to my markup, which keeps unwated suprises
#+BEGIN_SRC elisp
  (setq org-export-preserve-breaks t)
#+END_SRC

don't use the default preamble. We are creating our own css preamble
and we don't want the default one interfering
#+BEGIN_SRC elisp
  (setq org-html-postamble nil)
#+END_SRC

I program on a dark background because I am not heathen. But this
means that when we use the default inline CSS for syntax highlighting
we get really hard to read colors on a white background like email. So
instead org will just define css elements for the different syntax
elements and our =email.css= can define the colors for those. that way
we always have good colors for reading on white background regardless
of our theme.
#+BEGIN_SRC elisp
  (setq org-html-htmlize-output-type 'css)
#+END_SRC

create a custom HTML preamble that includes our default CSS to make
things more clean and modern. load it after the export libraries are
loaded so it does not effect startup time.
#+BEGIN_SRC elisp
  (with-eval-after-load 'ox-html
    (setq org-html-head
          (concat
           "<style type=\"text/css\">\n"
           "<!--/*--><![CDATA[/*><!--*/\n"
           (with-temp-buffer
             (insert-file-contents
              "~/org/org-html-themes/styles/email/css/email.css")
             (buffer-string))
           "/*]]>*/-->\n"
           "</style>\n")))
#+END_SRC

A simple function to export the current buffer as HTML and put it in
the clipboard
#+BEGIN_SRC elisp
  (defun $org-export-buffer ()
    "Export the current org email and copy it to the clipboard"
    (interactive)
    (defvar org-export-show-temporary-export-buffer)
    (let (org-export-show-temporary-export-buffer)
      (org-html-export-as-html)
      (with-current-buffer "*Org HTML Export*"
        (kill-new (buffer-string)))
      (message "HTML copied to clipboard")))

  (defun $export-code-region (beg end)
    "Export the current region as formatted HTML"
    (interactive "r")
    (let ((region (buffer-substring-no-properties beg end))
          (mode (string-remove-suffix "-mode" (symbol-name major-mode))))
      (with-temp-buffer
        (insert "#+BEGIN_SRC " mode "\n")
        (insert region "\n")
        (insert "#+END_SRC\n")
        ($org-export-buffer))))

  ($leader-set-key
    "xe" '$export-code-region)
#+END_SRC

The built-in version of =htmlize= does not support exporting code
blocks
#+BEGIN_SRC elisp
  (use-package htmlize)
#+END_SRC

** capture
#+BEGIN_SRC elisp
  (use-package org-capture
    :straight nil
    :init
    ($leader-set-key
      "c" 'org-capture)
    ($leader-local-set-key
      :definer 'minor-mode
      :keymaps 'org-capture-mode
      "e" '$org-export-buffer)
    :config
    (setq org-default-notes-file (expand-file-name "notes.org" org-directory)
          org-default-todo-file (expand-file-name "todo.org" org-directory)
          org-default-email-file (expand-file-name "email.org" org-directory)
          org-default-journal-file (expand-file-name "journal.org" org-directory)
          org-default-meeting-file (expand-file-name "meeting.org" org-directory)
          org-coding-problem-file (expand-file-name "personal/daily-coding-problems.org" org-directory)
          org-capture-templates
          (mapcar (lambda (x) (append x '(:empty-lines 1)))
                  '(("t" "Todo" entry (file org-default-todo-file)
                     "* TODO [#C] %?\n")
                    ("l" "Todo Link" entry (file org-default-todo-file)
                     "* TODO [#C] %?\n %i\n %a")
                    ("s" "Scheduled TODO" entry (file org-default-todo-file)
                     "* TODO [#C] %?\n  SCHEDULED: %^T\n")
                    ("T" "Todo from Clipboard" entry (file org-default-todo-file)
                     "* TODO [#C] %?\n%c")
                    ("n" "Note" entry (file org-default-notes-file)
                     "* %?")
                    ("N" "Note with Clipboard" entry (file org-default-notes-file)
                     "* %?\n   %c")
                    ("i" "Interupt" entry (file org-default-todo-file)
                     "* TODO [#C] %?\n" :clock-in t :clock-keep t)
                    ("j" "Journal" entry (file org-default-journal-file)
                     "* %<%a %b %e, %l:%M> -  %?")
                    ("d" "Daily Coding Problem" entry (file org-coding-problem-file)
                     "* TODO Problem #%($problem-number)\n%c%?")
                    ("m" "Meeting" entry (file org-default-meeting-file)
                     "* %?" :clock-in t :clock-resume t)))))

  (defun $problem-number ()
    (with-current-buffer (find-file-noselect org-coding-problem-file)
      (save-excursion
        (goto-char (point-max))
        (org-previous-visible-heading 1)
        (if (re-search-forward (rx (+ digit)) (line-end-position) t)
            (number-to-string
             (1+ (string-to-number (match-string-no-properties 0))))
          "0"))))
#+END_SRC

** tags
#+BEGIN_SRC elisp
  (csetq org-tags-column 0
         org-fast-tag-selection-single-key t)
#+END_SRC

** links
there is no good function to copy a link in org mode, so we override
the default open link behavior
#+BEGIN_SRC elisp
  (defun $org-copy-url ()
    "in my current setup, the builtin browswer does not
  work, so I copy links and paste them into chrome."
    (let ((context (org-element-context)))
      (when (member (org-element-property :type context)
                    '("http" "https"))
        (message "copied org link: %s"
                 (kill-new (org-element-property :raw-link context))))))


  (add-hook 'org-open-at-point-functions '$org-copy-url)
#+END_SRC

follow links with org return
#+BEGIN_SRC elisp
  (setq org-return-follows-link t)
#+END_SRC

** editing

*** auto capitalize
Auto capitlization is a really handy, especially since we can
customize it for any keyword we want.
#+BEGIN_SRC elisp
  (use-package auto-capitalize
    :hook org-mode)

  (setq auto-capitalize-predicate
        (defun $auto-captialize-predicate ()
          (if (eq major-mode 'org-mode)
              (not (org-babel-where-is-src-block-head))
            t)))
#+END_SRC

*** flyspell
Use flyspell to check our spelling in real time
#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'with-editor-mode-hook 'flyspell-mode)
#+END_SRC

*** company
Use company-ispell to provide spelling auto complete
#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook
            (defun $enable-company-spell ()
              (setq-local company-backends '((company-ispell company-capf company-dabbrev)))
              (setq-local company-frontends '(company-preview-frontend))
              (company-mode)))
#+END_SRC

** font
Use a proportional font for org mode because it is more readable
#+BEGIN_SRC elisp
  (use-package org-variable-pitch
    :hook (org-mode . org-variable-pitch-minor-mode)
    :init
    (set-face-attribute 'variable-pitch nil :font "Source Sans Pro" :height 130)
    (setq org-variable-pitch-fixed-font "Source Code Pro")
    :config
    (set-face-attribute 'org-variable-pitch-face nil :height 120))
#+END_SRC

** src blocks
#+BEGIN_SRC elisp
  (use-package org-src
    :straight nil
    :gfhook #'$org-src-lexical-bindings
    :custom
    (org-src-fontify-natively t)
    (org-src-window-setup 'current-window)
    (org-src-tab-acts-natively t)
    (org-babel-default-header-args:emacs-lisp '((:lexical . "yes"))))

  (defun $org-src-lexical-bindings ()
        (setq-local lexical-binding t))
#+END_SRC

exit in normal state
#+BEGIN_SRC elisp
  (general-advice-add '(org-edit-src-exit org-edit-src-abort) :after 'evil-normal-state)
#+END_SRC

*** babel
Babel is way to execute source code from within blocks.
#+BEGIN_SRC elisp
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages '((perl . t)
                                 (shell . t)
                                 (python . t)
                                 (emacs-lisp . t))))
#+END_SRC

** evil
#+BEGIN_SRC elisp
  (use-package evil-org
    :hook org-mode
    :init (add-hook 'org-insert-heading-hook 'evil-insert-state)
    :config
    (general-def 'normal 'org-mode-map
      "[[" '$org-headings/org-previous-visible-heading
      "]]" '$org-headings/org-next-visible-heading))

  (defhydra $org-headings (:exit nil)
    ("[" org-previous-visible-heading  "prev")
    ("]" org-next-visible-heading "next"))

  (use-package evil-org-agenda
    :straight nil
    :commands evil-org-agenda-set-keys
    :hook (org-agenda-mode . evil-org-agenda-set-keys))

  (defun $org-todo-or-evil-t ()
    "change the org todo state or evil's till operator"
    (interactive)
    (if (org-at-heading-p)
        (org-todo)
      (evilem-motion-find-char-to)))

  (general-def 'normal org-mode-map
    "t" '$org-todo-or-evil-t)
#+END_SRC

** noter
Org noter is a fantastic package that makes it easy to keep synced
notes with a document.
#+BEGIN_SRC elisp
  (use-package org-noter
    :general
    ('motion
     doc-view-mode-map
     "i" 'org-noter-insert-note))
#+END_SRC

** visuals
These packages are used to make org mode look better and take
advantage of unicode
#+BEGIN_SRC elisp
  (use-package org-bullets
    :hook org-mode)

  (use-package org-fancy-priorities
    :diminish
    :hook org-mode)
#+END_SRC

* Languages
:PROPERTIES:
:VISIBILITY: children
:END:
** General

make scripts executable on save
#+BEGIN_SRC elisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** flycheck
#+BEGIN_SRC elisp
  (use-package flycheck
    :init
    ($leader-set-key
      "tf" 'flycheck-mode)
    :general
    (:keymaps 'flycheck-error-list-mode-map
     "q" 'quit-window)
    :config
    (add-to-list 'shackle-rules '(flycheck-error-list-mode :select t)))

  (defhydra $flycheck (:exit nil)
    "navigate by flycheck errors"
    ("n" flycheck-next-error "next")
    ("p" flycheck-previous-error "prev")
    ("N" flycheck-previous-error "prev")
    ("l" flycheck-list-errors "list" :exit t))

  ($leader-set-key
    "l" '$flycheck/body)
#+END_SRC

these are warning about not unquoted expansions, but I feel like I am
usually aware enough to know when that is going to be a problem
#+BEGIN_SRC elisp
  (csetq flycheck-shellcheck-excluded-warnings '("SC2086" "SC2046"))
#+END_SRC

*** company
I don't want to use return for completion because that often
interferces with just regular typing. So i have gotten in the habit of
just using =C-l=
#+BEGIN_SRC elisp
  (use-package company
    :general
    (:keymaps 'company-active-map
     "RET" nil
     [return] nil
     "C-l" 'company-complete-selection)
    (:definer 'leader
     "tc" 'company-mode)
    :hook '(prog-mode org-mode ielm-mode)
    :custom
    (company-idle-delay 0.2)
    (evil-collection-company-use-tng nil)
    (company-dabbrev-downcase nil)
    (company-require-match nil)
    (company-dabbrev-code-ignore-case t)
    (company-dabbrev-ignore-case t)
    (company-backends '(company-capf
                        (company-dabbrev-code company-keywords)
                        company-dabbrev))
    :config
    (defun $company-select-prev-or-comint-match-input (&optional _)
      "Disable company mode when when we are selecting a previous
  prompt in shell mode"
      (when (and (eq major-mode 'shell-mode)
                 (eq company-selection 0))
        (company-abort)
        (call-interactively 'comint-previous-matching-input-from-input)))
    (advice-add 'company-select-previous :before-until #'$company-select-prev-or-comint-match-input))

  (with-eval-after-load 'company-dabbrev-code
    (add-to-list 'company-dabbrev-code-modes 'shell-mode))
#+END_SRC

collect usage statistics and filter candidates based on that
#+BEGIN_SRC elisp
  (use-package company-statistics
    :demand t
    :after company
    :config
    (company-statistics-mode))
#+END_SRC

helm company provides a helm interface to helm completion
#+BEGIN_SRC elisp
  (use-package helm-company
    :init
    :general
    (:keymaps '(company-mode-map company-active-map)
     "C-/" 'helm-company))
#+END_SRC

** elisp

*** general
#+BEGIN_SRC elisp
  (use-package elisp-mode
    :straight nil
    :init
    ($leader-local-set-key
      :keymaps 'emacs-lisp-mode-map
      "ee" 'eval-last-sexp
      "eb" 'eval-buffer
      "er" 'eval-region
      "ef" 'eval-defun))
#+END_SRC

*** ielm
ielm is an emacs lisp repl. We are going to patch the function so that
it will split the current window instead of replacing it. See
[[https://github.com/wasamasa/shackle/issues/33][wasamasa/shackle#33]]
#+BEGIN_SRC elisp
  ($leader-local-set-key
    :keymaps 'emacs-lisp-mode-map
    "'" 'ielm)

  (add-to-list 'shackle-rules `("*ielm*" :custom ,($shacklize display-buffer-below-selected) :select t))

  (el-patch-feature ielm)
  (with-eval-after-load 'ielm
    (el-patch-defun ielm ()
      "Interactively evaluate Emacs Lisp expressions.
  Switches to the buffer `*ielm*', or creates it if it does not exist.
  See `inferior-emacs-lisp-mode' for details."
      (interactive)
      (let (old-point)
        (unless (comint-check-proc "*ielm*")
          (with-current-buffer (get-buffer-create "*ielm*")
            (unless (zerop (buffer-size)) (setq old-point (point)))
            (inferior-emacs-lisp-mode)))
        (el-patch-swap (pop-to-buffer-same-window "*ielm*")
                       (display-buffer  "*ielm*"))
        (when old-point (push-mark old-point)))))
#+END_SRC

*** prettify symbols
make things look a litle nicer. we have to "cycle"
=prettify-symbols-mode= because our prog-mode hook enables it and
therefore it won't process any changes to =prettify-symbols-alist=
unless we turn it back on.
#+BEGIN_SRC elisp
  (defun $prettify-cons ()
    "make cons cells and lambda better formatted in elisp"
    (add-to-list 'prettify-symbols-alist '("lambda" . ?Î»))
    (add-to-list 'prettify-symbols-alist '("." . ?â€¢))
    (prettify-symbols-mode -1)
    (prettify-symbols-mode 1)
    (setq-local prettify-symbols-compose-predicate
                (defun $prettify-symbols-handle-dot (start end match)
                  (if (equal "." match)
                      (prettify-symbols-default-compose-p start end match)
                    ($prettify-symbols-all-p start end match)))))

  (add-hook 'emacs-lisp-mode-hook '$prettify-cons)
#+END_SRC

*** page breaks
make page breaks easier to see
#+BEGIN_SRC elisp
  (use-package page-break-lines
    :hook (emacs-lisp-mode help-mode))
#+END_SRC

*** indent
never have to worry about tab indenting again.
#+BEGIN_SRC elisp
  (use-package aggressive-indent
    :straight
    (:fork "CeleritasCelery/aggressive-indent-mode")
    :hook emacs-lisp-mode)
#+END_SRC

fix indentation of plists so that all properties align. From
#+BEGIN_SRC elisp
  (defun $lisp-indent-function (indent-point state)
    "Override `lisp-indent-function' to properly handle plists. See the original function fo full description"
    (let ((normal-indent (current-column))
          (orig-point (point)))
      (goto-char (1+ (elt state 1)))
      (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
      (cond
       ;; car of form doesn't seem to be a symbol, or is a keyword
       ((and (elt state 2)
             (or (not (looking-at "\\sw\\|\\s_"))
                 (looking-at ":")))
        (if (not (> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp))
            (progn (goto-char calculate-lisp-indent-last-sexp)
                   (beginning-of-line)
                   (parse-partial-sexp (point)
                                       calculate-lisp-indent-last-sexp 0 t)))
        ;; Indent under the list or under the first sexp on the same
        ;; line as calculate-lisp-indent-last-sexp.  Note that first
        ;; thing on that line has to be complete sexp since we are
        ;; inside the innermost containing sexp.
        (backward-prefix-chars)
        (current-column))
       ((and (save-excursion
               (goto-char indent-point)
               (skip-syntax-forward " ")
               (not (looking-at ":")))
             (save-excursion
               (goto-char orig-point)
               (looking-at ":")))
        (save-excursion
          (goto-char (+ 2 (elt state 1)))
          (current-column)))
       (t
        (let ((function (buffer-substring (point)
                                          (progn (forward-sexp 1) (point))))
              method)
          (setq method (or (function-get (intern-soft function)
                                         'lisp-indent-function)
                           (get (intern-soft function) 'lisp-indent-hook)))
          (cond ((or (eq method 'defun)
                     (and (null method)
                          (> (length function) 3)
                          (string-match "\\`def" function)))
                 (lisp-indent-defform state indent-point))
                ((integerp method)
                 (lisp-indent-specform method state
                                       indent-point normal-indent))
                (method
                 (funcall method indent-point state))))))))

  (setq lisp-indent-function '$lisp-indent-function)
#+END_SRC

*** extra font lock
let's you visually distinguish between let bound dynamic and lexical
variables. also shows interpolated parts of backquoted sexps.

#+BEGIN_SRC elisp
  (use-package lisp-extra-font-lock
    :hook emacs-lisp-mode
    :config
    (dolist (fn '("when-let" "when-let*" "if-let" "if-let*" "-let" "-let*"))
      (add-to-list 'lisp-extra-font-lock-let-functions fn)))
#+END_SRC

*** quick expand
using speed of though lisp to quicky create edit emacs-lisp
#+BEGIN_SRC elisp
  (use-package sotlisp
    :hook emacs-lisp-mode)
#+END_SRC

*** macro step
#+BEGIN_SRC elisp
  (use-package macrostep
    :init
    (defhydra macrostep (:exit nil :foreign-keys run)
      "expand macros one step at a time"
      ("e" macrostep-expand "expand")
      ("c" macrostep-collapse "collapse")
      ("n" macrostep-next-macro "next")
      ("N" macrostep-prev-macro "prev")
      ("q" macrostep-collapse-all "quit" :exit t))
    ($leader-local-set-key
      :keymaps 'emacs-lisp-mode-map
      "m" 'macrostep/body))
#+END_SRC

*** benchmarking

emacs package dev handbook has some useful benchmarking fuctions
#+BEGIN_SRC elisp
  (use-package epdh
    :straight (:host github :repo "alphapapa/emacs-package-dev-handbook"))
#+END_SRC

Some useful macros for profiling and emacs code
#+BEGIN_SRC elisp
  (defmacro $profile (&rest body)
    "generate a CPU profile report for BODY"
    (require 'profiler)
    (when (profiler-running-p)
      (profiler-stop)
      (profiler-reset))
    `(progn (profiler-start 'cpu)
            ,@body
            (profiler-report)
            (profiler-stop)
            (profiler-reset)))

  (defun $set-keyboard-quit ()
    (setq unread-command-events
          (mapcar (lambda (e) `(t . ,e))
                  (listify-key-sequence (kbd "C-g")))))
#+END_SRC

*** suggest
the suggest packages tries to find the most optimal way to convert
forms.
#+BEGIN_SRC elisp
  (use-package suggest
    :general
    (:definer 'leader
     :keymaps 'emacs-lisp-mode-map
     "s" 'suggest))
#+END_SRC

** perl

cperl-mode is considered by the better perl mode, and it certainly has
more features. However I prefer to use perl-mode for the following
reasons:
1. the font lock cperl HERE docs and perldocs are broken. If you
   insert a newline in the middle of one of those multiline
   constructs, it will break for the rest of the document
2. cperl overhighlights, it tries to highlight array's and hashes in
   comments, and hash keys are highlighted in the same face as has
   values. Makes it harder to read
3. cperl defines a custom face for arrays and hashs that is really
   jarring. It can be overriden, but you have to do that for every
   theme that you are using
4. I don't really use any of the features in cperl mode, so I don't
   think it is worth using

#+BEGIN_SRC elisp
  (defalias 'cperl-mode 'perl-mode)
#+END_SRC

I use regular perl-mode for files that are considered read-only.
#+BEGIN_SRC elisp
  (use-package perl-mode
    :straight nil
    :mode (rx "." (or "ip_info" "espflist" "udf" "hdl" "map") eos)
    :init
    (setq perl-indent-parens-as-block t
          perl-continued-brace-offset 0
          perl-continued-statement-offset 0))
#+END_SRC

We also change =:= to be a punctuation character to match perl mode.
This fixes a ligature issue.
#+BEGIN_SRC elisp
  (use-package cperl-mode
    :straight nil
    :init
    (setq
     ;; highlight all scalar variables not just the instantiation
     cperl-highlight-variables-indiscriminately t
     cperl-indent-level 4        ; 4 spaces is the standard indentation
     cperl-close-paren-offset -4 ; indent the closing paren back four spaces
     cperl-continued-statement-offset 4 ; if a statement continues indent it to four spaces
     cperl-indent-parens-as-block t)
    :config
    (modify-syntax-entry ?: "." cperl-mode-syntax-table))
#+END_SRC

*** flycheck
#+BEGIN_SRC elisp
  (setq flycheck-perl-executable "/usr/intel/pkgs/perl/5.14.1/bin/perl"
          flycheck-perl-perlcritic-executable "/usr/intel/pkgs/perl/5.14.1-threads/bin/perlcritic"
          flycheck-perl-include-path '("/p/hdk/cad/spf/latest/lib/perl5"
                                       "../lib/perl5"
                                       "../../lib/perl5"
                                       ".."))
      (setenv "SPF_ROOT" "/p/hdk/cad/spf/latest")
      (setenv "SPF_PERL_LIB" "/p/hdk/cad/spf/latest/lib/perl5")
      (setenv "XWEAVE_REPO_ROOT" "/p/hdk/rtl/ip_releases/shdk74/xweave/v17ww43a")
      (setenv "IDS_HOME" "/p/hdk/rtl/cad/x86-64_linux26/dteg/ideas_shell/0.15.1")
#+END_SRC

*** font lock
highlight variables in strings
#+BEGIN_SRC elisp
  (font-lock-add-keywords 'perl-mode
                          `((,(rx (group-n 1 "$" (opt "{")) (group-n 2 (1+ (any alnum "_"))) (group-n 3 (opt "}")))
                             (1 (when (not (nth 4 (syntax-ppss)))
                                  'default)
                                prepend)
                             (2 (when (not (nth 4 (syntax-ppss)))
                                  font-lock-variable-name-face)
                                prepend)
                             (3 (when (not (nth 4 (syntax-ppss)))
                                  'default)
                                prepend))))
#+END_SRC

*** perltidy
perltidy is a perl foratting tool
#+BEGIN_SRC elisp
  (use-package perltidy
    :general
    (:definer 'leader
     :keymaps '(perl-mode-map
                cperl-mode-map)
     "f" '(:ignore t :wk "format")
     "fr" 'perltidy-region
     "ff" 'perltidy-dwim-safe
     "fb" 'perltidy-buffer
     "fs" 'perltidy-subroutine))
#+END_SRC

** python
Setting to add jump to definition, auto-complete, and formatting to python mode
#+BEGIN_SRC elisp
  (setq python-prettify-symbols-alist '(("lambda" . ?Î»))
        python-shell-interpreter "python3.6.3a"
        flycheck-python-flake8-executable "python3.6.3a"
        flycheck-python-mypy-executable "python3.6.3a"
        flycheck-python-pycompile-executable "python3.6.3a"
        flycheck-flake8-maximum-line-length 120
        flycheck-python-pylint-executable "python3.6.3a")

  (use-package company-anaconda
    :demand t
    :after python
    :config
    (add-to-list 'company-backends 'company-anaconda))
  (use-package yapfify)

  (use-package live-py-mode
    :custom
    (live-py-version "python3.6.3a"))

  (use-package python
    :straight nil
    :interpreter ("python[a-z0-9.]*" . python-mode)
    :gfhook
    #'anaconda-mode
    #'company-mode
    #'flycheck-mode
    :compdef python-mode
    :company (company-anaconda company-dabbrev-code company-capf)
    :general
    (:definer 'leader
     :keymaps 'python-mode-map
     "j" 'counsel-semantic-or-imenu))
#+END_SRC

Inferior shell
#+BEGIN_SRC elisp
  (defun $python-shell ()
    (interactive)
    (unless (python-shell-get-process)
      (run-python))
    (python-shell-switch-to-shell t))

  (general-def 'normal python-mode-map "gz" #'$python-shell)
#+END_SRC

** verilog
we have some nonstandard extensions for SV
#+BEGIN_SRC elisp
  (use-package verilog-mode
    :straight nil
    :mode (rx "." (or "hier" "vf" "svh" "vg" "vs" "rdl" "icl" "sv09") eos)
    :general
    (:definer 'leader
     :keymaps 'verilog-mode-map
     "j" 'counsel-semantic-or-imenu))

  (defun $verilog-imenu-populated ()
    (setq-local imenu-generic-expression
                `(("instances" ,($rx ^ spc+ (or (: (opt "#(") "." symbol "(" -> "))")
                                                (: symbol))
                                     spc (group symbol "_" symbol) eol) 1)
                  ("modules" ,($rx ^ "module " (group symbol) " (") 1)
                  ("functions" ,($rx ^ spc* "function" spc+ (opt (or "automatic" "static") spc+)
                                     (1+ symbol) spc+ (group symbol)) 1)
                  ("packages" ,($rx ^ spc* "package" spc+ (group symbol)) 1))))

  (add-hook 'verilog-mode-hook '$verilog-imenu-populated)
#+END_SRC

*** display
Ligatures in verilog are more complicated then in other languages
because the symbol =<== can be either a left arrow or a "less then or
equal" symbol. So we add an addition wrapper around the compose
function to handle this special case.
#+BEGIN_SRC elisp
  (defun $compose-conditional-symbol (alist)
    (or (and (eq major-mode 'verilog-mode)
             (equal (match-string 0) "<=")
             (not (looking-at-p (rx (or (: (0+ " ") "(" )
                                        (: (1+ (not (in "(\n"))) ")")))))
             `((("<=" . (?\s (Br . Bl) ?\s (Br . Br)
                             ,(decode-char 'ucs #xEF87))))) )
        alist))

  (with-eval-after-load 'prog-mode
    (advice-add 'prettify-symbols--compose-symbol :filter-args #'$compose-conditional-symbol))
#+END_SRC

Make radix notation stand out
#+BEGIN_SRC elisp
  (font-lock-add-keywords 'verilog-mode
                          `(("'" . 'error)
                            (,(rx (or bol "'h" "'b" "'d" (not (any "_" alnum)))
                                  (group (1+ digit)))
                             1 font-lock-constant-face)))
#+END_SRC

*** indentation
Everyone uses their own indentation for verilog, so use dtrt to
automatically detect it.
#+BEGIN_SRC elisp
  (use-package dtrt-indent
    :hook verilog-mode
    :config
    (add-to-list 'dtrt-indent-hook-mapping-list '(verilog-mode c/c++/java verilog-indent-level)))
#+END_SRC

** TCL
#+BEGIN_SRC elisp
  (use-package tcl-mode
    :straight nil
    :gfhook #'$tcl-fix-symbol-def
    :mode "\\.upf\\'"
    :mode "\\.pdl\\'"
    :mode "\\.dofile\\'"
    :mode "\\.tcl\\'"
    :company ((company-syntcl company-dabbrev-code) (company-capf company-dabbrev))
    :general
    ('normal tcl-mode-map "gz" 'inferior-tcl)
    (tcl-mode-map "TAB" 'indent-for-tab-command)
    :custom
    (flycheck-tcl-nagelfar-syntaxdb-file "~/temp/TclComplete/syntaxdb_tessent.tcl")
    (tcl-application "tclsh"))

  (defun $tcl-fix-symbol-def ()
    (modify-syntax-entry ?$ "." tcl-mode-syntax-table))
#+END_SRC

*** completion
#+BEGIN_SRC elisp
  (use-package company-syntcl
    :straight
    (:repo "https://gitlab.devtools.intel.com/emacs-users/company-syntcl.git"
     :files ("company-syntcl.el"))
    :custom
    (company-syntcl-dir "~/temp/TclComplete")
    :config
    (defun company-syntcl--annotation (_) nil))
#+END_SRC

** ICL
ICL is the Instrument Control Language defined by IEEE
#+BEGIN_SRC elisp
  (define-derived-mode icl-mode c-mode "ICL"
    (setq-local c-basic-offset 3)
    (setq-local indent-line-function 'icl-indent-line)
    (setq-local font-lock-defaults '(icl-font-lock-keywords))
    (modify-syntax-entry ?\' "." icl-mode-syntax-table))

  (add-to-list 'auto-mode-alist '("\\.icl\\'" . icl-mode))
#+END_SRC

The indentation function for ICL. Very similar to C
#+BEGIN_SRC elisp
  (defun icl-broken-line-p ()
    (save-excursion
      (previous-line)
      (end-of-line)
      (skip-syntax-backward " " (line-beginning-position))
      (save-match-data
        (looking-back (rx (or "Of" "SelectedBy" "=")) (line-beginning-position)))))

  (defun icl-indent-line ()
    (interactive)
    (if (icl-broken-line-p)
        (let ((c-basic-offset 4))
          (c-indent-line))
      (c-indent-line)))
#+END_SRC

*** Keywords
#+BEGIN_SRC elisp
  (setq icl-font-lock-keywords
        `((,(rx symbol-start "Attribute" symbol-end) 0 font-lock-variable-name-face)
          (,(rx symbol-start (or "Instance" "Module" "Enum") symbol-end)
           0 font-lock-function-name-face)
          (,($rx ^ spc* (group upper (1+ alnum)) spc+) 1 font-lock-keyword-face)
          (,(rx symbol-start (or "InputPort"
                                 "Alias"
                                 "ClockMux"
                                 "DataMux"
                                 "ScanMux")
                symbol-end)
           0 font-lock-keyword-face)
          (,(rx (char " [':") (group (opt (char "bh")) (1+ digit))) 1 font-lock-type-face)
          (,(rx ".") 0 'error)
          (,($rx spc+ (group (or "Of" "SelectedBy"))) 1 font-lock-builtin-face)))
#+END_SRC

** config spec
Major mode for tessent spec files
#+BEGIN_SRC elisp
  (define-derived-mode tessent-spec-mode java-mode "Tessent Spec"
    (setq-local c-basic-offset 2))

  (add-to-list 'auto-mode-alist
               `(,(rx (or "meta_spec" "tessent_meta") eos) . tessent-spec-mode))
#+END_SRC

** json
add hide-show support to json mode and make comments properly font
locked
#+BEGIN_SRC elisp
  (use-package json-mode
    :gfhook 'flycheck-mode 'hs-minor-mode
    :init
    (setq flycheck-json-python-json-executable "python3.6.3")
    :config
    (add-to-list 'hs-special-modes-alist (list 'json-mode (rx (any "{[")) (rx (any "]}")) (rx "/" (any "/*"))))
    (font-lock-add-keywords 'json-mode
                            `((,(rx (group "//" (0+ nonl)) eol) 1 font-lock-comment-face))))
#+END_SRC

we are using the design_report.json as reference for our json coding
standard. This varies from the standard json Emacs json pretty printer in
the following ways:
- add a space before plist seperators
- use empty objects ={}= instead of =null=. null causes the json
  reader to choke
- indentation level is 4

#+BEGIN_SRC elisp
  (setq json-encoding-default-indentation "    ")

  (advice-add 'json-pretty-print :after
              (defun $json-convert-null-to-emtpy-obj (beg end)
                (save-excursion
                  (goto-char beg)
                  (while (re-search-forward (rx ": null") end 'noerror)
                    (replace-match ": {}")))))

  (el-patch-defun json-encode-alist (alist)
    "Return a JSON representation of ALIST."
    (when json-encoding-object-sort-predicate
      (setq alist
            (sort alist (lambda (a b)
                          (funcall json-encoding-object-sort-predicate
                                   (car a) (car b))))))
    (format "{%s%s}"
            (json-join
             (json--with-indentation
              (mapcar (lambda (cons)
                        (format (if json-encoding-pretty-print
                                    (el-patch-swap "%s%s: %s" "%s%s : %s")
                                  "%s%s:%s")
                                json--encoding-current-indentation
                                (json-encode-key (car cons))
                                (json-encode (cdr cons))))
                      alist))
             json-encoding-separator)
            (if (or (not json-encoding-pretty-print)
                    json-encoding-lisp-style-closings)
                ""
              json--encoding-current-indentation)))
#+END_SRC

** makefile
#+BEGIN_SRC elisp
  (add-to-list 'interpreter-mode-alist '("gmake" . makefile-gmake-mode))
#+END_SRC

** shell script

Highlight command arguments to help them stand out
#+BEGIN_SRC elisp
  (font-lock-add-keywords 'sh-mode
                          `((,($rx spc (group (>= 1 (in "-")) symbol))
                             1 font-lock-constant-face)))
#+END_SRC

*** tcsh
Tcsh is poorly supported in Emacs. The worst offender is the default
indentation, which is totally broken. This code ripped from [[https://github.com/Tux/tcsh/blob/master/csh-mode.el][csh-mode]]
fixes that.
#+BEGIN_SRC elisp
  (defun $tcsh-set-indent-functions ()
    (when (eq sh-shell 'tcsh)
      (load-file (expand-file-name "csh-indent-function.el" user-emacs-directory))
      (setq-local indent-line-function 'csh-indent-line)
      (setq-local indent-region-function 'csh-indent-region)))

  (add-hook 'sh-set-shell-hook #'$tcsh-set-indent-functions)
#+END_SRC

** markdown
#+BEGIN_SRC elisp
  (use-package markdown-mode)
#+END_SRC

** other
collection of major modes that I use for different file types.
#+BEGIN_SRC elisp
  (use-package major-modes
    :straight
    (:host gitlab :repo "foconoco/major-modes")
    :init
    ($leader-local-set-key
      :keymaps 'spfspec-mode-map
      "g" 'spfspec-goto-definition))
#+END_SRC

when I break out major-modes into different packages this should not
longer be necessary
#+BEGIN_SRC elisp
  (use-package highlight-numbers
    :hook log-mode
    :config
    (setq highlight-numbers-generic-regexp
          ($rx (or (seq "0x" (1+ hex))
                   (seq "'" nums "'")
                   (seq (or bol spc ":")
                        (or (seq nums (any "./-") nums)
                            nums))))))
#+END_SRC

itools is a conf file
#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist `(,(rx "itools" eos) . conf-mode))
#+END_SRC

simple mode for par.txt
#+BEGIN_SRC elisp
  (defvar par-mode-keywords
    `((,($rx bol (group symbol)) 1 font-lock-keyword-face)))

  (define-derived-mode par-mode fundamental-mode "par.txt"
    "Major mode for par.txt files"
    (setq-local font-lock-defaults '(par-mode-keywords)))

  (add-to-list 'auto-mode-alist `(,(rx "par.txt" eos) . par-mode))
#+END_SRC

Use dyanmic space in par mode. Meaning that we can editing something
and will automatically adjust the whitespace
#+BEGIN_SRC elisp
  (use-package dynamic-spaces
    :hook par-mode)
#+END_SRC

Function to reload the postsim file after changing the post process
#+BEGIN_SRC elisp
(defun $rerun-postprocess ()
  "Rerun the postprocess file for the current postsim"
  (interactive)
  (let ((file (buffer-file-name))
        (cmdline (save-excursion
                   (goto-char (point-min))
                   (when (re-search-forward ($rx bol "POSTSIM CMDLINE: " (group ->)))
                     (match-string 1))))
        (shell-file-name "/usr/intel/bin/tcsh")
        (src-file (car (file-expand-wildcards
                        (expand-file-name
                         "target/*/collage/work/*/setup_collage_assembler.*_collage_assemble.csh"
                         ($model-root))))))
    (if cmdline
        (progn
          (setq cmdline
                (thread-last (unless (string-prefix-p "-force" cmdline)
                               (concat cmdline " -force"))
                  (replace-regexp-in-string ($rx "/tmp/netbatch/" -> "//") "$MODEL_ROOT/" )
                  (replace-regexp-in-string (rx "acerun.log" symbol-end) "acerun.log.gz")))
          (shell-command-to-string
           (format "source %s && setenv PATH ${PATH}:$ACE_HOME/bin && %s" src-file cmdline))
          (if (string-suffix-p ".gz" file)
              (progn (kill-buffer)
                     (find-file (string-remove-suffix ".gz" file))))
          (auto-revert-mode))
      (user-error "commandline not found"))))
#+END_SRC


*** digit groups
allows us to more easily read binary numbers by visually grouping them
into nibbles.

#+BEGIN_SRC elisp
  (use-package digit-groups
    :hook (spfspec-mode itpp-mode)
    :init
    (require 'dash)
    (setq digit-groups-digits "01LHX"
          digit-groups-groups
          (mapcar (lambda (x) `(,x . digit-groups-default-face))
                  (--mapcat (list (+ 7 (* 8 it)) (+ 6 (* 8 it)) (+ 5 (* 8 it)) (+ 4 (* 8 it)))
                            '(9 8 7 6 5 4 3 2 1 0))))
    :config
    (set-face-attribute 'digit-groups-default-face nil :underline t))
#+END_SRC
